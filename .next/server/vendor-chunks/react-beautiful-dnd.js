"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-beautiful-dnd";
exports.ids = ["vendor-chunks/react-beautiful-dnd"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable),\n/* harmony export */   resetServerContext: () => (/* binding */ resetServerContext),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/es/index.js\");\n/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! use-memo-one */ \"(ssr)/./node_modules/use-memo-one/dist/use-memo-one.esm.js\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n\n\n\n\nvar isProduction = \"development\" === \"production\";\nvar spacesAndTabs = /[ \\t]{2,}/g;\nvar lineStartWithSpaces = /^[ \\t]*/gm;\nvar clean = function clean(value) {\n    return value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\n};\nvar getDevMessage = function getDevMessage(message) {\n    return clean(\"\\n  %creact-beautiful-dnd\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77‚Äç This is a development only message. It will be removed in production builds.\\n\");\n};\nvar getFormattedMessage = function getFormattedMessage(message) {\n    return [\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\n};\nvar isDisabledFlag = \"__react-beautiful-dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    var _console;\n    if (isProduction) {\n        return;\n    }\n    if (false) {}\n    (_console = console)[type].apply(_console, getFormattedMessage(message));\n}\nvar warning = log.bind(null, \"warn\");\nvar error = log.bind(null, \"error\");\nfunction noop() {}\nfunction getOptions(shared, fromBinding) {\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, shared, {}, fromBinding);\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    var unbindings = bindings.map(function(binding) {\n        var options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach(function(unbind) {\n            unbind();\n        });\n    };\n}\nvar isProduction$1 = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction RbdInvariant(message) {\n    this.message = message;\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction$1) {\n        throw new RbdInvariant(prefix);\n    } else {\n        throw new RbdInvariant(prefix + \": \" + (message || \"\"));\n    }\n}\nvar ErrorBoundary = function(_React$Component) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ErrorBoundary, _React$Component);\n    function ErrorBoundary() {\n        var _this;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [\n            this\n        ].concat(args)) || this;\n        _this.callbacks = null;\n        _this.unbind = noop;\n        _this.onWindowError = function(event) {\n            var callbacks = _this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(\"\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\n        The active drag has been aborted.\\n      \") : 0;\n            }\n            var err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        _this.getCallbacks = function() {\n            if (!_this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return _this.callbacks;\n        };\n        _this.setCallbacks = function(callbacks) {\n            _this.callbacks = callbacks;\n        };\n        return _this;\n    }\n    var _proto = ErrorBoundary.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    };\n    _proto.componentDidCatch = function componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.unbind();\n    };\n    _proto.render = function render() {\n        return this.props.children(this.setCallbacks);\n    };\n    return ErrorBoundary;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\nvar dragHandleUsageInstructions = \"\\n  Press space bar to start a drag.\\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\\n  Some screen readers may require you to be in focus mode or to use your pass through key\\n\";\nvar position = function position(index) {\n    return index + 1;\n};\nvar onDragStart = function onDragStart(start) {\n    return \"\\n  You have lifted an item in position \" + position(start.source.index) + \"\\n\";\n};\nvar withLocation = function withLocation(source, destination) {\n    var isInHomeList = source.droppableId === destination.droppableId;\n    var startPosition = position(source.index);\n    var endPosition = position(destination.index);\n    if (isInHomeList) {\n        return \"\\n      You have moved the item from position \" + startPosition + \"\\n      to position \" + endPosition + \"\\n    \";\n    }\n    return \"\\n    You have moved the item from position \" + startPosition + \"\\n    in list \" + source.droppableId + \"\\n    to list \" + destination.droppableId + \"\\n    in position \" + endPosition + \"\\n  \";\n};\nvar withCombine = function withCombine(id, source, combine) {\n    var inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return \"\\n      The item \" + id + \"\\n      has been combined with \" + combine.draggableId;\n    }\n    return \"\\n      The item \" + id + \"\\n      in list \" + source.droppableId + \"\\n      has been combined with \" + combine.draggableId + \"\\n      in list \" + combine.droppableId + \"\\n    \";\n};\nvar onDragUpdate = function onDragUpdate(update) {\n    var location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    var combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nvar returnedToStart = function returnedToStart(source) {\n    return \"\\n  The item has returned to its starting position\\n  of \" + position(source.index) + \"\\n\";\n};\nvar onDragEnd = function onDragEnd(result) {\n    if (result.reason === \"CANCEL\") {\n        return \"\\n      Movement cancelled.\\n      \" + returnedToStart(result.source) + \"\\n    \";\n    }\n    var location = result.destination;\n    var combine = result.combine;\n    if (location) {\n        return \"\\n      You have dropped the item.\\n      \" + withLocation(result.source, location) + \"\\n    \";\n    }\n    if (combine) {\n        return \"\\n      You have dropped the item.\\n      \" + withCombine(result.draggableId, result.source, combine) + \"\\n    \";\n    }\n    return \"\\n    The item has been dropped while not over a drop area.\\n    \" + returnedToStart(result.source) + \"\\n  \";\n};\nvar preset = {\n    dragHandleUsageInstructions: dragHandleUsageInstructions,\n    onDragStart: onDragStart,\n    onDragUpdate: onDragUpdate,\n    onDragEnd: onDragEnd\n};\nvar origin = {\n    x: 0,\n    y: 0\n};\nvar add = function add(point1, point2) {\n    return {\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    };\n};\nvar subtract = function subtract(point1, point2) {\n    return {\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    };\n};\nvar isEqual = function isEqual(point1, point2) {\n    return point1.x === point2.x && point1.y === point2.y;\n};\nvar negate = function negate(point) {\n    return {\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    };\n};\nvar patch = function patch(line, value, otherValue) {\n    var _ref;\n    if (otherValue === void 0) {\n        otherValue = 0;\n    }\n    return _ref = {}, _ref[line] = value, _ref[line === \"x\" ? \"y\" : \"x\"] = otherValue, _ref;\n};\nvar distance = function distance(point1, point2) {\n    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\nvar closest = function closest(target, points) {\n    return Math.min.apply(Math, points.map(function(point) {\n        return distance(target, point);\n    }));\n};\nvar apply = function apply(fn) {\n    return function(point) {\n        return {\n            x: fn(point.x),\n            y: fn(point.y)\n        };\n    };\n};\nvar executeClip = function(frame, subject) {\n    var result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nvar offsetByPosition = function offsetByPosition(spacing, point) {\n    return {\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    };\n};\nvar getCorners = function getCorners(spacing) {\n    return [\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\n};\nvar noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nvar scroll = function scroll(target, frame) {\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nvar increase = function increase(target, axis, withPlaceholder) {\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        var _extends2;\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\n    }\n    return target;\n};\nvar clip = function clip(target, frame) {\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(target);\n};\nvar getSubject = function(_ref) {\n    var page = _ref.page, withPlaceholder = _ref.withPlaceholder, axis = _ref.axis, frame = _ref.frame;\n    var scrolled = scroll(page.marginBox, frame);\n    var increased = increase(scrolled, axis, withPlaceholder);\n    var clipped = clip(increased, frame);\n    return {\n        page: page,\n        withPlaceholder: withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = function(droppable, newScroll) {\n    !droppable.frame ?  true ? invariant(false) : 0 : void 0;\n    var scrollable = droppable.frame;\n    var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    var scrollDisplacement = negate(scrollDiff);\n    var frame = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, scrollable, {\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    });\n    var subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame: frame\n    });\n    var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n        frame: frame,\n        subject: subject\n    });\n    return result;\n};\nfunction isInteger(value) {\n    if (Number.isInteger) {\n        return Number.isInteger(value);\n    }\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n}\nfunction values(map) {\n    if (Object.values) {\n        return Object.values(map);\n    }\n    return Object.keys(map).map(function(key) {\n        return map[key];\n    });\n}\nfunction findIndex(list, predicate) {\n    if (list.findIndex) {\n        return list.findIndex(predicate);\n    }\n    for(var i = 0; i < list.length; i++){\n        if (predicate(list[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction find(list, predicate) {\n    if (list.find) {\n        return list.find(predicate);\n    }\n    var index = findIndex(list, predicate);\n    if (index !== -1) {\n        return list[index];\n    }\n    return undefined;\n}\nfunction toArray(list) {\n    return Array.prototype.slice.call(list);\n}\nvar toDroppableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppables) {\n    return droppables.reduce(function(previous, current) {\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {});\n});\nvar toDraggableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(draggables) {\n    return draggables.reduce(function(previous, current) {\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {});\n});\nvar toDroppableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppables) {\n    return values(droppables);\n});\nvar toDraggableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(draggables) {\n    return values(draggables);\n});\nvar getDraggablesInsideDroppable = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppableId, draggables) {\n    var result = toDraggableList(draggables).filter(function(draggable) {\n        return droppableId === draggable.descriptor.droppableId;\n    }).sort(function(a, b) {\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(remove, list) {\n    return list.filter(function(item) {\n        return item.descriptor.id !== remove.descriptor.id;\n    });\n});\nvar moveToNextCombine = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, draggable = _ref.draggable, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    var location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        var at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, previousImpact, {\n            at: at\n        });\n    }\n    var all = previousImpact.displaced.all;\n    var closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        var last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    var indexOfClosest = findIndex(withoutDraggable, function(d) {\n        return d.descriptor.id === closestId;\n    });\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    var proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    var before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = function(draggable, destination) {\n    return draggable.descriptor.droppableId === destination.descriptor.id;\n};\nvar noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nvar emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nvar noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar isWithin = function(lowerBound, upperBound) {\n    return function(value) {\n        return lowerBound <= value && value <= upperBound;\n    };\n};\nvar isPartiallyVisibleThroughFrame = function(frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function(subject) {\n        var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = function(frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function(subject) {\n        var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nvar vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nvar horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = function(axis) {\n    return function(frame) {\n        var isWithinVertical = isWithin(frame.top, frame.bottom);\n        var isWithinHorizontal = isWithin(frame.left, frame.right);\n        return function(subject) {\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\n};\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\n    var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\n    return isVisibleThroughFrameFn(viewport)(target);\n};\nvar isVisible = function isVisible(_ref) {\n    var toBeDisplaced = _ref.target, destination = _ref.destination, viewport = _ref.viewport, withDroppableDisplacement = _ref.withDroppableDisplacement, isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\n    var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nvar isPartiallyVisible = function isPartiallyVisible(args) {\n    return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, args, {\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    }));\n};\nvar isTotallyVisible = function isTotallyVisible(args) {\n    return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, args, {\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    }));\n};\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\n    return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, args, {\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    }));\n};\nvar getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    var invisible = last.invisible, visible = last.visible;\n    if (invisible[id]) {\n        return false;\n    }\n    var previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    var marginBox = draggable.page.marginBox;\n    var expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups(_ref) {\n    var afterDragging = _ref.afterDragging, destination = _ref.destination, displacedBy = _ref.displacedBy, viewport = _ref.viewport, forceShouldAnimate = _ref.forceShouldAnimate, last = _ref.last;\n    return afterDragging.reduce(function process(groups, draggable) {\n        var target = getTarget(draggable, displacedBy);\n        var id = draggable.descriptor.id;\n        groups.all.push(id);\n        var isVisible = isPartiallyVisible({\n            target: target,\n            destination: destination,\n            viewport: viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        var displacement = {\n            draggableId: id,\n            shouldAnimate: shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd(_ref) {\n    var insideDestination = _ref.insideDestination, inHomeList = _ref.inHomeList, displacedBy = _ref.displacedBy, destination = _ref.destination;\n    var newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList: inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy: displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact(_ref2) {\n    var draggable = _ref2.draggable, insideDestination = _ref2.insideDestination, destination = _ref2.destination, viewport = _ref2.viewport, displacedBy = _ref2.displacedBy, last = _ref2.last, index = _ref2.index, forceShouldAnimate = _ref2.forceShouldAnimate;\n    var inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination: insideDestination,\n            inHomeList: inHomeList,\n            displacedBy: displacedBy,\n            destination: destination\n        });\n    }\n    var match = find(insideDestination, function(item) {\n        return item.descriptor.index === index;\n    });\n    if (!match) {\n        return goAtEnd({\n            insideDestination: insideDestination,\n            inHomeList: inHomeList,\n            displacedBy: displacedBy,\n            destination: destination\n        });\n    }\n    var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    var sliceFrom = insideDestination.indexOf(match);\n    var impacted = withoutDragging.slice(sliceFrom);\n    var displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination: destination,\n        displacedBy: displacedBy,\n        last: last,\n        viewport: viewport.frame,\n        forceShouldAnimate: forceShouldAnimate\n    });\n    return {\n        displaced: displaced,\n        displacedBy: displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, destination = _ref.destination, draggables = _ref.draggables, combine = _ref.combine, afterCritical = _ref.afterCritical;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    var combineId = combine.draggableId;\n    var combineWith = draggables[combineId];\n    var combineWithIndex = combineWith.descriptor.index;\n    var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, insideDestination = _ref.insideDestination, location = _ref.location;\n    if (!insideDestination.length) {\n        return null;\n    }\n    var currentIndex = location.index;\n    var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    var firstIndex = insideDestination[0].descriptor.index;\n    var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    var upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, draggable = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        var _newIndex = fromReorder({\n            isMovingForward: isMovingForward,\n            isInHomeList: isInHomeList,\n            location: wasAt.destination,\n            insideDestination: insideDestination\n        });\n        if (_newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable: draggable,\n            insideDestination: insideDestination,\n            destination: destination,\n            viewport: viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: _newIndex\n        });\n    }\n    var newIndex = fromCombine({\n        isMovingForward: isMovingForward,\n        destination: destination,\n        displaced: previousImpact.displaced,\n        draggables: draggables,\n        combine: wasAt.combine,\n        afterCritical: afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable: draggable,\n        insideDestination: insideDestination,\n        destination: destination,\n        viewport: viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = function(_ref) {\n    var displaced = _ref.displaced, afterCritical = _ref.afterCritical, combineWith = _ref.combineWith, displacedBy = _ref.displacedBy;\n    var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = function(_ref) {\n    var afterCritical = _ref.afterCritical, impact = _ref.impact, draggables = _ref.draggables;\n    var combine = tryGetCombine(impact);\n    !combine ?  true ? invariant(false) : 0 : void 0;\n    var combineWith = combine.draggableId;\n    var center = draggables[combineWith].page.borderBox.center;\n    var displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical: afterCritical,\n        combineWith: combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\n    return box.margin[axis.start] + box.borderBox[axis.size] / 2;\n};\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\n    return box.margin[axis.end] + box.borderBox[axis.size] / 2;\n};\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\n    return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\n};\nvar goAfter = function goAfter(_ref) {\n    var axis = _ref.axis, moveRelativeTo = _ref.moveRelativeTo, isMoving = _ref.isMoving;\n    return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goBefore = function goBefore(_ref2) {\n    var axis = _ref2.axis, moveRelativeTo = _ref2.moveRelativeTo, isMoving = _ref2.isMoving;\n    return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goIntoStart = function goIntoStart(_ref3) {\n    var axis = _ref3.axis, moveInto = _ref3.moveInto, isMoving = _ref3.isMoving;\n    return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n};\nvar whenReordering = function(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, draggables = _ref.draggables, droppable = _ref.droppable, afterCritical = _ref.afterCritical;\n    var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    var draggablePage = draggable.page;\n    var axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis: axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    var displaced = impact.displaced, displacedBy = impact.displacedBy;\n    var closestAfter = displaced.all[0];\n    if (closestAfter) {\n        var closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis: axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        var withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis: axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    var last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis: axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis: axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = function(droppable, point) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, droppable = _ref.droppable, draggables = _ref.draggables, afterCritical = _ref.afterCritical;\n    var original = draggable.page.borderBox.center;\n    var at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact: impact,\n            draggable: draggable,\n            draggables: draggables,\n            droppable: droppable,\n            afterCritical: afterCritical\n        });\n    }\n    return whenCombining({\n        impact: impact,\n        draggables: draggables,\n        afterCritical: afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = function(args) {\n    var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    var droppable = args.droppable;\n    var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = function(viewport, newScroll) {\n    var diff = subtract(newScroll, viewport.scroll.initial);\n    var displacement = negate(diff);\n    var frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    var updated = {\n        frame: frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement: displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map(function(id) {\n        return draggables[id];\n    });\n}\nfunction tryGetVisible(id, groups) {\n    for(var i = 0; i < groups.length; i++){\n        var displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = function(_ref) {\n    var impact = _ref.impact, viewport = _ref.viewport, destination = _ref.destination, draggables = _ref.draggables, maxScrollChange = _ref.maxScrollChange;\n    var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    var last = impact.displaced;\n    var withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables(last.all, draggables),\n        destination: destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last: last,\n        forceShouldAnimate: false\n    });\n    var withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last: last,\n        forceShouldAnimate: false\n    });\n    var invisible = {};\n    var visible = {};\n    var groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach(function(id) {\n        var displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    var newImpact = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, impact, {\n        displaced: {\n            all: last.all,\n            invisible: invisible,\n            visible: visible\n        }\n    });\n    return newImpact;\n};\nvar withViewportDisplacement = function(viewport, point) {\n    return add(viewport.scroll.diff.displacement, point);\n};\nvar getClientFromPageBorderBoxCenter = function(_ref) {\n    var pageBorderBoxCenter = _ref.pageBorderBoxCenter, draggable = _ref.draggable, viewport = _ref.viewport;\n    var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = function(_ref) {\n    var draggable = _ref.draggable, destination = _ref.destination, newPageBorderBoxCenter = _ref.newPageBorderBoxCenter, viewport = _ref.viewport, withDroppableDisplacement = _ref.withDroppableDisplacement, _ref$onlyOnMainAxis = _ref.onlyOnMainAxis, onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\n    var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    var args = {\n        target: shifted,\n        destination: destination,\n        withDroppableDisplacement: withDroppableDisplacement,\n        viewport: viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, draggable = _ref.draggable, destination = _ref.destination, draggables = _ref.draggables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, previousClientSelection = _ref.previousClientSelection, afterCritical = _ref.afterCritical;\n    if (!destination.isEnabled) {\n        return null;\n    }\n    var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    var isInHomeList = isHomeOf(draggable, destination);\n    var impact = moveToNextCombine({\n        isMovingForward: isMovingForward,\n        draggable: draggable,\n        destination: destination,\n        insideDestination: insideDestination,\n        previousImpact: previousImpact\n    }) || moveToNextIndex({\n        isMovingForward: isMovingForward,\n        isInHomeList: isInHomeList,\n        draggable: draggable,\n        draggables: draggables,\n        destination: destination,\n        insideDestination: insideDestination,\n        previousImpact: previousImpact,\n        viewport: viewport,\n        afterCritical: afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact: impact,\n        draggable: draggable,\n        droppable: destination,\n        draggables: draggables,\n        afterCritical: afterCritical\n    });\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable: draggable,\n        destination: destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        var clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter: pageBorderBoxCenter,\n            draggable: draggable,\n            viewport: viewport\n        });\n        return {\n            clientSelection: clientSelection,\n            impact: impact,\n            scrollJumpRequest: null\n        };\n    }\n    var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    var cautious = speculativelyIncrease({\n        impact: impact,\n        viewport: viewport,\n        destination: destination,\n        draggables: draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nvar getKnownActive = function getKnownActive(droppable) {\n    var rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, pageBorderBoxCenter = _ref.pageBorderBoxCenter, source = _ref.source, droppables = _ref.droppables, viewport = _ref.viewport;\n    var active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    var axis = source.axis;\n    var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    var candidates = toDroppableList(droppables).filter(function(droppable) {\n        return droppable !== source;\n    }).filter(function(droppable) {\n        return droppable.isEnabled;\n    }).filter(function(droppable) {\n        return Boolean(droppable.subject.active);\n    }).filter(function(droppable) {\n        return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\n    }).filter(function(droppable) {\n        var activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter(function(droppable) {\n        var activeOfTarget = getKnownActive(droppable);\n        var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort(function(a, b) {\n        var first = getKnownActive(a)[axis.crossAxisStart];\n        var second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter(function(droppable, index, array) {\n        return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    var contains = candidates.filter(function(droppable) {\n        var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort(function(a, b) {\n            return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n        })[0];\n    }\n    return candidates.sort(function(a, b) {\n        var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {\n    var original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {\n    var original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = function(_ref) {\n    var pageBorderBoxCenter = _ref.pageBorderBoxCenter, viewport = _ref.viewport, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;\n    var sorted = insideDestination.filter(function(draggable) {\n        return isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination: destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        });\n    }).sort(function(a, b) {\n        var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function getDisplacedBy(axis, displaceBy) {\n    var displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\n    var axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    var availableSpace = droppable.subject.page.contentBox[axis.size];\n    var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    var spaceUsed = insideDroppable.reduce(function(sum, dimension) {\n        return sum + dimension.client.marginBox[axis.size];\n    }, 0);\n    var requiredSpace = spaceUsed + placeholderSize[axis.line];\n    var needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nvar withMaxScroll = function withMaxScroll(frame, max) {\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, frame, {\n        scroll: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, frame.scroll, {\n            max: max\n        })\n    });\n};\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\n    var frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    var added = {\n        placeholderSize: placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        var _subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n            subject: _subject\n        });\n    }\n    var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    var newFrame = withMaxScroll(frame, maxScroll);\n    var subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n        subject: subject,\n        frame: newFrame\n    });\n};\nvar removePlaceholder = function removePlaceholder(droppable) {\n    var added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    var frame = droppable.frame;\n    if (!frame) {\n        var _subject2 = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n            subject: _subject2\n        });\n    }\n    var oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    var newFrame = withMaxScroll(frame, oldMaxScroll);\n    var subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n        subject: subject,\n        frame: newFrame\n    });\n};\nvar moveToNewDroppable = function(_ref) {\n    var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, moveRelativeTo = _ref.moveRelativeTo, insideDestination = _ref.insideDestination, draggable = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        var proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable: draggable,\n            droppable: destination,\n            draggables: draggables,\n            afterCritical: afterCritical\n        });\n        var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable: draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    var proposedIndex = function() {\n        var relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    }();\n    var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable: draggable,\n        insideDestination: insideDestination,\n        destination: destination,\n        viewport: viewport,\n        displacedBy: displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, draggable = _ref.draggable, isOver = _ref.isOver, draggables = _ref.draggables, droppables = _ref.droppables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var destination = getBestCrossAxisDroppable({\n        isMovingForward: isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables: droppables,\n        viewport: viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    var moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport: viewport,\n        destination: destination,\n        insideDestination: insideDestination,\n        afterCritical: afterCritical\n    });\n    var impact = moveToNewDroppable({\n        previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n        destination: destination,\n        draggable: draggable,\n        draggables: draggables,\n        moveRelativeTo: moveRelativeTo,\n        insideDestination: insideDestination,\n        viewport: viewport,\n        afterCritical: afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact: impact,\n        draggable: draggable,\n        droppable: destination,\n        draggables: draggables,\n        afterCritical: afterCritical\n    });\n    var clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter: pageBorderBoxCenter,\n        draggable: draggable,\n        viewport: viewport\n    });\n    return {\n        clientSelection: clientSelection,\n        impact: impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = function(impact) {\n    var at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nvar getDroppableOver = function getDroppableOver(impact, droppables) {\n    var id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = function(_ref) {\n    var state = _ref.state, type = _ref.type;\n    var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);\n    var isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    var home = state.dimensions.droppables[state.critical.droppable.id];\n    var isOver = isActuallyOver || home;\n    var direction = isOver.axis.direction;\n    var isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    var isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    var draggable = state.dimensions.draggables[state.critical.draggable.id];\n    var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    var _state$dimensions = state.dimensions, draggables = _state$dimensions.draggables, droppables = _state$dimensions.droppables;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward: isMovingForward,\n        previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n        draggable: draggable,\n        destination: isOver,\n        draggables: draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward: isMovingForward,\n        previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n        draggable: draggable,\n        isOver: isOver,\n        draggables: draggables,\n        droppables: droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway(_ref) {\n    var pageBorderBox = _ref.pageBorderBox, draggable = _ref.draggable, candidates = _ref.candidates;\n    var startCenter = draggable.page.borderBox.center;\n    var sorted = candidates.map(function(candidate) {\n        var axis = candidate.axis;\n        var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort(function(a, b) {\n        return b.distance - a.distance;\n    });\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver$1(_ref2) {\n    var pageBorderBox = _ref2.pageBorderBox, draggable = _ref2.draggable, droppables = _ref2.droppables;\n    var candidates = toDroppableList(droppables).filter(function(item) {\n        if (!item.isEnabled) {\n            return false;\n        }\n        var active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        var axis = item.axis;\n        var childCenter = active.center[axis.crossAxisLine];\n        var crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        var isStartContained = isContained(crossAxisStart);\n        var isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox: pageBorderBox,\n        draggable: draggable,\n        candidates: candidates\n    });\n}\nvar offsetRectByPosition = function offsetRectByPosition(rect, point) {\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(offsetByPosition(rect, point));\n};\nvar withDroppableScroll = function(droppable, area) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced(_ref) {\n    var displaced = _ref.displaced, id = _ref.id;\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex(_ref) {\n    var draggable = _ref.draggable, closest = _ref.closest, inHomeList = _ref.inHomeList;\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = function(_ref2) {\n    var targetRect = _ref2.pageBorderBoxWithDroppableScroll, draggable = _ref2.draggable, destination = _ref2.destination, insideDestination = _ref2.insideDestination, last = _ref2.last, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;\n    var axis = destination.axis;\n    var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    var displacement = displacedBy.value;\n    var targetStart = targetRect[axis.start];\n    var targetEnd = targetRect[axis.end];\n    var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    var closest = find(withoutDragging, function(child) {\n        var id = child.descriptor.id;\n        var childCenter = child.page.borderBox.center[axis.line];\n        var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        var isDisplaced = getIsDisplaced({\n            displaced: last,\n            id: id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    });\n    var newIndex = atIndex({\n        draggable: draggable,\n        closest: closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable: draggable,\n        insideDestination: insideDestination,\n        destination: destination,\n        viewport: viewport,\n        last: last,\n        displacedBy: displacedBy,\n        index: newIndex\n    });\n};\nvar combineThresholdDivisor = 4;\nvar getCombineImpact = function(_ref) {\n    var draggable = _ref.draggable, targetRect = _ref.pageBorderBoxWithDroppableScroll, previousImpact = _ref.previousImpact, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    var axis = destination.axis;\n    var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    var displacement = displacedBy.value;\n    var targetStart = targetRect[axis.start];\n    var targetEnd = targetRect[axis.end];\n    var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    var combineWith = find(withoutDragging, function(child) {\n        var id = child.descriptor.id;\n        var childRect = child.page.borderBox;\n        var childSize = childRect[axis.size];\n        var threshold = childSize / combineThresholdDivisor;\n        var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        var isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id: id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    var impact = {\n        displacedBy: displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = function(_ref) {\n    var pageOffset = _ref.pageOffset, draggable = _ref.draggable, draggables = _ref.draggables, droppables = _ref.droppables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    var destinationId = getDroppableOver$1({\n        pageBorderBox: pageBorderBox,\n        draggable: draggable,\n        droppables: droppables\n    });\n    if (!destinationId) {\n        return noImpact;\n    }\n    var destination = droppables[destinationId];\n    var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,\n        draggable: draggable,\n        previousImpact: previousImpact,\n        destination: destination,\n        insideDestination: insideDestination,\n        afterCritical: afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,\n        draggable: draggable,\n        destination: destination,\n        insideDestination: insideDestination,\n        last: previousImpact.displaced,\n        viewport: viewport,\n        afterCritical: afterCritical\n    });\n};\nvar patchDroppableMap = function(droppables, updated) {\n    var _extends2;\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\n};\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\n    var previousImpact = _ref.previousImpact, impact = _ref.impact, droppables = _ref.droppables;\n    var last = whatIsDraggedOver(previousImpact);\n    var now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    var lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    var updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = function(_ref2) {\n    var draggable = _ref2.draggable, draggables = _ref2.draggables, droppables = _ref2.droppables, previousImpact = _ref2.previousImpact, impact = _ref2.impact;\n    var cleaned = clearUnusedPlaceholder({\n        previousImpact: previousImpact,\n        impact: impact,\n        droppables: droppables\n    });\n    var isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    var droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    var patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = function(_ref) {\n    var state = _ref.state, forcedClientSelection = _ref.clientSelection, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport, forcedImpact = _ref.impact, scrollJumpRequest = _ref.scrollJumpRequest;\n    var viewport = forcedViewport || state.viewport;\n    var dimensions = forcedDimensions || state.dimensions;\n    var clientSelection = forcedClientSelection || state.current.client.selection;\n    var offset = subtract(clientSelection, state.initial.client.selection);\n    var client = {\n        offset: offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    var page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    var current = {\n        client: client,\n        page: page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"COLLECTING\"\n        }, state, {\n            dimensions: dimensions,\n            viewport: viewport,\n            current: current\n        });\n    }\n    var draggable = dimensions.draggables[state.critical.draggable.id];\n    var newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable: draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport: viewport,\n        afterCritical: state.afterCritical\n    });\n    var withUpdatedPlaceholders = recomputePlaceholders({\n        draggable: draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state, {\n        current: current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport: viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    });\n    return result;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map(function(id) {\n        return draggables[id];\n    });\n}\nvar recompute = function(_ref) {\n    var impact = _ref.impact, viewport = _ref.viewport, draggables = _ref.draggables, destination = _ref.destination, forceShouldAnimate = _ref.forceShouldAnimate;\n    var last = impact.displaced;\n    var afterDragging = getDraggables$1(last.all, draggables);\n    var displaced = getDisplacementGroups({\n        afterDragging: afterDragging,\n        destination: destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate: forceShouldAnimate,\n        last: last\n    });\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, impact, {\n        displaced: displaced\n    });\n};\nvar getClientBorderBoxCenter = function(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, droppable = _ref.droppable, draggables = _ref.draggables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact: impact,\n        draggable: draggable,\n        draggables: draggables,\n        droppable: droppable,\n        afterCritical: afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter: pageBorderBoxCenter,\n        draggable: draggable,\n        viewport: viewport\n    });\n};\nvar refreshSnap = function(_ref) {\n    var state = _ref.state, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport;\n    !(state.movementMode === \"SNAP\") ?  true ? invariant(false) : 0 : void 0;\n    var needsVisibilityCheck = state.impact;\n    var viewport = forcedViewport || state.viewport;\n    var dimensions = forcedDimensions || state.dimensions;\n    var draggables = dimensions.draggables, droppables = dimensions.droppables;\n    var draggable = draggables[state.critical.draggable.id];\n    var isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    var destination = droppables[isOver];\n    var impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport: viewport,\n        destination: destination,\n        draggables: draggables\n    });\n    var clientSelection = getClientBorderBoxCenter({\n        impact: impact,\n        draggable: draggable,\n        droppable: destination,\n        draggables: draggables,\n        viewport: viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact: impact,\n        clientSelection: clientSelection,\n        state: state,\n        dimensions: dimensions,\n        viewport: viewport\n    });\n};\nvar getHomeLocation = function(descriptor) {\n    return {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    };\n};\nvar getLiftEffect = function(_ref) {\n    var draggable = _ref.draggable, home = _ref.home, draggables = _ref.draggables, viewport = _ref.viewport;\n    var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    var rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    var afterDragging = insideHome.slice(rawIndex + 1);\n    var effected = afterDragging.reduce(function(previous, item) {\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    var afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy: displacedBy,\n        effected: effected\n    };\n    var displaced = getDisplacementGroups({\n        afterDragging: afterDragging,\n        destination: home,\n        displacedBy: displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    var impact = {\n        displaced: displaced,\n        displacedBy: displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact: impact,\n        afterCritical: afterCritical\n    };\n};\nvar patchDimensionMap = function(dimensions, updated) {\n    return {\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    };\n};\nvar start = function start(key) {\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar finish = function finish(key) {\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = function(_ref) {\n    var draggable = _ref.draggable, offset$1 = _ref.offset, initialWindowScroll = _ref.initialWindowScroll;\n    var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(draggable.client, offset$1);\n    var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, initialWindowScroll);\n    var moved = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, draggable, {\n        placeholder: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, draggable.placeholder, {\n            client: client\n        }),\n        client: client,\n        page: page\n    });\n    return moved;\n};\nvar getFrame = function(droppable) {\n    var frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = function(_ref) {\n    var additions = _ref.additions, updatedDroppables = _ref.updatedDroppables, viewport = _ref.viewport;\n    var windowScrollChange = viewport.scroll.diff.value;\n    return additions.map(function(draggable) {\n        var droppableId = draggable.descriptor.droppableId;\n        var modified = updatedDroppables[droppableId];\n        var frame = getFrame(modified);\n        var droppableScrollChange = frame.scroll.diff.value;\n        var totalChange = add(windowScrollChange, droppableScrollChange);\n        var moved = offsetDraggable({\n            draggable: draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nvar publishWhileDraggingInVirtual = function(_ref) {\n    var state = _ref.state, published = _ref.published;\n    start();\n    var withScrollChange = published.modified.map(function(update) {\n        var existing = state.dimensions.droppables[update.droppableId];\n        var scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    var droppables = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));\n    var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    var draggables = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.dimensions.draggables, {}, updatedAdditions);\n    published.removals.forEach(function(id) {\n        delete draggables[id];\n    });\n    var dimensions = {\n        droppables: droppables,\n        draggables: draggables\n    };\n    var wasOverId = whatIsDraggedOver(state.impact);\n    var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    var draggable = dimensions.draggables[state.critical.draggable.id];\n    var home = dimensions.droppables[state.critical.droppable.id];\n    var _getLiftEffect = getLiftEffect({\n        draggable: draggable,\n        home: home,\n        draggables: draggables,\n        viewport: state.viewport\n    }), onLiftImpact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;\n    var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    var impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: previousImpact,\n        viewport: state.viewport,\n        afterCritical: afterCritical\n    });\n    finish();\n    var draggingState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        phase: \"DRAGGING\"\n    }, state, {\n        phase: \"DRAGGING\",\n        impact: impact,\n        onLiftImpact: onLiftImpact,\n        dimensions: dimensions,\n        afterCritical: afterCritical,\n        forceShouldAnimate: false\n    });\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    var dropPending = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        phase: \"DROP_PENDING\"\n    }, draggingState, {\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    });\n    return dropPending;\n};\nvar isSnapping = function isSnapping(state) {\n    return state.movementMode === \"SNAP\";\n};\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\n    var dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state: state,\n            dimensions: dimensions\n        });\n    }\n    return refreshSnap({\n        state: state,\n        dimensions: dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"DRAGGING\"\n        }, state, {\n            scrollJumpRequest: null\n        });\n    }\n    return state;\n}\nvar idle = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = function(state, action) {\n    if (state === void 0) {\n        state = idle;\n    }\n    if (action.type === \"FLUSH\") {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, idle, {\n            shouldFlush: true\n        });\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        var _action$payload = action.payload, critical = _action$payload.critical, clientSelection = _action$payload.clientSelection, viewport = _action$payload.viewport, dimensions = _action$payload.dimensions, movementMode = _action$payload.movementMode;\n        var draggable = dimensions.draggables[critical.draggable.id];\n        var home = dimensions.droppables[critical.droppable.id];\n        var client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        var initial = {\n            client: client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function(item) {\n            return !item.isFixedOnPage;\n        });\n        var _getLiftEffect = getLiftEffect({\n            draggable: draggable,\n            home: home,\n            draggables: dimensions.draggables,\n            viewport: viewport\n        }), impact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;\n        var result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical: critical,\n            movementMode: movementMode,\n            dimensions: dimensions,\n            initial: initial,\n            current: initial,\n            isWindowScrollAllowed: isWindowScrollAllowed,\n            impact: impact,\n            afterCritical: afterCritical,\n            onLiftImpact: impact,\n            viewport: viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Collection cannot start from phase \" + state.phase) : 0 : void 0;\n        var _result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"COLLECTING\"\n        }, state, {\n            phase: \"COLLECTING\"\n        });\n        return _result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, \"Unexpected \" + action.type + \" received in phase \" + state.phase) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state: state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : 0 : void 0;\n        var _clientSelection = action.payload.client;\n        if (isEqual(_clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state: state,\n            clientSelection: _clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : 0 : void 0;\n        var _action$payload2 = action.payload, id = _action$payload2.id, newScroll = _action$payload2.newScroll;\n        var target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        var scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : 0 : void 0;\n        var _action$payload3 = action.payload, _id = _action$payload3.id, isEnabled = _action$payload3.isEnabled;\n        var _target = state.dimensions.droppables[_id];\n        !_target ?  true ? invariant(false, \"Cannot find Droppable[id: \" + _id + \"] to toggle its enabled state\") : 0 : void 0;\n        !(_target.isEnabled !== isEnabled) ?  true ? invariant(false, \"Trying to set droppable isEnabled to \" + String(isEnabled) + \"\\n      but it is already \" + String(_target.isEnabled)) : 0 : void 0;\n        var updated = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, _target, {\n            isEnabled: isEnabled\n        });\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : 0 : void 0;\n        var _action$payload4 = action.payload, _id2 = _action$payload4.id, isCombineEnabled = _action$payload4.isCombineEnabled;\n        var _target2 = state.dimensions.droppables[_id2];\n        !_target2 ?  true ? invariant(false, \"Cannot find Droppable[id: \" + _id2 + \"] to toggle its isCombineEnabled state\") : 0 : void 0;\n        !(_target2.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, \"Trying to set droppable isCombineEnabled to \" + String(isCombineEnabled) + \"\\n      but it is already \" + String(_target2.isCombineEnabled)) : 0 : void 0;\n        var _updated = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, _target2, {\n            isCombineEnabled: isCombineEnabled\n        });\n        return postDroppableChange(state, _updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, \"Cannot move by window in phase \" + state.phase) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        var _newScroll = action.payload.newScroll;\n        if (isEqual(state.viewport.scroll.current, _newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        var _viewport = scrollViewport(state.viewport, _newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state: state,\n                viewport: _viewport\n            });\n        }\n        return update({\n            state: state,\n            viewport: _viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        var maxScroll = action.payload.maxScroll;\n        if (isEqual(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        var withMaxScroll = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.viewport, {\n            scroll: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.viewport.scroll, {\n                max: maxScroll\n            })\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"DRAGGING\"\n        }, state, {\n            viewport: withMaxScroll\n        });\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, action.type + \" received while not in DRAGGING phase\") : 0 : void 0;\n        var _result2 = moveInDirection({\n            state: state,\n            type: action.type\n        });\n        if (!_result2) {\n            return state;\n        }\n        return update({\n            state: state,\n            impact: _result2.impact,\n            clientSelection: _result2.clientSelection,\n            scrollJumpRequest: _result2.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        var reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        var newState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"DROP_PENDING\"\n        }, state, {\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason: reason\n        });\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        var _action$payload5 = action.payload, completed = _action$payload5.completed, dropDuration = _action$payload5.dropDuration, newHomeClientOffset = _action$payload5.newHomeClientOffset;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, \"Cannot animate drop from phase \" + state.phase) : 0 : void 0;\n        var _result3 = {\n            phase: \"DROP_ANIMATING\",\n            completed: completed,\n            dropDuration: dropDuration,\n            newHomeClientOffset: newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return _result3;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        var _completed = action.payload.completed;\n        return {\n            phase: \"IDLE\",\n            completed: _completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nvar beforeInitialCapture = function beforeInitialCapture(args) {\n    return {\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    };\n};\nvar lift = function lift(args) {\n    return {\n        type: \"LIFT\",\n        payload: args\n    };\n};\nvar initialPublish = function initialPublish(args) {\n    return {\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    };\n};\nvar publishWhileDragging = function publishWhileDragging(args) {\n    return {\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    };\n};\nvar collectionStarting = function collectionStarting() {\n    return {\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    };\n};\nvar updateDroppableScroll = function updateDroppableScroll(args) {\n    return {\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    };\n};\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\n    return {\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    };\n};\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\n    return {\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    };\n};\nvar move = function move(args) {\n    return {\n        type: \"MOVE\",\n        payload: args\n    };\n};\nvar moveByWindowScroll = function moveByWindowScroll(args) {\n    return {\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    };\n};\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\n    return {\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    };\n};\nvar moveUp = function moveUp() {\n    return {\n        type: \"MOVE_UP\",\n        payload: null\n    };\n};\nvar moveDown = function moveDown() {\n    return {\n        type: \"MOVE_DOWN\",\n        payload: null\n    };\n};\nvar moveRight = function moveRight() {\n    return {\n        type: \"MOVE_RIGHT\",\n        payload: null\n    };\n};\nvar moveLeft = function moveLeft() {\n    return {\n        type: \"MOVE_LEFT\",\n        payload: null\n    };\n};\nvar flush = function flush() {\n    return {\n        type: \"FLUSH\",\n        payload: null\n    };\n};\nvar animateDrop = function animateDrop(args) {\n    return {\n        type: \"DROP_ANIMATE\",\n        payload: args\n    };\n};\nvar completeDrop = function completeDrop(args) {\n    return {\n        type: \"DROP_COMPLETE\",\n        payload: args\n    };\n};\nvar drop = function drop(args) {\n    return {\n        type: \"DROP\",\n        payload: args\n    };\n};\nvar dropPending = function dropPending(args) {\n    return {\n        type: \"DROP_PENDING\",\n        payload: args\n    };\n};\nvar dropAnimationFinished = function dropAnimationFinished() {\n    return {\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    };\n};\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    var indexes = insideDestination.map(function(d) {\n        return d.descriptor.index;\n    });\n    var errors = {};\n    for(var i = 1; i < indexes.length; i++){\n        var current = indexes[i];\n        var previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    var formatted = indexes.map(function(index) {\n        var hasError = Boolean(errors[index]);\n        return hasError ? \"[\\uD83D\\uDD25\" + index + \"]\" : \"\" + index;\n    }).join(\", \");\n     true ? warning(\"\\n    Detected non-consecutive <Draggable /> indexes.\\n\\n    (This can cause unexpected bugs)\\n\\n    \" + formatted + \"\\n  \") : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift$1 = function(marshal) {\n    return function(_ref) {\n        var getState = _ref.getState, dispatch = _ref.dispatch;\n        return function(next) {\n            return function(action) {\n                if (action.type !== \"LIFT\") {\n                    next(action);\n                    return;\n                }\n                var _action$payload = action.payload, id = _action$payload.id, clientSelection = _action$payload.clientSelection, movementMode = _action$payload.movementMode;\n                var initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode: movementMode\n                }));\n                var scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                var request = {\n                    draggableId: id,\n                    scrollOptions: scrollOptions\n                };\n                var _marshal$startPublish = marshal.startPublishing(request), critical = _marshal$startPublish.critical, dimensions = _marshal$startPublish.dimensions, viewport = _marshal$startPublish.viewport;\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical: critical,\n                    dimensions: dimensions,\n                    clientSelection: clientSelection,\n                    movementMode: movementMode,\n                    viewport: viewport\n                }));\n            };\n        };\n    };\n};\nvar style = function(marshal) {\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    marshal.dragging();\n                }\n                if (action.type === \"DROP_ANIMATE\") {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\") {\n                    marshal.resting();\n                }\n                next(action);\n            };\n        };\n    };\n};\nvar curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nvar combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nvar timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nvar outOfTheWayTiming = timings.outOfTheWay + \"s \" + curves.outOfTheWay;\nvar transitions = {\n    fluid: \"opacity \" + outOfTheWayTiming,\n    snap: \"transform \" + outOfTheWayTiming + \", opacity \" + outOfTheWayTiming,\n    drop: function drop(duration) {\n        var timing = duration + \"s \" + curves.drop;\n        return \"transform \" + timing + \", opacity \" + timing;\n    },\n    outOfTheWay: \"transform \" + outOfTheWayTiming,\n    placeholder: \"height \" + outOfTheWayTiming + \", width \" + outOfTheWayTiming + \", margin \" + outOfTheWayTiming\n};\nvar moveTo = function moveTo(offset) {\n    return isEqual(offset, origin) ? null : \"translate(\" + offset.x + \"px, \" + offset.y + \"px)\";\n};\nvar transforms = {\n    moveTo: moveTo,\n    drop: function drop(offset, isCombining) {\n        var translate = moveTo(offset);\n        if (!translate) {\n            return null;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return translate + \" scale(\" + combine.scale.drop + \")\";\n    }\n};\nvar minDropTime = timings.minDropTime, maxDropTime = timings.maxDropTime;\nvar dropTimeRange = maxDropTime - minDropTime;\nvar maxDropTimeAtDistance = 1500;\nvar cancelDropModifier = 0.6;\nvar getDropDuration = function(_ref) {\n    var current = _ref.current, destination = _ref.destination, reason = _ref.reason;\n    var distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    var percentage = distance$1 / maxDropTimeAtDistance;\n    var duration = minDropTime + dropTimeRange * percentage;\n    var withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = function(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, dimensions = _ref.dimensions, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var draggables = dimensions.draggables, droppables = dimensions.droppables;\n    var droppableId = whatIsDraggedOver(impact);\n    var destination = droppableId ? droppables[droppableId] : null;\n    var home = droppables[draggable.descriptor.droppableId];\n    var newClientCenter = getClientBorderBoxCenter({\n        impact: impact,\n        draggable: draggable,\n        draggables: draggables,\n        afterCritical: afterCritical,\n        droppable: destination || home,\n        viewport: viewport\n    });\n    var offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = function(_ref) {\n    var draggables = _ref.draggables, reason = _ref.reason, lastImpact = _ref.lastImpact, home = _ref.home, viewport = _ref.viewport, onLiftImpact = _ref.onLiftImpact;\n    if (!lastImpact.at || reason !== \"DROP\") {\n        var recomputedHomeImpact = recompute({\n            draggables: draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport: viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    var withoutMovement = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, lastImpact, {\n        displaced: emptyGroups\n    });\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nvar drop$1 = function(_ref) {\n    var getState = _ref.getState, dispatch = _ref.dispatch;\n    return function(next) {\n        return function(action) {\n            if (action.type !== \"DROP\") {\n                next(action);\n                return;\n            }\n            var state = getState();\n            var reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason: reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            var isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, \"Cannot drop in phase: \" + state.phase) : 0 : void 0;\n            var critical = state.critical;\n            var dimensions = state.dimensions;\n            var draggable = dimensions.draggables[state.critical.draggable.id];\n            var _getDropImpact = getDropImpact({\n                reason: reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            }), impact = _getDropImpact.impact, didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\n            var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            var source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            var result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source: source,\n                reason: reason,\n                mode: state.movementMode,\n                destination: destination,\n                combine: combine\n            };\n            var newHomeClientOffset = getNewHomeClientOffset({\n                impact: impact,\n                draggable: draggable,\n                dimensions: dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            var completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result: result,\n                impact: impact\n            };\n            var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed: completed\n                }));\n                return;\n            }\n            var dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason: reason\n            });\n            var args = {\n                newHomeClientOffset: newHomeClientOffset,\n                dropDuration: dropDuration,\n                completed: completed\n            };\n            dispatch(animateDrop(args));\n        };\n    };\n};\nvar getWindowScroll = function() {\n    return {\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    };\n};\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: function fn(event) {\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener(_ref) {\n    var onWindowScroll = _ref.onWindowScroll;\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    var scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(updateScroll);\n    var binding = getWindowScrollBinding(scheduled);\n    var unbind = noop;\n    function isActive() {\n        return unbind !== noop;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop;\n    }\n    return {\n        start: start,\n        stop: stop,\n        isActive: isActive\n    };\n}\nvar shouldEnd = function shouldEnd(action) {\n    return action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\n};\nvar scrollListener = function(store) {\n    var listener = getScrollListener({\n        onWindowScroll: function onWindowScroll(newScroll) {\n            store.dispatch(moveByWindowScroll({\n                newScroll: newScroll\n            }));\n        }\n    });\n    return function(next) {\n        return function(action) {\n            if (!listener.isActive() && action.type === \"INITIAL_PUBLISH\") {\n                listener.start();\n            }\n            if (listener.isActive() && shouldEnd(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n    };\n};\nvar getExpiringAnnounce = function(announce) {\n    var wasCalled = false;\n    var isExpired = false;\n    var timeoutId = setTimeout(function() {\n        isExpired = true;\n    });\n    var result = function result(message) {\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(\"\\n        Announcements cannot be made asynchronously.\\n        Default message has already been announced.\\n      \") : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = function() {\n        return wasCalled;\n    };\n    return result;\n};\nvar getAsyncMarshal = function() {\n    var entries = [];\n    var execute = function execute(timerId) {\n        var index = findIndex(entries, function(item) {\n            return item.timerId === timerId;\n        });\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        var _entries$splice = entries.splice(index, 1), entry = _entries$splice[0];\n        entry.callback();\n    };\n    var add = function add(fn) {\n        var timerId = setTimeout(function() {\n            return execute(timerId);\n        });\n        var entry = {\n            timerId: timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    var flush = function flush() {\n        if (!entries.length) {\n            return;\n        }\n        var shallow = [].concat(entries);\n        entries.length = 0;\n        shallow.forEach(function(entry) {\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add: add,\n        flush: flush\n    };\n};\nvar areLocationsEqual = function areLocationsEqual(first, second) {\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nvar isCombineEqual = function isCombineEqual(first, second) {\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nvar isCriticalEqual = function isCriticalEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nvar withTimings = function withTimings(key, fn) {\n    start();\n    fn();\n    finish();\n};\nvar getDragStart = function getDragStart(critical, mode) {\n    return {\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode: mode\n    };\n};\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    var willExpire = getExpiringAnnounce(announce);\n    var provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n};\nvar getPublisher = function(getResponders, announce) {\n    var asyncMarshal = getAsyncMarshal();\n    var dragging = null;\n    var beforeCapture = function beforeCapture(draggableId, mode) {\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", function() {\n            var fn = getResponders().onBeforeCapture;\n            if (fn) {\n                var before = {\n                    draggableId: draggableId,\n                    mode: mode\n                };\n                fn(before);\n            }\n        });\n    };\n    var beforeStart = function beforeStart(critical, mode) {\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", function() {\n            var fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    var start = function start(critical, mode) {\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        var data = getDragStart(critical, mode);\n        dragging = {\n            mode: mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(function() {\n            withTimings(\"onDragStart\", function() {\n                return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\n            });\n        });\n    };\n    var update = function update(critical, impact) {\n        var location = tryGetDestination(impact);\n        var combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        var data = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, getDragStart(critical, dragging.mode), {\n            combine: combine,\n            destination: location\n        });\n        asyncMarshal.add(function() {\n            withTimings(\"onDragUpdate\", function() {\n                return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\n            });\n        });\n    };\n    var flush = function flush() {\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    var drop = function drop(result) {\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", function() {\n            return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\n        });\n    };\n    var abort = function abort() {\n        if (!dragging) {\n            return;\n        }\n        var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, getDragStart(dragging.lastCritical, dragging.mode), {\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        });\n        drop(result);\n    };\n    return {\n        beforeCapture: beforeCapture,\n        beforeStart: beforeStart,\n        start: start,\n        update: update,\n        flush: flush,\n        drop: drop,\n        abort: abort\n    };\n};\nvar responders = function(getResponders, announce) {\n    var publisher = getPublisher(getResponders, announce);\n    return function(store) {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"BEFORE_INITIAL_CAPTURE\") {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    var critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    var result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (action.type === \"FLUSH\") {\n                    publisher.abort();\n                    return;\n                }\n                var state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n        };\n    };\n};\nvar dropAnimationFinish = function(store) {\n    return function(next) {\n        return function(action) {\n            if (action.type !== \"DROP_ANIMATION_FINISHED\") {\n                next(action);\n                return;\n            }\n            var state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\n    };\n};\nvar dropAnimationFlushOnScroll = function(store) {\n    var unbind = null;\n    var frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return function(next) {\n        return function(action) {\n            if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATION_FINISHED\") {\n                clear();\n            }\n            next(action);\n            if (action.type !== \"DROP_ANIMATE\") {\n                return;\n            }\n            var binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    var state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(function() {\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n    };\n};\nvar dimensionMarshalStopper = function(marshal) {\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"DROP_COMPLETE\" || action.type === \"FLUSH\" || action.type === \"DROP_ANIMATE\") {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\n        };\n    };\n};\nvar focus = function(marshal) {\n    var isWatching = false;\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (action.type === \"FLUSH\") {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    isWatching = false;\n                    var result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n        };\n    };\n};\nvar shouldStop = function shouldStop(action) {\n    return action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\n};\nvar autoScroll = function(autoScroller) {\n    return function(store) {\n        return function(next) {\n            return function(action) {\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    next(action);\n                    var state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\n        };\n    };\n};\nvar pendingDrop = function(store) {\n    return function(next) {\n        return function(action) {\n            next(action);\n            if (action.type !== \"PUBLISH_WHILE_DRAGGING\") {\n                return;\n            }\n            var postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop({\n                reason: postActionState.reason\n            }));\n        };\n    };\n};\nvar composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_8__.compose;\nvar createStore = function(_ref) {\n    var dimensionMarshal = _ref.dimensionMarshal, focusMarshal = _ref.focusMarshal, styleMarshal = _ref.styleMarshal, getResponders = _ref.getResponders, announce = _ref.announce, autoScroller = _ref.autoScroller;\n    return (0,redux__WEBPACK_IMPORTED_MODULE_8__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_8__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\n};\nvar clean$1 = function clean() {\n    return {\n        additions: {},\n        removals: {},\n        modified: {}\n    };\n};\nfunction createPublisher(_ref) {\n    var registry = _ref.registry, callbacks = _ref.callbacks;\n    var staging = clean$1();\n    var frameId = null;\n    var collect = function collect() {\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(function() {\n            frameId = null;\n            start();\n            var _staging = staging, additions = _staging.additions, removals = _staging.removals, modified = _staging.modified;\n            var added = Object.keys(additions).map(function(id) {\n                return registry.draggable.getById(id).getDimension(origin);\n            }).sort(function(a, b) {\n                return a.descriptor.index - b.descriptor.index;\n            });\n            var updated = Object.keys(modified).map(function(id) {\n                var entry = registry.droppable.getById(id);\n                var scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll: scroll\n                };\n            });\n            var result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    var add = function add(entry) {\n        var id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    var remove = function remove(entry) {\n        var descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    var stop = function stop() {\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add: add,\n        remove: remove,\n        stop: stop\n    };\n}\nvar getMaxScroll = function(_ref) {\n    var scrollHeight = _ref.scrollHeight, scrollWidth = _ref.scrollWidth, height = _ref.height, width = _ref.width;\n    var maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    var adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = function() {\n    var doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = function() {\n    var doc = getDocumentElement();\n    var maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = function() {\n    var scroll = getWindowScroll();\n    var maxScroll = getMaxWindowScroll();\n    var top = scroll.y;\n    var left = scroll.x;\n    var doc = getDocumentElement();\n    var width = doc.clientWidth;\n    var height = doc.clientHeight;\n    var right = left + width;\n    var bottom = top + height;\n    var frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n        top: top,\n        left: left,\n        right: right,\n        bottom: bottom\n    });\n    var viewport = {\n        frame: frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = function(_ref) {\n    var critical = _ref.critical, scrollOptions = _ref.scrollOptions, registry = _ref.registry;\n    start();\n    var viewport = getViewport();\n    var windowScroll = viewport.scroll.current;\n    var home = critical.droppable;\n    var droppables = registry.droppable.getAllByType(home.type).map(function(entry) {\n        return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\n    });\n    var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function(entry) {\n        return entry.getDimension(windowScroll);\n    });\n    var dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    var result = {\n        dimensions: dimensions,\n        critical: critical,\n        viewport: viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    var home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(\"\\n      You are attempting to add or remove a Draggable [id: \" + entry.descriptor.id + \"]\\n      while a drag is occurring. This is only supported for virtual lists.\\n\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\n    \") : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = function(registry, callbacks) {\n    var collection = null;\n    var publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry: registry\n    });\n    var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\n        !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update is enabled flag of Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id: id,\n            isEnabled: isEnabled\n        });\n    };\n    var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update isCombineEnabled flag of Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id: id,\n            isCombineEnabled: isCombineEnabled\n        });\n    };\n    var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id: id,\n            newScroll: newScroll\n        });\n    };\n    var scrollDroppable = function scrollDroppable(id, change) {\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    var stopPublishing = function stopPublishing() {\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        var home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach(function(entry) {\n            return entry.callbacks.dragStopped();\n        });\n        collection.unsubscribe();\n        collection = null;\n    };\n    var subscriber = function subscriber(event) {\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        var dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    var startPublishing = function startPublishing(request) {\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        var entry = registry.draggable.getById(request.draggableId);\n        var home = registry.droppable.getById(entry.descriptor.droppableId);\n        var critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        var unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical: critical,\n            unsubscribe: unsubscribe\n        };\n        return getInitialPublish({\n            critical: critical,\n            registry: registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    var marshal = {\n        updateDroppableIsEnabled: updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n        scrollDroppable: scrollDroppable,\n        updateDroppableScroll: updateDroppableScroll,\n        startPublishing: startPublishing,\n        stopPublishing: stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = function(state, id) {\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = function(change) {\n    window.scrollBy(change.x, change.y);\n};\nvar getScrollableDroppables = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppables) {\n    return toDroppableList(droppables).filter(function(droppable) {\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    });\n});\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\n    var maybe = find(getScrollableDroppables(droppables), function(droppable) {\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    });\n    return maybe;\n};\nvar getBestScrollableDroppable = function(_ref) {\n    var center = _ref.center, destination = _ref.destination, droppables = _ref.droppables;\n    if (destination) {\n        var _dimension = droppables[destination];\n        if (!_dimension.frame) {\n            return null;\n        }\n        return _dimension;\n    }\n    var dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nvar config = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: function ease(percentage) {\n        return Math.pow(percentage, 2);\n    },\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    }\n};\nvar getDistanceThresholds = function(container, axis) {\n    var startScrollingFrom = container[axis.size] * config.startFromPercentage;\n    var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\n    var thresholds = {\n        startScrollingFrom: startScrollingFrom,\n        maxScrollValueAt: maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = function(_ref) {\n    var startOfRange = _ref.startOfRange, endOfRange = _ref.endOfRange, current = _ref.current;\n    var range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(\"\\n      Detected distance range of 0 in the fluid auto scroller\\n      This is unexpected and would cause a divide by 0 issue.\\n      Not allowing an auto scroll\\n    \") : 0;\n        return 0;\n    }\n    var currentInRange = current - startOfRange;\n    var percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = function(distanceToEdge, thresholds) {\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return config.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    var percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar accelerateAt = config.durationDampening.accelerateAt;\nvar stopAt = config.durationDampening.stopDampeningAt;\nvar dampenValueByTime = function(proposedScroll, dragStartTime) {\n    var startOfRange = dragStartTime;\n    var endOfRange = stopAt;\n    var now = Date.now();\n    var runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    var betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange: endOfRange,\n        current: runTime\n    });\n    var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = function(_ref) {\n    var distanceToEdge = _ref.distanceToEdge, thresholds = _ref.thresholds, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var scroll = getValueFromDistance(distanceToEdge, thresholds);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\n};\nvar getScrollOnAxis = function(_ref) {\n    var container = _ref.container, distanceToEdges = _ref.distanceToEdges, dragStartTime = _ref.dragStartTime, axis = _ref.axis, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var thresholds = getDistanceThresholds(container, axis);\n    var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds: thresholds,\n            dragStartTime: dragStartTime,\n            shouldUseTimeDampening: shouldUseTimeDampening\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds: thresholds,\n        dragStartTime: dragStartTime,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n};\nvar adjustForSizeLimits = function(_ref) {\n    var container = _ref.container, subject = _ref.subject, proposedScroll = _ref.proposedScroll;\n    var isTooBigVertically = subject.height > container.height;\n    var isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nvar clean$2 = apply(function(value) {\n    return value === 0 ? 0 : value;\n});\nvar getScroll = function(_ref) {\n    var dragStartTime = _ref.dragStartTime, container = _ref.container, subject = _ref.subject, center = _ref.center, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    var y = getScrollOnAxis({\n        container: container,\n        distanceToEdges: distanceToEdges,\n        dragStartTime: dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    var x = getScrollOnAxis({\n        container: container,\n        distanceToEdges: distanceToEdges,\n        dragStartTime: dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    var required = clean$2({\n        x: x,\n        y: y\n    });\n    if (isEqual(required, origin)) {\n        return null;\n    }\n    var limited = adjustForSizeLimits({\n        container: container,\n        subject: subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual(limited, origin) ? null : limited;\n};\nvar smallestSigned = apply(function(value) {\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nvar getOverlap = function() {\n    var getRemainder = function getRemainder(target, max) {\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return function(_ref) {\n        var current = _ref.current, max = _ref.max, change = _ref.change;\n        var targetScroll = add(current, change);\n        var overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n}();\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\n    var rawMax = _ref2.max, current = _ref2.current, change = _ref2.change;\n    var max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    var smallestChange = smallestSigned(change);\n    var overlap = getOverlap({\n        max: max,\n        current: current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nvar canScrollWindow = function canScrollWindow(viewport, change) {\n    return canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change: change\n    });\n};\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    var max = viewport.scroll.max;\n    var current = viewport.scroll.current;\n    return getOverlap({\n        current: current,\n        max: max,\n        change: change\n    });\n};\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change: change\n    });\n};\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change: change\n    });\n};\nvar getWindowScrollChange = function(_ref) {\n    var viewport = _ref.viewport, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var scroll = getScroll({\n        dragStartTime: dragStartTime,\n        container: viewport.frame,\n        subject: subject,\n        center: center,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = function(_ref) {\n    var droppable = _ref.droppable, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    var scroll = getScroll({\n        dragStartTime: dragStartTime,\n        container: frame.pageMarginBox,\n        subject: subject,\n        center: center,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll$1 = function(_ref) {\n    var state = _ref.state, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening, scrollWindow = _ref.scrollWindow, scrollDroppable = _ref.scrollDroppable;\n    var center = state.current.page.borderBoxCenter;\n    var draggable = state.dimensions.draggables[state.critical.draggable.id];\n    var subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        var viewport = state.viewport;\n        var _change = getWindowScrollChange({\n            dragStartTime: dragStartTime,\n            viewport: viewport,\n            subject: subject,\n            center: center,\n            shouldUseTimeDampening: shouldUseTimeDampening\n        });\n        if (_change) {\n            scrollWindow(_change);\n            return;\n        }\n    }\n    var droppable = getBestScrollableDroppable({\n        center: center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    var change = getDroppableScrollChange({\n        dragStartTime: dragStartTime,\n        droppable: droppable,\n        subject: subject,\n        center: center,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = function(_ref) {\n    var scrollWindow = _ref.scrollWindow, scrollDroppable = _ref.scrollDroppable;\n    var scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(scrollWindow);\n    var scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(scrollDroppable);\n    var dragging = null;\n    var tryScroll = function tryScroll(state) {\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        var _dragging = dragging, shouldUseTimeDampening = _dragging.shouldUseTimeDampening, dragStartTime = _dragging.dragStartTime;\n        scroll$1({\n            state: state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime: dragStartTime,\n            shouldUseTimeDampening: shouldUseTimeDampening\n        });\n    };\n    var start$1 = function start$1(state) {\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        var dragStartTime = Date.now();\n        var wasScrollNeeded = false;\n        var fakeScrollCallback = function fakeScrollCallback() {\n            wasScrollNeeded = true;\n        };\n        scroll$1({\n            state: state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback\n        });\n        dragging = {\n            dragStartTime: dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    var stop = function stop() {\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop: stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = function(_ref) {\n    var move = _ref.move, scrollDroppable = _ref.scrollDroppable, scrollWindow = _ref.scrollWindow;\n    var moveByOffset = function moveByOffset(state, offset) {\n        var client = add(state.current.client.selection, offset);\n        move({\n            client: client\n        });\n    };\n    var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        var overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        var whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        var remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        var overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        var whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        var remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    var jumpScroller = function jumpScroller(state) {\n        var request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        var destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        var viewport = state.viewport;\n        var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = function(_ref) {\n    var scrollDroppable = _ref.scrollDroppable, scrollWindow = _ref.scrollWindow, move = _ref.move;\n    var fluidScroller = createFluidScroller({\n        scrollWindow: scrollWindow,\n        scrollDroppable: scrollDroppable\n    });\n    var jumpScroll = createJumpScroller({\n        move: move,\n        scrollWindow: scrollWindow,\n        scrollDroppable: scrollDroppable\n    });\n    var scroll = function scroll(state) {\n        if (state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    var scroller = {\n        scroll: scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nvar prefix$1 = \"data-rbd\";\nvar dragHandle = function() {\n    var base = prefix$1 + \"-drag-handle\";\n    return {\n        base: base,\n        draggableId: base + \"-draggable-id\",\n        contextId: base + \"-context-id\"\n    };\n}();\nvar draggable = function() {\n    var base = prefix$1 + \"-draggable\";\n    return {\n        base: base,\n        contextId: base + \"-context-id\",\n        id: base + \"-id\"\n    };\n}();\nvar droppable = function() {\n    var base = prefix$1 + \"-droppable\";\n    return {\n        base: base,\n        contextId: base + \"-context-id\",\n        id: base + \"-id\"\n    };\n}();\nvar scrollContainer = {\n    contextId: prefix$1 + \"-scroll-container-context-id\"\n};\nvar makeGetSelector = function makeGetSelector(context) {\n    return function(attribute) {\n        return \"[\" + attribute + '=\"' + context + '\"]';\n    };\n};\nvar getStyles = function getStyles(rules, property) {\n    return rules.map(function(rule) {\n        var value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return rule.selector + \" { \" + value + \" }\";\n    }).join(\" \");\n};\nvar noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = function(contextId) {\n    var getSelector = makeGetSelector(contextId);\n    var dragHandle$1 = function() {\n        var grabCursor = \"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \";\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: \"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    }();\n    var draggable$1 = function() {\n        var transition = \"\\n      transition: \" + transitions.outOfTheWay + \";\\n    \";\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    }();\n    var droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: \"overflow-anchor: none;\"\n        }\n    };\n    var body = {\n        selector: \"body\",\n        styles: {\n            dragging: \"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"\n        }\n    };\n    var rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nvar useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar getHead = function getHead() {\n    var head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nvar createStyleEl = function createStyleEl(nonce) {\n    var el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    var styles = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return getStyles$1(contextId);\n    }, [\n        contextId\n    ]);\n    var alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var setDynamicStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)((0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(proposed) {\n        var el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    var setAlwaysStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(proposed) {\n        var el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useIsomorphicLayoutEffect(function() {\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        var always = createStyleEl(nonce);\n        var dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(prefix$1 + \"-always\", contextId);\n        dynamic.setAttribute(prefix$1 + \"-dynamic\", contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return function() {\n            var remove = function remove(ref) {\n                var current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    var dragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return setDynamicStyle(styles.dragging);\n    }, [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    var dropping = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(reason) {\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    var resting = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    var marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            dragging: dragging,\n            dropping: dropping,\n            resting: resting\n        };\n    }, [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nvar getWindowFromEl = function(el) {\n    return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\n};\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    var selector = \"[\" + dragHandle.contextId + '=\"' + contextId + '\"]';\n    var possible = toArray(document.querySelectorAll(selector));\n    if (!possible.length) {\n         true ? warning('Unable to find any drag handles in the context \"' + contextId + '\"') : 0;\n        return null;\n    }\n    var handle = find(possible, function(el) {\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning('Unable to find drag handle with id \"' + draggableId + '\" as no handle with a matching id was found') : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    var entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    var recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    var register = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function register(id, focus) {\n        var entry = {\n            id: id,\n            focus: focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            var entries = entriesRef.current;\n            var current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    var tryGiveFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryGiveFocus(tryGiveFocusTo) {\n        var handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    var tryShiftRecord = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    var tryRestoreFocusRecorded = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(function() {\n            restoreFocusFrameRef.current = null;\n            var record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    var tryRecordFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryRecordFocus(id) {\n        recordRef.current = null;\n        var focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useIsomorphicLayoutEffect(function() {\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            var frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    var marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            register: register,\n            tryRecordFocus: tryRecordFocus,\n            tryRestoreFocusRecorded: tryRestoreFocusRecorded,\n            tryShiftRecord: tryShiftRecord\n        };\n    }, [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    var entries = {\n        draggables: {},\n        droppables: {}\n    };\n    var subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            var index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach(function(cb) {\n                return cb(event);\n            });\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        var entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, \"Cannot find draggable entry with id [\" + id + \"]\") : 0 : void 0;\n        return entry;\n    }\n    var draggableAPI = {\n        register: function register(entry) {\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: function update(entry, last) {\n            var current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: function unregister(entry) {\n            var draggableId = entry.descriptor.id;\n            var current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            notify({\n                type: \"REMOVAL\",\n                value: entry\n            });\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: function exists(id) {\n            return Boolean(findDraggableById(id));\n        },\n        getAllByType: function getAllByType(type) {\n            return values(entries.draggables).filter(function(entry) {\n                return entry.descriptor.type === type;\n            });\n        }\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        var entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, \"Cannot find droppable entry with id [\" + id + \"]\") : 0 : void 0;\n        return entry;\n    }\n    var droppableAPI = {\n        register: function register(entry) {\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: function unregister(entry) {\n            var current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: function exists(id) {\n            return Boolean(findDroppableById(id));\n        },\n        getAllByType: function getAllByType(type) {\n            return values(entries.droppables).filter(function(entry) {\n                return entry.descriptor.type === type;\n            });\n        }\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe: subscribe,\n        clean: clean\n    };\n}\nfunction useRegistry() {\n    var registry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return function unmount() {\n            requestAnimationFrame(registry.clean);\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = function() {\n    var body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nvar visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nvar getId = function getId(contextId) {\n    return \"rbd-announcement-\" + contextId;\n};\nfunction useAnnouncer(contextId) {\n    var id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return getId(contextId);\n    }, [\n        contextId\n    ]);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        var el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el.style, visuallyHidden);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                var body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    var announce = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(message) {\n        var el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning('\\n      A screen reader message was trying to be announced but it was unable to do so.\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\n      Consider calling provided.announce() before the unmount so that the instruction will\\n      not be lost for users relying on a screen reader.\\n\\n      Message not passed to screen reader:\\n\\n      \"' + message + '\"\\n    ') : 0;\n    }, []);\n    return announce;\n}\nvar count = 0;\nvar defaults = {\n    separator: \"::\"\n};\nfunction reset() {\n    count = 0;\n}\nfunction useUniqueId(prefix, options) {\n    if (options === void 0) {\n        options = defaults;\n    }\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return \"\" + prefix + options.separator + count++;\n    }, [\n        options.separator,\n        prefix\n    ]);\n}\nfunction getElementId(_ref) {\n    var contextId = _ref.contextId, uniqueId = _ref.uniqueId;\n    return \"rbd-hidden-text-\" + contextId + \"-\" + uniqueId;\n}\nfunction useHiddenTextElement(_ref2) {\n    var contextId = _ref2.contextId, text = _ref2.text;\n    var uniqueId = useUniqueId(\"hidden-text\", {\n        separator: \"-\"\n    });\n    var id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return getElementId({\n            contextId: contextId,\n            uniqueId: uniqueId\n        });\n    }, [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        var el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            var body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^16.8.5 || ^17.0.0 || ^18.0.0\",\n    \"react-dom\": \"^16.8.5 || ^17.0.0 || ^18.0.0\"\n};\nvar semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nvar getVersion = function getVersion(value) {\n    var result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, \"Unable to parse React version \" + value) : 0 : void 0;\n    var major = Number(result[1]);\n    var minor = Number(result[2]);\n    var patch = Number(result[3]);\n    return {\n        major: major,\n        minor: minor,\n        patch: patch,\n        raw: value\n    };\n};\nvar isSatisfied = function isSatisfied(expected, actual) {\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = function(peerDepValue, actualValue) {\n    var peerDep = getVersion(peerDepValue);\n    var actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(\"\\n    React version: [\" + actual.raw + \"]\\n    does not satisfy expected peer dependency version: [\" + peerDep.raw + \"]\\n\\n    This can result in run time bugs, and even fatal crashes\\n  \") : 0;\n};\nvar suffix = \"\\n  We expect a html5 doctype: <!doctype html>\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\";\nvar checkDoctype = function(doc) {\n    var doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(\"\\n      No <!doctype html> found.\\n\\n      \" + suffix + \"\\n    \") : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(\"\\n      Unexpected <!doctype> found: (\" + doctype.name + \")\\n\\n      \" + suffix + \"\\n    \") : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(\"\\n      Unexpected <!doctype> publicId found: (\" + doctype.publicId + \")\\n      A html5 doctype does not have a publicId\\n\\n      \" + suffix + \"\\n    \") : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(function() {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n            try {\n                fn();\n            } catch (e) {\n                error(\"\\n          A setup problem was encountered.\\n\\n          > \" + e.message + \"\\n        \");\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(function() {\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    var lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        var newLock = {\n            abandon: abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed: isClaimed,\n        isActive: isActive,\n        claim: claim,\n        release: release,\n        tryAbandon: tryAbandon\n    };\n}\nvar tab = 9;\nvar enter = 13;\nvar escape = 27;\nvar space = 32;\nvar pageUp = 33;\nvar pageDown = 34;\nvar end = 35;\nvar home = 36;\nvar arrowLeft = 37;\nvar arrowUp = 38;\nvar arrowRight = 39;\nvar arrowDown = 40;\nvar _preventedKeys;\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\nvar preventStandardKeyEvents = function(event) {\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nvar supportedEventName = function() {\n    var base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    var candidates = [\n        base,\n        \"ms\" + base,\n        \"webkit\" + base,\n        \"moz\" + base,\n        \"o\" + base\n    ];\n    var supported = find(candidates, function(eventName) {\n        return \"on\" + eventName in document;\n    });\n    return supported || base;\n}();\nvar primaryButton = 0;\nvar sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nvar idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings(_ref) {\n    var cancel = _ref.cancel, completed = _ref.completed, getPhase = _ref.getPhase, setPhase = _ref.setPhase;\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: function fn(event) {\n                var button = event.button, clientX = event.clientX, clientY = event.clientY;\n                if (button !== primaryButton) {\n                    return;\n                }\n                var point = {\n                    x: clientX,\n                    y: clientY\n                };\n                var phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                var pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                var actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions: actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: function fn(event) {\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: function fn() {\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    var phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop);\n    var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                var draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                var actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                var point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        };\n    }, [\n        api\n    ]);\n    var preventForcePressBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: function fn(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                var id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                var options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        };\n    }, [\n        api\n    ]);\n    var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function listenForCapture() {\n        var options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    var stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    var cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    var bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function bindCapturingEvents() {\n        var options = {\n            capture: true,\n            passive: false\n        };\n        var bindings = getCaptureBindings({\n            cancel: cancel,\n            completed: stop,\n            getPhase: function getPhase() {\n                return phaseRef.current;\n            },\n            setPhase: function setPhase(phase) {\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    var startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point: point,\n            actions: actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nvar _scrollJumpKeys;\nfunction noop$1() {}\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: function fn(event) {\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                var draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                var preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                var isCapturing = true;\n                var actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        };\n    }, [\n        api\n    ]);\n    var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryStartCapture() {\n        var options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nvar idle$2 = {\n    type: \"IDLE\"\n};\nvar timeForLongPress = 120;\nvar forcePressThreshold = 0.15;\nfunction getWindowBindings(_ref) {\n    var cancel = _ref.cancel, getPhase = _ref.getPhase;\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: function fn(event) {\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: function fn(event) {\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings(_ref2) {\n    var cancel = _ref2.cancel, completed = _ref2.completed, getPhase = _ref2.getPhase;\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                var _event$touches$ = event.touches[0], clientX = _event$touches$.clientX, clientY = _event$touches$.clientY;\n                var point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: function fn(event) {\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false) : 0 : void 0;\n                var touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                var isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                var shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    var phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$2);\n    var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop);\n    var getPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    var setPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                var draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                var actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                var touch = event.touches[0];\n                var clientX = touch.clientX, clientY = touch.clientY;\n                var point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        };\n    }, [\n        api\n    ]);\n    var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function listenForCapture() {\n        var options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    var stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle$2);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    var cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    var bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function bindCapturingEvents() {\n        var options = {\n            capture: true,\n            passive: false\n        };\n        var args = {\n            cancel: cancel,\n            completed: stop,\n            getPhase: getPhase\n        };\n        var unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        var unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    var startDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startDragging() {\n        var phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot start dragging from phase \" + phase.type) : 0 : void 0;\n        var actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions: actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    var startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        var longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point: point,\n            actions: actions,\n            longPressTimerId: longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            var phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle$2);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useIsomorphicLayoutEffect(function webkitHack() {\n        var unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: function fn() {},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(function() {\n        var previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(function() {\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nvar interactiveTagNames = {\n    input: true,\n    button: true,\n    textarea: true,\n    select: true,\n    option: true,\n    optgroup: true,\n    video: true,\n    audio: true\n};\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    var attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    var target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = function(el) {\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(el.getBoundingClientRect()).center;\n};\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nvar supportedMatchesName = function() {\n    var base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    var candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    var value = find(candidates, function(name) {\n        return name in Element.prototype;\n    });\n    return value || base;\n}();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest$1(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return \"[\" + dragHandle.contextId + '=\"' + contextId + '\"]';\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    var target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    var selector = getSelector(contextId);\n    var handle = closest$1(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    var handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    var selector = \"[\" + draggable.contextId + '=\"' + contextId + '\"]';\n    var possible = toArray(document.querySelectorAll(selector));\n    var draggable$1 = find(possible, function(el) {\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction _isActive(_ref) {\n    var expected = _ref.expected, phase = _ref.phase, isLockActive = _ref.isLockActive, shouldWarn = _ref.shouldWarn;\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(\"\\n        Cannot perform action.\\n        The sensor no longer has an action lock.\\n\\n        Tips:\\n\\n        - Throw away your action handlers when forceStop() is called\\n        - Check actions.isActive() if you really need to\\n      \") : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(\"\\n        Cannot perform action.\\n        The actions you used belong to an outdated phase\\n\\n        Current phase: \" + expected + \"\\n        You called an action from outdated phase: \" + phase + \"\\n\\n        Tips:\\n\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\n      \") : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart(_ref2) {\n    var lockAPI = _ref2.lockAPI, store = _ref2.store, registry = _ref2.registry, draggableId = _ref2.draggableId;\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    var entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(\"Unable to find draggable with id: \" + draggableId) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart(_ref3) {\n    var lockAPI = _ref3.lockAPI, contextId = _ref3.contextId, store = _ref3.store, registry = _ref3.registry, draggableId = _ref3.draggableId, forceSensorStop = _ref3.forceSensorStop, sourceEvent = _ref3.sourceEvent;\n    var shouldStart = canStart({\n        lockAPI: lockAPI,\n        store: store,\n        registry: registry,\n        draggableId: draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    var entry = registry.draggable.getById(draggableId);\n    var el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(\"Unable to find draggable element with id: \" + draggableId) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    var lock = lockAPI.claim(forceSensorStop || noop);\n    var phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (_isActive({\n            expected: expected,\n            phase: phase,\n            isLockActive: isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    var tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift$1(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n            !(phase === \"PRE_DRAG\") ?  true ? invariant(false, \"Cannot lift in phase \" + phase) : 0 : void 0;\n        }\n        store.dispatch(lift(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options) {\n            if (options === void 0) {\n                options = {\n                    shouldBlockNextClick: false\n                };\n            }\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                var unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop({\n                reason: reason\n            }));\n        }\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            isActive: function isActive() {\n                return _isActive({\n                    expected: \"DRAGGING\",\n                    phase: phase,\n                    isLockActive: isLockActive,\n                    shouldWarn: false\n                });\n            },\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: function drop(options) {\n                return finish(\"DROP\", options);\n            },\n            cancel: function cancel(options) {\n                return finish(\"CANCEL\", options);\n            }\n        }, args.actions);\n    }\n    function fluidLift(clientSelection) {\n        var move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(function(client) {\n            tryDispatchWhenDragging(function() {\n                return move({\n                    client: client\n                });\n            });\n        });\n        var api = lift$1({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: function cleanup() {\n                return move$1.cancel();\n            },\n            actions: {\n                move: move$1\n            }\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, api, {\n            move: move$1\n        });\n    }\n    function snapLift() {\n        var actions = {\n            moveUp: function moveUp$1() {\n                return tryDispatchWhenDragging(moveUp);\n            },\n            moveRight: function moveRight$1() {\n                return tryDispatchWhenDragging(moveRight);\n            },\n            moveDown: function moveDown$1() {\n                return tryDispatchWhenDragging(moveDown);\n            },\n            moveLeft: function moveLeft$1() {\n                return tryDispatchWhenDragging(moveLeft);\n            }\n        };\n        return lift$1({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop,\n            actions: actions\n        });\n    }\n    function abortPreDrag() {\n        var shouldRelease = _isActive({\n            expected: \"PRE_DRAG\",\n            phase: phase,\n            isLockActive: isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    var preDrag = {\n        isActive: function isActive() {\n            return _isActive({\n                expected: \"PRE_DRAG\",\n                phase: phase,\n                isLockActive: isLockActive,\n                shouldWarn: false\n            });\n        },\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift: fluidLift,\n        snapLift: snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nvar defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal(_ref4) {\n    var contextId = _ref4.contextId, store = _ref4.store, registry = _ref4.registry, customSensors = _ref4.customSensors, enableDefaultSensors = _ref4.enableDefaultSensors;\n    var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);\n    var lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return create();\n    })[0];\n    var tryAbandonLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryAbandonLock(previous, current) {\n        if (previous.isDragging && !current.isDragging) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useIsomorphicLayoutEffect(function listenToStore() {\n        var previous = store.getState();\n        var unsubscribe = store.subscribe(function() {\n            var current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    var canGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(draggableId) {\n        return canStart({\n            lockAPI: lockAPI,\n            registry: registry,\n            store: store,\n            draggableId: draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    var tryGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(draggableId, forceStop, options) {\n        return tryStart({\n            lockAPI: lockAPI,\n            registry: registry,\n            contextId: contextId,\n            store: store,\n            draggableId: draggableId,\n            forceSensorStop: forceStop,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        });\n    }, [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    var findClosestDraggableId = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(event) {\n        return tryGetClosestDraggableIdFromEvent(contextId, event);\n    }, [\n        contextId\n    ]);\n    var findOptionsForDraggable = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(id) {\n        var entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    var tryReleaseLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    var isLockClaimed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(lockAPI.isClaimed, [\n        lockAPI\n    ]);\n    var api = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            canGetLock: canGetLock,\n            tryGetLock: tryGetLock,\n            findClosestDraggableId: findClosestDraggableId,\n            findOptionsForDraggable: findOptionsForDraggable,\n            tryReleaseLock: tryReleaseLock,\n            isLockClaimed: isLockClaimed\n        };\n    }, [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(var i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nvar createResponders = function createResponders(props) {\n    return {\n        onBeforeCapture: props.onBeforeCapture,\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    };\n};\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    var contextId = props.contextId, setCallbacks = props.setCallbacks, sensors = props.sensors, nonce = props.nonce, dragHandleUsageInstructions = props.dragHandleUsageInstructions;\n    var lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    var lastPropsRef = usePrevious(props);\n    var getResponders = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    var announce = useAnnouncer(contextId);\n    var dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId: contextId,\n        text: dragHandleUsageInstructions\n    });\n    var styleMarshal = useStyleMarshal(contextId, nonce);\n    var lazyDispatch = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(action) {\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    var marshalCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return (0,redux__WEBPACK_IMPORTED_MODULE_8__.bindActionCreators)({\n            publishWhileDragging: publishWhileDragging,\n            updateDroppableScroll: updateDroppableScroll,\n            updateDroppableIsEnabled: updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n            collectionStarting: collectionStarting\n        }, lazyDispatch);\n    }, [\n        lazyDispatch\n    ]);\n    var registry = useRegistry();\n    var dimensionMarshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    var autoScroller = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return createAutoScroller((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            scrollWindow: scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable\n        }, (0,redux__WEBPACK_IMPORTED_MODULE_8__.bindActionCreators)({\n            move: move\n        }, lazyDispatch)));\n    }, [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch\n    ]);\n    var focusMarshal = useFocusMarshal(contextId);\n    var store = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return createStore({\n            announce: announce,\n            autoScroller: autoScroller,\n            dimensionMarshal: dimensionMarshal,\n            focusMarshal: focusMarshal,\n            getResponders: getResponders,\n            styleMarshal: styleMarshal\n        });\n    }, [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    var tryResetStore = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var current = getStore(lazyStoreRef);\n        var state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    var isDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var state = getStore(lazyStoreRef).getState();\n        return state.isDragging || state.phase === \"DROP_ANIMATING\";\n    }, []);\n    var appCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            isDragging: isDragging,\n            tryAbort: tryResetStore\n        };\n    }, [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    var getCanLift = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(id) {\n        return canStartDrag(getStore(lazyStoreRef).getState(), id);\n    }, []);\n    var getIsMovementAllowed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return isMovementAllowed(getStore(lazyStoreRef).getState());\n    }, []);\n    var appContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId: contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId: dragHandleUsageInstructionsId,\n            registry: registry\n        };\n    }, [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId: contextId,\n        store: store,\n        registry: registry,\n        customSensors: sensors,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_3__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nvar count$1 = 0;\nfunction reset$1() {\n    count$1 = 0;\n}\nfunction useInstanceCount() {\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return \"\" + count$1++;\n    }, []);\n}\nfunction resetServerContext() {\n    reset$1();\n    reset();\n}\nfunction DragDropContext(props) {\n    var contextId = useInstanceCount();\n    var dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, function(setCallbacks) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd\n        }, props.children);\n    });\n}\nvar isEqual$1 = function isEqual(base) {\n    return function(value) {\n        return base === value;\n    };\n};\nvar isScroll = isEqual$1(\"scroll\");\nvar isAuto = isEqual$1(\"auto\");\nvar isVisible$1 = isEqual$1(\"visible\");\nvar isEither = function isEither(overflow, fn) {\n    return fn(overflow.overflowX) || fn(overflow.overflowY);\n};\nvar isBoth = function isBoth(overflow, fn) {\n    return fn(overflow.overflowX) && fn(overflow.overflowY);\n};\nvar isElementScrollable = function isElementScrollable(el) {\n    var style = window.getComputedStyle(el);\n    var overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nvar isBodyScrollable = function isBodyScrollable() {\n    if (false) {}\n    var body = getBodyElement();\n    var html = document.documentElement;\n    !html ?  true ? invariant(false) : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    var htmlStyle = window.getComputedStyle(html);\n    var htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible$1)) {\n        return false;\n    }\n     true ? warning(\"\\n    We have detected that your <body> element might be a scroll container.\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\n\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\n    we will be treating the <body> as *not* a scroll container\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\n  \") : 0;\n    return false;\n};\nvar getClosestScrollable = function getClosestScrollable(el) {\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar checkForNestedScrollContainers = function(scrollable) {\n    if (!scrollable) {\n        return;\n    }\n    var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \") : 0;\n};\nvar getScroll$1 = function(el) {\n    return {\n        x: el.scrollLeft,\n        y: el.scrollTop\n    };\n};\nvar getIsFixed = function getIsFixed(el) {\n    if (!el) {\n        return false;\n    }\n    var style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = function(start) {\n    var closestScrollable = getClosestScrollable(start);\n    var isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable: closestScrollable,\n        isFixedOnPage: isFixedOnPage\n    };\n};\nvar getDroppableDimension = function(_ref) {\n    var descriptor = _ref.descriptor, isEnabled = _ref.isEnabled, isCombineEnabled = _ref.isCombineEnabled, isFixedOnPage = _ref.isFixedOnPage, direction = _ref.direction, client = _ref.client, page = _ref.page, closest = _ref.closest;\n    var frame = function() {\n        if (!closest) {\n            return null;\n        }\n        var scrollSize = closest.scrollSize, frameClient = closest.client;\n        var maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient: frameClient,\n            scrollSize: scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    }();\n    var axis = direction === \"vertical\" ? vertical : horizontal;\n    var subject = getSubject({\n        page: page,\n        withPlaceholder: null,\n        axis: axis,\n        frame: frame\n    });\n    var dimension = {\n        descriptor: descriptor,\n        isCombineEnabled: isCombineEnabled,\n        isFixedOnPage: isFixedOnPage,\n        axis: axis,\n        isEnabled: isEnabled,\n        client: client,\n        page: page,\n        frame: frame,\n        subject: subject\n    };\n    return dimension;\n};\nvar getClient = function getClient(targetRef, closestScrollable) {\n    var base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    var top = base.paddingBox.top - closestScrollable.scrollTop;\n    var left = base.paddingBox.left - closestScrollable.scrollLeft;\n    var bottom = top + closestScrollable.scrollHeight;\n    var right = left + closestScrollable.scrollWidth;\n    var paddingBox = {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left\n    };\n    var borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.expand)(paddingBox, base.border);\n    var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.createBox)({\n        borderBox: borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = function(_ref) {\n    var ref = _ref.ref, descriptor = _ref.descriptor, env = _ref.env, windowScroll = _ref.windowScroll, direction = _ref.direction, isDropDisabled = _ref.isDropDisabled, isCombineEnabled = _ref.isCombineEnabled, shouldClipSubject = _ref.shouldClipSubject;\n    var closestScrollable = env.closestScrollable;\n    var client = getClient(ref, closestScrollable);\n    var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, windowScroll);\n    var closest = function() {\n        if (!closestScrollable) {\n            return null;\n        }\n        var frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getBox)(closestScrollable);\n        var scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll$1(closestScrollable),\n            scrollSize: scrollSize,\n            shouldClipSubject: shouldClipSubject\n        };\n    }();\n    var dimension = getDroppableDimension({\n        descriptor: descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled: isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction: direction,\n        client: client,\n        page: page,\n        closest: closest\n    });\n    return dimension;\n};\nvar immediate = {\n    passive: false\n};\nvar delayed = {\n    passive: true\n};\nvar getListenerOptions = function(options) {\n    return options.shouldPublishImmediately ? immediate : delayed;\n};\nfunction useRequiredContext(Context) {\n    var result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\n    return dragging && dragging.env.closestScrollable || null;\n};\nfunction useDroppablePublisher(args) {\n    var whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var appContext = useRequiredContext(AppContext);\n    var uniqueId = useUniqueId(\"droppable\");\n    var registry = appContext.registry, marshal = appContext.marshal;\n    var previousRef = usePrevious(args);\n    var descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        };\n    }, [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    var publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    var memoizedUpdateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(x, y) {\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            var scroll = {\n                x: x,\n                y: y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        });\n    }, [\n        descriptor.id,\n        marshal\n    ]);\n    var getClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll$1(dragging.env.closestScrollable);\n    }, []);\n    var updateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    var scheduleScrollUpdate = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(updateScroll);\n    }, [\n        updateScroll\n    ]);\n    var onClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        var closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        var options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    var getDimensionAndWatchScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(windowScroll, options) {\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        var previous = previousRef.current;\n        var ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        var env = getEnv(ref);\n        var dragging = {\n            ref: ref,\n            descriptor: descriptor,\n            env: env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        var dimension = getDimension({\n            ref: ref,\n            descriptor: descriptor,\n            env: env,\n            windowScroll: windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        var scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    var getScrollWhileDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        var closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll$1(closest);\n    }, []);\n    var dragStopped = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        var closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    var scroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(change) {\n        var dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        var closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    var callbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            getDimensionAndWatchScroll: getDimensionAndWatchScroll,\n            getScrollWhileDragging: getScrollWhileDragging,\n            dragStopped: dragStopped,\n            scroll: scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    var entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            uniqueId: uniqueId,\n            descriptor: descriptor,\n            callbacks: callbacks\n        };\n    }, [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return function() {\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop$2() {}\nvar empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nvar getSize = function getSize(_ref) {\n    var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount, placeholder = _ref.placeholder, animate = _ref.animate;\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nvar getStyle = function getStyle(_ref2) {\n    var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount, placeholder = _ref2.placeholder, animate = _ref2.animate;\n    var size = getSize({\n        isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n        placeholder: placeholder,\n        animate: animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nfunction Placeholder(props) {\n    var animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var tryClearAnimateOpenTimer = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    var animate = props.animate, onTransitionEnd = props.onTransitionEnd, onClose = props.onClose, contextId = props.contextId;\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\"), isAnimatingOpenOnMount = _useState[0], setIsAnimatingOpenOnMount = _useState[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (!isAnimatingOpenOnMount) {\n            return noop$2;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop$2;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop$2;\n        }\n        animateOpenTimerRef.current = setTimeout(function() {\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    var onSizeChangeEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(event) {\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    var style = getStyle({\n        isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style: style,\n        \"data-rbd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n}\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, \"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \") : 0 : void 0;\n}\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach(function(check) {\n        return check(args);\n    });\n}\nvar shared = [\n    function required(_ref) {\n        var props = _ref.props;\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, \"A Droppable requires a [string] droppableId. Provided: [\" + typeof props.droppableId + \"]\") : 0 : void 0;\n    },\n    function _boolean(_ref2) {\n        var props = _ref2.props;\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref(_ref3) {\n        var getDroppableRef = _ref3.getDroppableRef;\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nvar standard = [\n    function placeholder(_ref4) {\n        var props = _ref4.props, getPlaceholderRef = _ref4.getPlaceholderRef;\n        if (!props.placeholder) {\n            return;\n        }\n        var ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning('\\n      Droppable setup issue [droppableId: \"' + props.droppableId + '\"]:\\n      DroppableProvided > placeholder could not be found.\\n\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\n    ') : 0;\n    }\n];\nvar virtual = [\n    function hasClone(_ref5) {\n        var props = _ref5.props;\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder(_ref6) {\n        var getPlaceholderRef = _ref6.getPlaceholderRef;\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(function() {\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nvar AnimateInOut = function(_React$PureComponent) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(AnimateInOut, _React$PureComponent);\n    function AnimateInOut() {\n        var _this;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _React$PureComponent.call.apply(_React$PureComponent, [\n            this\n        ].concat(args)) || this;\n        _this.state = {\n            isVisible: Boolean(_this.props.on),\n            data: _this.props.on,\n            animate: _this.props.shouldAnimate && _this.props.on ? \"open\" : \"none\"\n        };\n        _this.onClose = function() {\n            if (_this.state.animate !== \"close\") {\n                return;\n            }\n            _this.setState({\n                isVisible: false\n            });\n        };\n        return _this;\n    }\n    AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    };\n    var _proto = AnimateInOut.prototype;\n    _proto.render = function render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        var provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    };\n    return AnimateInOut;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent));\nvar zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\n    if (!isCombining) {\n        return null;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    var dimension = dragging.dimension;\n    var box = dimension.client;\n    var offset = dragging.offset, combineWith = dragging.combineWith, dropping = dragging.dropping;\n    var isCombining = Boolean(combineWith);\n    var shouldAnimate = getShouldDraggingAnimate(dragging);\n    var isDropAnimating = Boolean(dropping);\n    var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    var style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform: transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? null : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll) {\n    if (windowScroll === void 0) {\n        windowScroll = origin;\n    }\n    var computedStyles = window.getComputedStyle(el);\n    var borderBox = el.getBoundingClientRect();\n    var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.calculateBox)(borderBox, computedStyles);\n    var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, windowScroll);\n    var placeholder = {\n        client: client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    var displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    var dimension = {\n        descriptor: descriptor,\n        placeholder: placeholder,\n        displaceBy: displaceBy,\n        client: client,\n        page: page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    var uniqueId = useUniqueId(\"draggable\");\n    var descriptor = args.descriptor, registry = args.registry, getDraggableRef = args.getDraggableRef, canDragInteractiveElements = args.canDragInteractiveElements, shouldRespectForcePress = args.shouldRespectForcePress, isEnabled = args.isEnabled;\n    var options = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            canDragInteractiveElements: canDragInteractiveElements,\n            shouldRespectForcePress: shouldRespectForcePress,\n            isEnabled: isEnabled\n        };\n    }, [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    var getDimension = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(windowScroll) {\n        var el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    var entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            uniqueId: uniqueId,\n            descriptor: descriptor,\n            options: options,\n            getDimension: getDimension\n        };\n    }, [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    var publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    var isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useIsomorphicLayoutEffect(function() {\n        registry.draggable.register(publishedRef.current);\n        return function() {\n            return registry.draggable.unregister(publishedRef.current);\n        };\n    }, [\n        registry.draggable\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        var last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(function() {\n        function prefix(id) {\n            return \"Draggable[id: \" + id + \"]: \";\n        }\n        var id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, \"Draggable requires a [string] draggableId.\\n      Provided: [type: \" + typeof id + \"] (value: \" + id + \")\") : 0 : void 0;\n        !isInteger(props.index) ?  true ? invariant(false, prefix(id) + \" requires an integer index prop\") : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, prefix(id) + \" Unable to find drag handle\") : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(function() {\n        var initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(function() {\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nfunction Draggable(props) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var setRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(el) {\n        ref.current = el;\n    }, []);\n    var getRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return ref.current;\n    }, []);\n    var _useRequiredContext = useRequiredContext(AppContext), contextId = _useRequiredContext.contextId, dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId, registry = _useRequiredContext.registry;\n    var _useRequiredContext2 = useRequiredContext(DroppableContext), type = _useRequiredContext2.type, droppableId = _useRequiredContext2.droppableId;\n    var descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            id: props.draggableId,\n            index: props.index,\n            type: type,\n            droppableId: droppableId\n        };\n    }, [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    var children = props.children, draggableId = props.draggableId, isEnabled = props.isEnabled, shouldRespectForcePress = props.shouldRespectForcePress, canDragInteractiveElements = props.canDragInteractiveElements, isClone = props.isClone, mapped = props.mapped, dropAnimationFinishedAction = props.dropAnimationFinished;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        var forPublisher = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n            return {\n                descriptor: descriptor,\n                registry: registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements: canDragInteractiveElements,\n                shouldRespectForcePress: shouldRespectForcePress,\n                isEnabled: isEnabled\n            };\n        }, [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    var dragHandleProps = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rbd-drag-handle-draggable-id\": draggableId,\n            \"data-rbd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null;\n    }, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    var onMoveEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(event) {\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        dropAnimationFinishedAction();\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    var provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        var style = getStyle$1(mapped);\n        var onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : null;\n        var result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rbd-draggable-context-id\": contextId,\n                \"data-rbd-draggable-id\": draggableId,\n                style: style,\n                onTransitionEnd: onTransitionEnd\n            },\n            dragHandleProps: dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    var rubric = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        };\n    }, [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return children(provided, mapped.snapshot, rubric);\n}\nvar isStrictEqual = function(a, b) {\n    return a === b;\n};\nvar whatIsDraggedOverFromResult = function(result) {\n    var combine = result.combine, destination = result.destination;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\n    return result.combine ? result.combine.draggableId : null;\n};\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    var memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(x, y) {\n        return {\n            x: x,\n            y: y\n        };\n    });\n    var getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(mode, isClone, draggingOver, combineWith, dropping) {\n        return {\n            isDragging: true,\n            isClone: isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode: mode,\n            draggingOver: draggingOver,\n            combineWith: combineWith,\n            combineTargetFor: null\n        };\n    });\n    var getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\n        return {\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver: draggingOver,\n                combineWith: combineWith,\n                mode: mode,\n                offset: offset,\n                dimension: dimension,\n                forceShouldAnimate: forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        };\n    });\n    var selector = function selector(state, ownProps) {\n        if (state.isDragging) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            var offset = state.current.client.offset;\n            var dimension = state.dimensions.draggables[ownProps.draggableId];\n            var draggingOver = whatIsDraggedOver(state.impact);\n            var combineWith = getCombineWithFromImpact(state.impact);\n            var forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            var completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            var isClone = ownProps.isClone;\n            var _dimension = state.dimensions.draggables[ownProps.draggableId];\n            var result = completed.result;\n            var mode = result.mode;\n            var _draggingOver = whatIsDraggedOverFromResult(result);\n            var _combineWith = getCombineWithFromResult(result);\n            var duration = state.dropDuration;\n            var dropping = {\n                duration: duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: _combineWith ? combine.opacity.drop : null,\n                scale: _combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension: _dimension,\n                    dropping: dropping,\n                    draggingOver: _draggingOver,\n                    combineWith: _combineWith,\n                    mode: mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor) {\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor: combineTargetFor,\n        combineWith: null\n    };\n}\nvar atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    var memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(x, y) {\n        return {\n            x: x,\n            y: y\n        };\n    });\n    var getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(getSecondarySnapshot);\n    var getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(offset, combineTargetFor, shouldAnimateDisplacement) {\n        if (combineTargetFor === void 0) {\n            combineTargetFor = null;\n        }\n        return {\n            mapped: {\n                type: \"SECONDARY\",\n                offset: offset,\n                combineTargetFor: combineTargetFor,\n                shouldAnimateDisplacement: shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        };\n    });\n    var getFallback = function getFallback(combineTargetFor) {\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    var getProps = function getProps(ownId, draggingId, impact, afterCritical) {\n        var visualDisplacement = impact.displaced.visible[ownId];\n        var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        var combine = tryGetCombine(impact);\n        var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            var change = negate(afterCritical.displacedBy.point);\n            var _offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(_offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        var displaceBy = impact.displacedBy.point;\n        var offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    var selector = function selector(state, ownProps) {\n        if (state.isDragging) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            var completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nvar makeMapStateToProps = function makeMapStateToProps() {\n    var draggingSelector = getDraggableSelector();\n    var secondarySelector = getSecondarySelector();\n    var selector = function selector(state, ownProps) {\n        return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    };\n    return selector;\n};\nvar mapDispatchToProps = {\n    dropAnimationFinished: dropAnimationFinished\n};\nvar ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.connect)(makeMapStateToProps, mapDispatchToProps, null, {\n    context: StoreContext,\n    pure: true,\n    areStatePropsEqual: isStrictEqual\n})(Draggable);\nfunction PrivateDraggable(props) {\n    var droppableContext = useRequiredContext(DroppableContext);\n    var isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n    var isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nfunction Droppable(props) {\n    var appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    var contextId = appContext.contextId, isMovementAllowed = appContext.isMovementAllowed;\n    var droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var children = props.children, droppableId = props.droppableId, type = props.type, mode = props.mode, direction = props.direction, ignoreContainerClipping = props.ignoreContainerClipping, isDropDisabled = props.isDropDisabled, isCombineEnabled = props.isCombineEnabled, snapshot = props.snapshot, useClone = props.useClone, updateViewportMaxScroll = props.updateViewportMaxScroll, getContainerForClone = props.getContainerForClone;\n    var getDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return droppableRef.current;\n    }, []);\n    var setDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(value) {\n        droppableRef.current = value;\n    }, []);\n    var getPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return placeholderRef.current;\n    }, []);\n    var setPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(value) {\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props: props,\n        getDroppableRef: getDroppableRef,\n        getPlaceholderRef: getPlaceholderRef\n    });\n    var onPlaceholderTransitionEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId: droppableId,\n        type: type,\n        mode: mode,\n        direction: direction,\n        isDropDisabled: isDropDisabled,\n        isCombineEnabled: isCombineEnabled,\n        ignoreContainerClipping: ignoreContainerClipping,\n        getDroppableRef: getDroppableRef\n    });\n    var placeholder = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n        on: props.placeholder,\n        shouldAnimate: props.shouldAnimatePlaceholder\n    }, function(_ref) {\n        var onClose = _ref.onClose, data = _ref.data, animate = _ref.animate;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n            placeholder: data,\n            onClose: onClose,\n            innerRef: setPlaceholderRef,\n            animate: animate,\n            contextId: contextId,\n            onTransitionEnd: onPlaceholderTransitionEnd\n        });\n    });\n    var provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            innerRef: setDroppableRef,\n            placeholder: placeholder,\n            droppableProps: {\n                \"data-rbd-droppable-id\": droppableId,\n                \"data-rbd-droppable-context-id\": contextId\n            }\n        };\n    }, [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    var droppableContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            droppableId: droppableId,\n            type: type,\n            isUsingCloneFor: isUsingCloneFor\n        };\n    }, [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        var dragging = useClone.dragging, render = useClone.render;\n        var node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, function(draggableProvided, draggableSnapshot) {\n            return render(draggableProvided, draggableSnapshot, dragging);\n        });\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_4___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n}\nvar isMatchingType = function isMatchingType(type, critical) {\n    return type === critical.droppable.type;\n};\nvar getDraggable = function getDraggable(critical, dimensions) {\n    return dimensions.draggables[critical.draggable.id];\n};\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\n    var idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    var idleWithoutAnimation = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, idleWithAnimation, {\n        shouldAnimatePlaceholder: false\n    });\n    var getDraggableRubric = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(descriptor) {\n        return {\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        };\n    });\n    var getMapProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {\n        var draggableId = dragging.descriptor.id;\n        var isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            var useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            var _snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot: _snapshot,\n                useClone: useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        var snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot: snapshot,\n            useClone: null\n        };\n    });\n    var selector = function selector(state, ownProps) {\n        var id = ownProps.droppableId;\n        var type = ownProps.type;\n        var isEnabled = !ownProps.isDropDisabled;\n        var renderClone = ownProps.renderClone;\n        if (state.isDragging) {\n            var critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            var dragging = getDraggable(critical, state.dimensions);\n            var isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            var completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            var _dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            var _completed = state.completed;\n            if (!isMatchingType(type, _completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            var wasOver = whatIsDraggedOver(_completed.impact) === id;\n            var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === \"COMBINE\");\n            var isHome = _completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nvar mapDispatchToProps$1 = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nvar defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nvar ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    pure: true,\n    areStatePropsEqual: isStrictEqual\n})(Droppable);\nConnectedDroppable.defaultProps = defaultProps;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYmVhdXRpZnVsLWRuZC9kaXN0L3JlYWN0LWJlYXV0aWZ1bC1kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDbEI7QUFDWjtBQUN5QztBQUNuRDtBQUNJO0FBQ2lEO0FBQ2hFO0FBQ047QUFDRTtBQUVqQyxJQUFJMkIsZUFBZUMsa0JBQXlCO0FBQzVDLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxzQkFBc0I7QUFFMUIsSUFBSUMsUUFBUSxTQUFTQSxNQUFNQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQ0osZUFBZSxLQUFLSSxPQUFPLENBQUNILHFCQUFxQixJQUFJSSxJQUFJO0FBQ2hGO0FBRUEsSUFBSUMsZ0JBQWdCLFNBQVNBLGNBQWNDLE9BQU87SUFDaEQsT0FBT0wsTUFBTSxzQ0FBc0NBLE1BQU1LLFdBQVc7QUFDdEU7QUFFQSxJQUFJQyxzQkFBc0IsU0FBU0Esb0JBQW9CRCxPQUFPO0lBQzVELE9BQU87UUFBQ0QsY0FBY0M7UUFBVTtRQUF3RDtRQUFvQjtLQUFrQjtBQUNoSTtBQUNBLElBQUlFLGlCQUFpQjtBQUNyQixTQUFTQyxJQUFJQyxJQUFJLEVBQUVKLE9BQU87SUFDeEIsSUFBSUs7SUFFSixJQUFJZCxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSxJQUFJLEtBQXVELEVBQUUsRUFFNUQ7SUFFQWMsQ0FBQUEsV0FBV0UsT0FBTSxDQUFFLENBQUNILEtBQUssQ0FBQ0ksS0FBSyxDQUFDSCxVQUFVSixvQkFBb0JEO0FBQ2pFO0FBQ0EsSUFBSVMsVUFBVU4sSUFBSU8sSUFBSSxDQUFDLE1BQU07QUFDN0IsSUFBSUMsUUFBUVIsSUFBSU8sSUFBSSxDQUFDLE1BQU07QUFFM0IsU0FBU0UsUUFBUTtBQUVqQixTQUFTQyxXQUFXQyxNQUFNLEVBQUVDLFdBQVc7SUFDckMsT0FBTzVDLDhFQUFRQSxDQUFDLENBQUMsR0FBRzJDLFFBQVEsQ0FBQyxHQUFHQztB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QUkwZSx1QkFBdUI7SUFDekI5d0IseUJBQXlCQTtBQUMzQjtBQUVBLFNBQVMrd0I7SUFDUCxDQUFDcnNCLFNBQVNzTyxJQUFJLEdBQUc3MEIsS0FBcUMsR0FBRzRDLFVBQVUsT0FBTyxnQ0FBZ0NBLENBQWdCLEdBQUcsS0FBSztJQUNsSSxPQUFPMmpCLFNBQVNzTyxJQUFJO0FBQ3RCO0FBRUEsSUFBSWdlLGVBQWU7SUFDakJ0N0IsTUFBTTtJQUNOM1csTUFBTTtJQUNOb08sV0FBVztJQUNYKzRCLGdCQUFnQjtJQUNoQmo3QixrQkFBa0I7SUFDbEJnOEIseUJBQXlCO0lBQ3pCd0MsYUFBYTtJQUNiMEYsc0JBQXNCNEI7QUFDeEI7QUFDQSxJQUFJRSxxQkFBcUI1ekMsb0RBQU9BLENBQUMyeUMsdUJBQXVCYyxzQkFBc0IsTUFBTTtJQUNsRmpmLFNBQVM0RTtJQUNUOFgsTUFBTTtJQUNOQyxvQkFBb0IvQjtBQUN0QixHQUFHc0M7QUFDSGtDLG1CQUFtQkQsWUFBWSxHQUFHQTtBQUUrSCIsInNvdXJjZXMiOlsid2VicGFjazovL3Nsb3Blc2hpZnQvLi9ub2RlX21vZHVsZXMvcmVhY3QtYmVhdXRpZnVsLWRuZC9kaXN0L3JlYWN0LWJlYXV0aWZ1bC1kbmQuZXNtLmpzPzgwZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUgYXMgY3JlYXRlU3RvcmUkMSwgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlLCBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBQcm92aWRlciwgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAndXNlLW1lbW8tb25lJztcbmltcG9ydCB7IGdldFJlY3QsIGV4cGFuZCwgb2Zmc2V0LCB3aXRoU2Nyb2xsLCBnZXRCb3gsIGNyZWF0ZUJveCwgY2FsY3VsYXRlQm94IH0gZnJvbSAnY3NzLWJveC1tb2RlbCc7XG5pbXBvcnQgbWVtb2l6ZU9uZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgcmFmU2NoZCBmcm9tICdyYWYtc2NoZCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG52YXIgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG52YXIgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcblxudmFyIGNsZWFuID0gZnVuY3Rpb24gY2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKS5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKS50cmltKCk7XG59O1xuXG52YXIgZ2V0RGV2TWVzc2FnZSA9IGZ1bmN0aW9uIGdldERldk1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gY2xlYW4oXCJcXG4gICVjcmVhY3QtYmVhdXRpZnVsLWRuZFxcblxcbiAgJWNcIiArIGNsZWFuKG1lc3NhZ2UpICsgXCJcXG5cXG4gICVjXFx1RDgzRFxcdURDNzdcXHUyMDBEIFRoaXMgaXMgYSBkZXZlbG9wbWVudCBvbmx5IG1lc3NhZ2UuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cXG5cIik7XG59O1xuXG52YXIgZ2V0Rm9ybWF0dGVkTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gW2dldERldk1lc3NhZ2UobWVzc2FnZSksICdjb2xvcjogIzAwQzU4NDsgZm9udC1zaXplOiAxLjJlbTsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2xpbmUtaGVpZ2h0OiAxLjUnLCAnY29sb3I6ICM3MjM4NzQ7J107XG59O1xudmFyIGlzRGlzYWJsZWRGbGFnID0gJ19fcmVhY3QtYmVhdXRpZnVsLWRuZC1kaXNhYmxlLWRldi13YXJuaW5ncyc7XG5mdW5jdGlvbiBsb2codHlwZSwgbWVzc2FnZSkge1xuICB2YXIgX2NvbnNvbGU7XG5cbiAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbaXNEaXNhYmxlZEZsYWddKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgKF9jb25zb2xlID0gY29uc29sZSlbdHlwZV0uYXBwbHkoX2NvbnNvbGUsIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xufVxudmFyIHdhcm5pbmcgPSBsb2cuYmluZChudWxsLCAnd2FybicpO1xudmFyIGVycm9yID0gbG9nLmJpbmQobnVsbCwgJ2Vycm9yJyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKHNoYXJlZCwgZnJvbUJpbmRpbmcpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBzaGFyZWQsIHt9LCBmcm9tQmluZGluZyk7XG59XG5cbmZ1bmN0aW9uIGJpbmRFdmVudHMoZWwsIGJpbmRpbmdzLCBzaGFyZWRPcHRpb25zKSB7XG4gIHZhciB1bmJpbmRpbmdzID0gYmluZGluZ3MubWFwKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIGJpbmRpbmcub3B0aW9ucyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmV2ZW50TmFtZSwgYmluZGluZy5mbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gdW5iaW5kQWxsKCkge1xuICAgIHVuYmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAodW5iaW5kKSB7XG4gICAgICB1bmJpbmQoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIGlzUHJvZHVjdGlvbiQxID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbnZhciBwcmVmaXggPSAnSW52YXJpYW50IGZhaWxlZCc7XG5mdW5jdGlvbiBSYmRJbnZhcmlhbnQobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5SYmRJbnZhcmlhbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNQcm9kdWN0aW9uJDEpIHtcbiAgICB0aHJvdyBuZXcgUmJkSW52YXJpYW50KHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXggKyBcIjogXCIgKyAobWVzc2FnZSB8fCAnJykpO1xuICB9XG59XG5cbnZhciBFcnJvckJvdW5kYXJ5ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIF90aGlzLnVuYmluZCA9IG5vb3A7XG5cbiAgICBfdGhpcy5vbldpbmRvd0Vycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gX3RoaXMuZ2V0Q2FsbGJhY2tzKCk7XG5cbiAgICAgIGlmIChjYWxsYmFja3MuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIGNhbGxiYWNrcy50cnlBYm9ydCgpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgICBBbiBlcnJvciB3YXMgY2F1Z2h0IGJ5IG91ciB3aW5kb3cgJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB3aGlsZSBhIGRyYWcgd2FzIG9jY3VycmluZy5cXG4gICAgICAgIFRoZSBhY3RpdmUgZHJhZyBoYXMgYmVlbiBhYm9ydGVkLlxcbiAgICAgIFwiKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGVyciA9IGV2ZW50LmVycm9yO1xuXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUmJkSW52YXJpYW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Q2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBBcHBDYWxsYmFja3MgaW4gPEVycm9yQm91bmRhcnkvPicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuY2FsbGJhY2tzO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRDYWxsYmFja3MgPSBmdW5jdGlvbiAoY2FsbGJhY2tzKSB7XG4gICAgICBfdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFcnJvckJvdW5kYXJ5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgZXZlbnROYW1lOiAnZXJyb3InLFxuICAgICAgZm46IHRoaXMub25XaW5kb3dFcnJvclxuICAgIH1dKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiBjb21wb25lbnREaWRDYXRjaChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgUmJkSW52YXJpYW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zZXRDYWxsYmFja3MpO1xuICB9O1xuXG4gIHJldHVybiBFcnJvckJvdW5kYXJ5O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG52YXIgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gXCJcXG4gIFByZXNzIHNwYWNlIGJhciB0byBzdGFydCBhIGRyYWcuXFxuICBXaGVuIGRyYWdnaW5nIHlvdSBjYW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0gYXJvdW5kIGFuZCBlc2NhcGUgdG8gY2FuY2VsLlxcbiAgU29tZSBzY3JlZW4gcmVhZGVycyBtYXkgcmVxdWlyZSB5b3UgdG8gYmUgaW4gZm9jdXMgbW9kZSBvciB0byB1c2UgeW91ciBwYXNzIHRocm91Z2gga2V5XFxuXCI7XG5cbnZhciBwb3NpdGlvbiA9IGZ1bmN0aW9uIHBvc2l0aW9uKGluZGV4KSB7XG4gIHJldHVybiBpbmRleCArIDE7XG59O1xuXG52YXIgb25EcmFnU3RhcnQgPSBmdW5jdGlvbiBvbkRyYWdTdGFydChzdGFydCkge1xuICByZXR1cm4gXCJcXG4gIFlvdSBoYXZlIGxpZnRlZCBhbiBpdGVtIGluIHBvc2l0aW9uIFwiICsgcG9zaXRpb24oc3RhcnQuc291cmNlLmluZGV4KSArIFwiXFxuXCI7XG59O1xuXG52YXIgd2l0aExvY2F0aW9uID0gZnVuY3Rpb24gd2l0aExvY2F0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIGlzSW5Ib21lTGlzdCA9IHNvdXJjZS5kcm9wcGFibGVJZCA9PT0gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIHZhciBzdGFydFBvc2l0aW9uID0gcG9zaXRpb24oc291cmNlLmluZGV4KTtcbiAgdmFyIGVuZFBvc2l0aW9uID0gcG9zaXRpb24oZGVzdGluYXRpb24uaW5kZXgpO1xuXG4gIGlmIChpc0luSG9tZUxpc3QpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICBZb3UgaGF2ZSBtb3ZlZCB0aGUgaXRlbSBmcm9tIHBvc2l0aW9uIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiXFxuICAgICAgdG8gcG9zaXRpb24gXCIgKyBlbmRQb3NpdGlvbiArIFwiXFxuICAgIFwiO1xuICB9XG5cbiAgcmV0dXJuIFwiXFxuICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gXCIgKyBzdGFydFBvc2l0aW9uICsgXCJcXG4gICAgaW4gbGlzdCBcIiArIHNvdXJjZS5kcm9wcGFibGVJZCArIFwiXFxuICAgIHRvIGxpc3QgXCIgKyBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZCArIFwiXFxuICAgIGluIHBvc2l0aW9uIFwiICsgZW5kUG9zaXRpb24gKyBcIlxcbiAgXCI7XG59O1xuXG52YXIgd2l0aENvbWJpbmUgPSBmdW5jdGlvbiB3aXRoQ29tYmluZShpZCwgc291cmNlLCBjb21iaW5lKSB7XG4gIHZhciBpbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBjb21iaW5lLmRyb3BwYWJsZUlkO1xuXG4gIGlmIChpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIFwiXFxuICAgICAgVGhlIGl0ZW0gXCIgKyBpZCArIFwiXFxuICAgICAgaGFzIGJlZW4gY29tYmluZWQgd2l0aCBcIiArIGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIH1cblxuICByZXR1cm4gXCJcXG4gICAgICBUaGUgaXRlbSBcIiArIGlkICsgXCJcXG4gICAgICBpbiBsaXN0IFwiICsgc291cmNlLmRyb3BwYWJsZUlkICsgXCJcXG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoIFwiICsgY29tYmluZS5kcmFnZ2FibGVJZCArIFwiXFxuICAgICAgaW4gbGlzdCBcIiArIGNvbWJpbmUuZHJvcHBhYmxlSWQgKyBcIlxcbiAgICBcIjtcbn07XG5cbnZhciBvbkRyYWdVcGRhdGUgPSBmdW5jdGlvbiBvbkRyYWdVcGRhdGUodXBkYXRlKSB7XG4gIHZhciBsb2NhdGlvbiA9IHVwZGF0ZS5kZXN0aW5hdGlvbjtcblxuICBpZiAobG9jYXRpb24pIHtcbiAgICByZXR1cm4gd2l0aExvY2F0aW9uKHVwZGF0ZS5zb3VyY2UsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIHZhciBjb21iaW5lID0gdXBkYXRlLmNvbWJpbmU7XG5cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gd2l0aENvbWJpbmUodXBkYXRlLmRyYWdnYWJsZUlkLCB1cGRhdGUuc291cmNlLCBjb21iaW5lKTtcbiAgfVxuXG4gIHJldHVybiAnWW91IGFyZSBvdmVyIGFuIGFyZWEgdGhhdCBjYW5ub3QgYmUgZHJvcHBlZCBvbic7XG59O1xuXG52YXIgcmV0dXJuZWRUb1N0YXJ0ID0gZnVuY3Rpb24gcmV0dXJuZWRUb1N0YXJ0KHNvdXJjZSkge1xuICByZXR1cm4gXCJcXG4gIFRoZSBpdGVtIGhhcyByZXR1cm5lZCB0byBpdHMgc3RhcnRpbmcgcG9zaXRpb25cXG4gIG9mIFwiICsgcG9zaXRpb24oc291cmNlLmluZGV4KSArIFwiXFxuXCI7XG59O1xuXG52YXIgb25EcmFnRW5kID0gZnVuY3Rpb24gb25EcmFnRW5kKHJlc3VsdCkge1xuICBpZiAocmVzdWx0LnJlYXNvbiA9PT0gJ0NBTkNFTCcpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICBNb3ZlbWVudCBjYW5jZWxsZWQuXFxuICAgICAgXCIgKyByZXR1cm5lZFRvU3RhcnQocmVzdWx0LnNvdXJjZSkgKyBcIlxcbiAgICBcIjtcbiAgfVxuXG4gIHZhciBsb2NhdGlvbiA9IHJlc3VsdC5kZXN0aW5hdGlvbjtcbiAgdmFyIGNvbWJpbmUgPSByZXN1bHQuY29tYmluZTtcblxuICBpZiAobG9jYXRpb24pIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxcbiAgICAgIFwiICsgd2l0aExvY2F0aW9uKHJlc3VsdC5zb3VyY2UsIGxvY2F0aW9uKSArIFwiXFxuICAgIFwiO1xuICB9XG5cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxcbiAgICAgIFwiICsgd2l0aENvbWJpbmUocmVzdWx0LmRyYWdnYWJsZUlkLCByZXN1bHQuc291cmNlLCBjb21iaW5lKSArIFwiXFxuICAgIFwiO1xuICB9XG5cbiAgcmV0dXJuIFwiXFxuICAgIFRoZSBpdGVtIGhhcyBiZWVuIGRyb3BwZWQgd2hpbGUgbm90IG92ZXIgYSBkcm9wIGFyZWEuXFxuICAgIFwiICsgcmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpICsgXCJcXG4gIFwiO1xufTtcblxudmFyIHByZXNldCA9IHtcbiAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMsXG4gIG9uRHJhZ1N0YXJ0OiBvbkRyYWdTdGFydCxcbiAgb25EcmFnVXBkYXRlOiBvbkRyYWdVcGRhdGUsXG4gIG9uRHJhZ0VuZDogb25EcmFnRW5kXG59O1xuXG52YXIgb3JpZ2luID0ge1xuICB4OiAwLFxuICB5OiAwXG59O1xudmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChwb2ludDEsIHBvaW50Mikge1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50MS54ICsgcG9pbnQyLngsXG4gICAgeTogcG9pbnQxLnkgKyBwb2ludDIueVxuICB9O1xufTtcbnZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHBvaW50MSwgcG9pbnQyKSB7XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQxLnggLSBwb2ludDIueCxcbiAgICB5OiBwb2ludDEueSAtIHBvaW50Mi55XG4gIH07XG59O1xudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKHBvaW50MSwgcG9pbnQyKSB7XG4gIHJldHVybiBwb2ludDEueCA9PT0gcG9pbnQyLnggJiYgcG9pbnQxLnkgPT09IHBvaW50Mi55O1xufTtcbnZhciBuZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUocG9pbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludC54ICE9PSAwID8gLXBvaW50LnggOiAwLFxuICAgIHk6IHBvaW50LnkgIT09IDAgPyAtcG9pbnQueSA6IDBcbiAgfTtcbn07XG52YXIgcGF0Y2ggPSBmdW5jdGlvbiBwYXRjaChsaW5lLCB2YWx1ZSwgb3RoZXJWYWx1ZSkge1xuICB2YXIgX3JlZjtcblxuICBpZiAob3RoZXJWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgb3RoZXJWYWx1ZSA9IDA7XG4gIH1cblxuICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW2xpbmVdID0gdmFsdWUsIF9yZWZbbGluZSA9PT0gJ3gnID8gJ3knIDogJ3gnXSA9IG90aGVyVmFsdWUsIF9yZWY7XG59O1xudmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UocG9pbnQxLCBwb2ludDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludDIueCAtIHBvaW50MS54LCAyKSArIE1hdGgucG93KHBvaW50Mi55IC0gcG9pbnQxLnksIDIpKTtcbn07XG52YXIgY2xvc2VzdCA9IGZ1bmN0aW9uIGNsb3Nlc3QodGFyZ2V0LCBwb2ludHMpIHtcbiAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIGRpc3RhbmNlKHRhcmdldCwgcG9pbnQpO1xuICB9KSk7XG59O1xudmFyIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBmbihwb2ludC54KSxcbiAgICAgIHk6IGZuKHBvaW50LnkpXG4gICAgfTtcbiAgfTtcbn07XG5cbnZhciBleGVjdXRlQ2xpcCA9IChmdW5jdGlvbiAoZnJhbWUsIHN1YmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGdldFJlY3Qoe1xuICAgIHRvcDogTWF0aC5tYXgoc3ViamVjdC50b3AsIGZyYW1lLnRvcCksXG4gICAgcmlnaHQ6IE1hdGgubWluKHN1YmplY3QucmlnaHQsIGZyYW1lLnJpZ2h0KSxcbiAgICBib3R0b206IE1hdGgubWluKHN1YmplY3QuYm90dG9tLCBmcmFtZS5ib3R0b20pLFxuICAgIGxlZnQ6IE1hdGgubWF4KHN1YmplY3QubGVmdCwgZnJhbWUubGVmdClcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdC53aWR0aCA8PSAwIHx8IHJlc3VsdC5oZWlnaHQgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgb2Zmc2V0QnlQb3NpdGlvbiA9IGZ1bmN0aW9uIG9mZnNldEJ5UG9zaXRpb24oc3BhY2luZywgcG9pbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHNwYWNpbmcudG9wICsgcG9pbnQueSxcbiAgICBsZWZ0OiBzcGFjaW5nLmxlZnQgKyBwb2ludC54LFxuICAgIGJvdHRvbTogc3BhY2luZy5ib3R0b20gKyBwb2ludC55LFxuICAgIHJpZ2h0OiBzcGFjaW5nLnJpZ2h0ICsgcG9pbnQueFxuICB9O1xufTtcbnZhciBnZXRDb3JuZXJzID0gZnVuY3Rpb24gZ2V0Q29ybmVycyhzcGFjaW5nKSB7XG4gIHJldHVybiBbe1xuICAgIHg6IHNwYWNpbmcubGVmdCxcbiAgICB5OiBzcGFjaW5nLnRvcFxuICB9LCB7XG4gICAgeDogc3BhY2luZy5yaWdodCxcbiAgICB5OiBzcGFjaW5nLnRvcFxuICB9LCB7XG4gICAgeDogc3BhY2luZy5sZWZ0LFxuICAgIHk6IHNwYWNpbmcuYm90dG9tXG4gIH0sIHtcbiAgICB4OiBzcGFjaW5nLnJpZ2h0LFxuICAgIHk6IHNwYWNpbmcuYm90dG9tXG4gIH1dO1xufTtcbnZhciBub1NwYWNpbmcgPSB7XG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMFxufTtcblxudmFyIHNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbCh0YXJnZXQsIGZyYW1lKSB7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldEJ5UG9zaXRpb24odGFyZ2V0LCBmcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQpO1xufTtcblxudmFyIGluY3JlYXNlID0gZnVuY3Rpb24gaW5jcmVhc2UodGFyZ2V0LCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpIHtcbiAgaWYgKHdpdGhQbGFjZWhvbGRlciAmJiB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnkpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0YXJnZXQsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW2F4aXMuZW5kXSA9IHRhcmdldFtheGlzLmVuZF0gKyB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnlbYXhpcy5saW5lXSwgX2V4dGVuZHMyKSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGNsaXAgPSBmdW5jdGlvbiBjbGlwKHRhcmdldCwgZnJhbWUpIHtcbiAgaWYgKGZyYW1lICYmIGZyYW1lLnNob3VsZENsaXBTdWJqZWN0KSB7XG4gICAgcmV0dXJuIGV4ZWN1dGVDbGlwKGZyYW1lLnBhZ2VNYXJnaW5Cb3gsIHRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gZ2V0UmVjdCh0YXJnZXQpO1xufTtcblxudmFyIGdldFN1YmplY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHBhZ2UgPSBfcmVmLnBhZ2UsXG4gICAgICB3aXRoUGxhY2Vob2xkZXIgPSBfcmVmLndpdGhQbGFjZWhvbGRlcixcbiAgICAgIGF4aXMgPSBfcmVmLmF4aXMsXG4gICAgICBmcmFtZSA9IF9yZWYuZnJhbWU7XG4gIHZhciBzY3JvbGxlZCA9IHNjcm9sbChwYWdlLm1hcmdpbkJveCwgZnJhbWUpO1xuICB2YXIgaW5jcmVhc2VkID0gaW5jcmVhc2Uoc2Nyb2xsZWQsIGF4aXMsIHdpdGhQbGFjZWhvbGRlcik7XG4gIHZhciBjbGlwcGVkID0gY2xpcChpbmNyZWFzZWQsIGZyYW1lKTtcbiAgcmV0dXJuIHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogd2l0aFBsYWNlaG9sZGVyLFxuICAgIGFjdGl2ZTogY2xpcHBlZFxuICB9O1xufSk7XG5cbnZhciBzY3JvbGxEcm9wcGFibGUgPSAoZnVuY3Rpb24gKGRyb3BwYWJsZSwgbmV3U2Nyb2xsKSB7XG4gICFkcm9wcGFibGUuZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIHNjcm9sbGFibGUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIHZhciBzY3JvbGxEaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsKTtcbiAgdmFyIHNjcm9sbERpc3BsYWNlbWVudCA9IG5lZ2F0ZShzY3JvbGxEaWZmKTtcblxuICB2YXIgZnJhbWUgPSBfZXh0ZW5kcyh7fSwgc2Nyb2xsYWJsZSwge1xuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsYWJsZS5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IHNjcm9sbERpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudDogc2Nyb2xsRGlzcGxhY2VtZW50XG4gICAgICB9LFxuICAgICAgbWF4OiBzY3JvbGxhYmxlLnNjcm9sbC5tYXhcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcixcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogZnJhbWVcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IF9leHRlbmRzKHt9LCBkcm9wcGFibGUsIHtcbiAgICBmcmFtZTogZnJhbWUsXG4gICAgc3ViamVjdDogc3ViamVjdFxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcikge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59XG5mdW5jdGlvbiB2YWx1ZXMobWFwKSB7XG4gIGlmIChPYmplY3QudmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1hcFtrZXldO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmRJbmRleChsaXN0LCBwcmVkaWNhdGUpIHtcbiAgaWYgKGxpc3QuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3QuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljYXRlKGxpc3RbaV0pKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmaW5kKGxpc3QsIHByZWRpY2F0ZSkge1xuICBpZiAobGlzdC5maW5kKSB7XG4gICAgcmV0dXJuIGxpc3QuZmluZChwcmVkaWNhdGUpO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gZmluZEluZGV4KGxpc3QsIHByZWRpY2F0ZSk7XG5cbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0b0FycmF5KGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QpO1xufVxuXG52YXIgdG9Ecm9wcGFibGVNYXAgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChkcm9wcGFibGVzKSB7XG4gIHJldHVybiBkcm9wcGFibGVzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sIHt9KTtcbn0pO1xudmFyIHRvRHJhZ2dhYmxlTWFwID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZHJhZ2dhYmxlcykge1xuICByZXR1cm4gZHJhZ2dhYmxlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LCB7fSk7XG59KTtcbnZhciB0b0Ryb3BwYWJsZUxpc3QgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChkcm9wcGFibGVzKSB7XG4gIHJldHVybiB2YWx1ZXMoZHJvcHBhYmxlcyk7XG59KTtcbnZhciB0b0RyYWdnYWJsZUxpc3QgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChkcmFnZ2FibGVzKSB7XG4gIHJldHVybiB2YWx1ZXMoZHJhZ2dhYmxlcyk7XG59KTtcblxudmFyIGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChkcm9wcGFibGVJZCwgZHJhZ2dhYmxlcykge1xuICB2YXIgcmVzdWx0ID0gdG9EcmFnZ2FibGVMaXN0KGRyYWdnYWJsZXMpLmZpbHRlcihmdW5jdGlvbiAoZHJhZ2dhYmxlKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZUlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZDtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXg7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmZ1bmN0aW9uIHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmRlc3RpbmF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cnlHZXRDb21iaW5lKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmNvbWJpbmU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHJlbW92ZURyYWdnYWJsZUZyb21MaXN0ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAocmVtb3ZlLCBsaXN0KSB7XG4gIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLmRlc2NyaXB0b3IuaWQgIT09IHJlbW92ZS5kZXNjcmlwdG9yLmlkO1xuICB9KTtcbn0pO1xuXG52YXIgbW92ZVRvTmV4dENvbWJpbmUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IF9yZWYuaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBwcmV2aW91c0ltcGFjdCA9IF9yZWYucHJldmlvdXNJbXBhY3Q7XG5cbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihwcmV2aW91c0ltcGFjdCk7XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW1wYWN0KHRhcmdldCkge1xuICAgIHZhciBhdCA9IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IHRhcmdldCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWRcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJldmlvdXNJbXBhY3QsIHtcbiAgICAgIGF0OiBhdFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFsbCA9IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZC5hbGw7XG4gIHZhciBjbG9zZXN0SWQgPSBhbGwubGVuZ3RoID8gYWxsWzBdIDogbnVsbDtcblxuICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3RJZCA/IGdldEltcGFjdChjbG9zZXN0SWQpIDogbnVsbDtcbiAgfVxuXG4gIHZhciB3aXRob3V0RHJhZ2dhYmxlID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG5cbiAgaWYgKCFjbG9zZXN0SWQpIHtcbiAgICBpZiAoIXdpdGhvdXREcmFnZ2FibGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHdpdGhvdXREcmFnZ2FibGVbd2l0aG91dERyYWdnYWJsZS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gZ2V0SW1wYWN0KGxhc3QuZGVzY3JpcHRvci5pZCk7XG4gIH1cblxuICB2YXIgaW5kZXhPZkNsb3Nlc3QgPSBmaW5kSW5kZXgod2l0aG91dERyYWdnYWJsZSwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5kZXNjcmlwdG9yLmlkID09PSBjbG9zZXN0SWQ7XG4gIH0pO1xuICAhKGluZGV4T2ZDbG9zZXN0ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBkaXNwbGFjZWQgaXRlbSBpbiBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBwcm9wb3NlZEluZGV4ID0gaW5kZXhPZkNsb3Nlc3QgLSAxO1xuXG4gIGlmIChwcm9wb3NlZEluZGV4IDwgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGJlZm9yZSA9IHdpdGhvdXREcmFnZ2FibGVbcHJvcG9zZWRJbmRleF07XG4gIHJldHVybiBnZXRJbXBhY3QoYmVmb3JlLmRlc2NyaXB0b3IuaWQpO1xufSk7XG5cbnZhciBpc0hvbWVPZiA9IChmdW5jdGlvbiAoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikge1xuICByZXR1cm4gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQ7XG59KTtcblxudmFyIG5vRGlzcGxhY2VkQnkgPSB7XG4gIHBvaW50OiBvcmlnaW4sXG4gIHZhbHVlOiAwXG59O1xudmFyIGVtcHR5R3JvdXBzID0ge1xuICBpbnZpc2libGU6IHt9LFxuICB2aXNpYmxlOiB7fSxcbiAgYWxsOiBbXVxufTtcbnZhciBub0ltcGFjdCA9IHtcbiAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgZGlzcGxhY2VkQnk6IG5vRGlzcGxhY2VkQnksXG4gIGF0OiBudWxsXG59O1xuXG52YXIgaXNXaXRoaW4gPSAoZnVuY3Rpb24gKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBsb3dlckJvdW5kIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVwcGVyQm91bmQ7XG4gIH07XG59KTtcblxudmFyIGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSA9IChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgdmFyIGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIHZhciBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHZhciBpc0NvbnRhaW5lZCA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcblxuICAgIGlmIChpc0NvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSB8fCBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKTtcbiAgICB2YXIgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5ID0gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgfHwgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIHZhciBpc1BhcnRpYWxseUNvbnRhaW5lZCA9IGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5O1xuXG4gICAgaWYgKGlzUGFydGlhbGx5Q29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNCaWdnZXJWZXJ0aWNhbGx5ID0gc3ViamVjdC50b3AgPCBmcmFtZS50b3AgJiYgc3ViamVjdC5ib3R0b20gPiBmcmFtZS5ib3R0b207XG4gICAgdmFyIGlzQmlnZ2VySG9yaXpvbnRhbGx5ID0gc3ViamVjdC5sZWZ0IDwgZnJhbWUubGVmdCAmJiBzdWJqZWN0LnJpZ2h0ID4gZnJhbWUucmlnaHQ7XG4gICAgdmFyIGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lID0gaXNCaWdnZXJWZXJ0aWNhbGx5ICYmIGlzQmlnZ2VySG9yaXpvbnRhbGx5O1xuXG4gICAgaWYgKGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXMgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5IHx8IGlzQmlnZ2VySG9yaXpvbnRhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHk7XG4gICAgcmV0dXJuIGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzO1xuICB9O1xufSk7XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gKGZ1bmN0aW9uIChmcmFtZSkge1xuICB2YXIgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgdmFyIGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgdmFyIGlzQ29udGFpbmVkID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIHJldHVybiBpc0NvbnRhaW5lZDtcbiAgfTtcbn0pO1xuXG52YXIgdmVydGljYWwgPSB7XG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgbGluZTogJ3knLFxuICBjcm9zc0F4aXNMaW5lOiAneCcsXG4gIHN0YXJ0OiAndG9wJyxcbiAgZW5kOiAnYm90dG9tJyxcbiAgc2l6ZTogJ2hlaWdodCcsXG4gIGNyb3NzQXhpc1N0YXJ0OiAnbGVmdCcsXG4gIGNyb3NzQXhpc0VuZDogJ3JpZ2h0JyxcbiAgY3Jvc3NBeGlzU2l6ZTogJ3dpZHRoJ1xufTtcbnZhciBob3Jpem9udGFsID0ge1xuICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgbGluZTogJ3gnLFxuICBjcm9zc0F4aXNMaW5lOiAneScsXG4gIHN0YXJ0OiAnbGVmdCcsXG4gIGVuZDogJ3JpZ2h0JyxcbiAgc2l6ZTogJ3dpZHRoJyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICd0b3AnLFxuICBjcm9zc0F4aXNFbmQ6ICdib3R0b20nLFxuICBjcm9zc0F4aXNTaXplOiAnaGVpZ2h0J1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMgPSAoZnVuY3Rpb24gKGF4aXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICAgIHZhciBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgICBpZiAoYXhpcyA9PT0gdmVydGljYWwpIHtcbiAgICAgICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGdldERyb3BwYWJsZURpc3BsYWNlZCA9IGZ1bmN0aW9uIGdldERyb3BwYWJsZURpc3BsYWNlZCh0YXJnZXQsIGRlc3RpbmF0aW9uKSB7XG4gIHZhciBkaXNwbGFjZW1lbnQgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCA6IG9yaWdpbjtcbiAgcmV0dXJuIG9mZnNldEJ5UG9zaXRpb24odGFyZ2V0LCBkaXNwbGFjZW1lbnQpO1xufTtcblxudmFyIGlzVmlzaWJsZUluRHJvcHBhYmxlID0gZnVuY3Rpb24gaXNWaXNpYmxlSW5Ecm9wcGFibGUodGFyZ2V0LCBkZXN0aW5hdGlvbiwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pIHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbihkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkodGFyZ2V0KTtcbn07XG5cbnZhciBpc1Zpc2libGVJblZpZXdwb3J0ID0gZnVuY3Rpb24gaXNWaXNpYmxlSW5WaWV3cG9ydCh0YXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikge1xuICByZXR1cm4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4odmlld3BvcnQpKHRhcmdldCk7XG59O1xuXG52YXIgaXNWaXNpYmxlID0gZnVuY3Rpb24gaXNWaXNpYmxlKF9yZWYpIHtcbiAgdmFyIHRvQmVEaXNwbGFjZWQgPSBfcmVmLnRhcmdldCxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPSBfcmVmLndpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gICAgICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbiA9IF9yZWYuaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm47XG4gIHZhciBkaXNwbGFjZWRUYXJnZXQgPSB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID8gZ2V0RHJvcHBhYmxlRGlzcGxhY2VkKHRvQmVEaXNwbGFjZWQsIGRlc3RpbmF0aW9uKSA6IHRvQmVEaXNwbGFjZWQ7XG4gIHJldHVybiBpc1Zpc2libGVJbkRyb3BwYWJsZShkaXNwbGFjZWRUYXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgJiYgaXNWaXNpYmxlSW5WaWV3cG9ydChkaXNwbGFjZWRUYXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbik7XG59O1xuXG52YXIgaXNQYXJ0aWFsbHlWaXNpYmxlID0gZnVuY3Rpb24gaXNQYXJ0aWFsbHlWaXNpYmxlKGFyZ3MpIHtcbiAgcmV0dXJuIGlzVmlzaWJsZShfZXh0ZW5kcyh7fSwgYXJncywge1xuICAgIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWVcbiAgfSkpO1xufTtcbnZhciBpc1RvdGFsbHlWaXNpYmxlID0gZnVuY3Rpb24gaXNUb3RhbGx5VmlzaWJsZShhcmdzKSB7XG4gIHJldHVybiBpc1Zpc2libGUoX2V4dGVuZHMoe30sIGFyZ3MsIHtcbiAgICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxuICB9KSk7XG59O1xudmFyIGlzVG90YWxseVZpc2libGVPbkF4aXMgPSBmdW5jdGlvbiBpc1RvdGFsbHlWaXNpYmxlT25BeGlzKGFyZ3MpIHtcbiAgcmV0dXJuIGlzVmlzaWJsZShfZXh0ZW5kcyh7fSwgYXJncywge1xuICAgIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzKGFyZ3MuZGVzdGluYXRpb24uYXhpcylcbiAgfSkpO1xufTtcblxudmFyIGdldFNob3VsZEFuaW1hdGUgPSBmdW5jdGlvbiBnZXRTaG91bGRBbmltYXRlKGlkLCBsYXN0LCBmb3JjZVNob3VsZEFuaW1hdGUpIHtcbiAgaWYgKHR5cGVvZiBmb3JjZVNob3VsZEFuaW1hdGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBmb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cblxuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpbnZpc2libGUgPSBsYXN0LmludmlzaWJsZSxcbiAgICAgIHZpc2libGUgPSBsYXN0LnZpc2libGU7XG5cbiAgaWYgKGludmlzaWJsZVtpZF0pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJldmlvdXMgPSB2aXNpYmxlW2lkXTtcbiAgcmV0dXJuIHByZXZpb3VzID8gcHJldmlvdXMuc2hvdWxkQW5pbWF0ZSA6IHRydWU7XG59O1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQoZHJhZ2dhYmxlLCBkaXNwbGFjZWRCeSkge1xuICB2YXIgbWFyZ2luQm94ID0gZHJhZ2dhYmxlLnBhZ2UubWFyZ2luQm94O1xuICB2YXIgZXhwYW5kQnkgPSB7XG4gICAgdG9wOiBkaXNwbGFjZWRCeS5wb2ludC55LFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiBkaXNwbGFjZWRCeS5wb2ludC54XG4gIH07XG4gIHJldHVybiBnZXRSZWN0KGV4cGFuZChtYXJnaW5Cb3gsIGV4cGFuZEJ5KSk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYWNlbWVudEdyb3VwcyhfcmVmKSB7XG4gIHZhciBhZnRlckRyYWdnaW5nID0gX3JlZi5hZnRlckRyYWdnaW5nLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgZGlzcGxhY2VkQnkgPSBfcmVmLmRpc3BsYWNlZEJ5LFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlID0gX3JlZi5mb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgICBsYXN0ID0gX3JlZi5sYXN0O1xuICByZXR1cm4gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoZnVuY3Rpb24gcHJvY2Vzcyhncm91cHMsIGRyYWdnYWJsZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoZHJhZ2dhYmxlLCBkaXNwbGFjZWRCeSk7XG4gICAgdmFyIGlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQ7XG4gICAgZ3JvdXBzLmFsbC5wdXNoKGlkKTtcbiAgICB2YXIgaXNWaXNpYmxlID0gaXNQYXJ0aWFsbHlWaXNpYmxlKHtcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgIGdyb3Vwcy5pbnZpc2libGVbZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZEFuaW1hdGUgPSBnZXRTaG91bGRBbmltYXRlKGlkLCBsYXN0LCBmb3JjZVNob3VsZEFuaW1hdGUpO1xuICAgIHZhciBkaXNwbGFjZW1lbnQgPSB7XG4gICAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgICBzaG91bGRBbmltYXRlOiBzaG91bGRBbmltYXRlXG4gICAgfTtcbiAgICBncm91cHMudmlzaWJsZVtpZF0gPSBkaXNwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfSwge1xuICAgIGFsbDogW10sXG4gICAgdmlzaWJsZToge30sXG4gICAgaW52aXNpYmxlOiB7fVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhPZkxhc3RJdGVtKGRyYWdnYWJsZXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFkcmFnZ2FibGVzLmxlbmd0aCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGluZGV4T2ZMYXN0SXRlbSA9IGRyYWdnYWJsZXNbZHJhZ2dhYmxlcy5sZW5ndGggLSAxXS5kZXNjcmlwdG9yLmluZGV4O1xuICByZXR1cm4gb3B0aW9ucy5pbkhvbWVMaXN0ID8gaW5kZXhPZkxhc3RJdGVtIDogaW5kZXhPZkxhc3RJdGVtICsgMTtcbn1cblxuZnVuY3Rpb24gZ29BdEVuZChfcmVmKSB7XG4gIHZhciBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0ID0gX3JlZi5pbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnkgPSBfcmVmLmRpc3BsYWNlZEJ5LFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uO1xuICB2YXIgbmV3SW5kZXggPSBnZXRJbmRleE9mTGFzdEl0ZW0oaW5zaWRlRGVzdGluYXRpb24sIHtcbiAgICBpbkhvbWVMaXN0OiBpbkhvbWVMaXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KF9yZWYyKSB7XG4gIHZhciBkcmFnZ2FibGUgPSBfcmVmMi5kcmFnZ2FibGUsXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYyLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmMi5kZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0ID0gX3JlZjIudmlld3BvcnQsXG4gICAgICBkaXNwbGFjZWRCeSA9IF9yZWYyLmRpc3BsYWNlZEJ5LFxuICAgICAgbGFzdCA9IF9yZWYyLmxhc3QsXG4gICAgICBpbmRleCA9IF9yZWYyLmluZGV4LFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlID0gX3JlZjIuZm9yY2VTaG91bGRBbmltYXRlO1xuICB2YXIgaW5Ib21lTGlzdCA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pO1xuXG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgaW5Ib21lTGlzdDogaW5Ib21lTGlzdCxcbiAgICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gZmluZChpbnNpZGVEZXN0aW5hdGlvbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5kZXNjcmlwdG9yLmluZGV4ID09PSBpbmRleDtcbiAgfSk7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBnb0F0RW5kKHtcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3Q6IGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgdmFyIHNsaWNlRnJvbSA9IGluc2lkZURlc3RpbmF0aW9uLmluZGV4T2YobWF0Y2gpO1xuICB2YXIgaW1wYWN0ZWQgPSB3aXRob3V0RHJhZ2dpbmcuc2xpY2Uoc2xpY2VGcm9tKTtcbiAgdmFyIGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogaW1wYWN0ZWQsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBsYXN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZvcmNlU2hvdWxkQW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGFjZWQ6IGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGVJZCwgYWZ0ZXJDcml0aWNhbCkge1xuICByZXR1cm4gQm9vbGVhbihhZnRlckNyaXRpY2FsLmVmZmVjdGVkW2RyYWdnYWJsZUlkXSk7XG59XG5cbnZhciBmcm9tQ29tYmluZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gX3JlZi5pc01vdmluZ0ZvcndhcmQsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgY29tYmluZSA9IF9yZWYuY29tYmluZSxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG5cbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY29tYmluZUlkID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgdmFyIGNvbWJpbmVXaXRoID0gZHJhZ2dhYmxlc1tjb21iaW5lSWRdO1xuICB2YXIgY29tYmluZVdpdGhJbmRleCA9IGNvbWJpbmVXaXRoLmRlc2NyaXB0b3IuaW5kZXg7XG4gIHZhciBkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lSWQsIGFmdGVyQ3JpdGljYWwpO1xuXG4gIGlmIChkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCkge1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4IC0gMTtcbiAgfVxuXG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleCArIDE7XG4gIH1cblxuICByZXR1cm4gY29tYmluZVdpdGhJbmRleDtcbn0pO1xuXG52YXIgZnJvbVJlb3JkZXIgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IF9yZWYuaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgaXNJbkhvbWVMaXN0ID0gX3JlZi5pc0luSG9tZUxpc3QsXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb247XG5cbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjdXJyZW50SW5kZXggPSBsb2NhdGlvbi5pbmRleDtcbiAgdmFyIHByb3Bvc2VkSW5kZXggPSBpc01vdmluZ0ZvcndhcmQgPyBjdXJyZW50SW5kZXggKyAxIDogY3VycmVudEluZGV4IC0gMTtcbiAgdmFyIGZpcnN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvblswXS5kZXNjcmlwdG9yLmluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgdmFyIHVwcGVyQm91bmQgPSBpc0luSG9tZUxpc3QgPyBsYXN0SW5kZXggOiBsYXN0SW5kZXggKyAxO1xuXG4gIGlmIChwcm9wb3NlZEluZGV4IDwgZmlyc3RJbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb3Bvc2VkSW5kZXggPiB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJvcG9zZWRJbmRleDtcbn0pO1xuXG52YXIgbW92ZVRvTmV4dEluZGV4ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBfcmVmLmlzTW92aW5nRm9yd2FyZCxcbiAgICAgIGlzSW5Ib21lTGlzdCA9IF9yZWYuaXNJbkhvbWVMaXN0LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgcHJldmlvdXNJbXBhY3QgPSBfcmVmLnByZXZpb3VzSW1wYWN0LFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIHdhc0F0ID0gcHJldmlvdXNJbXBhY3QuYXQ7XG4gICF3YXNBdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBtb3ZlIGluIGRpcmVjdGlvbiB3aXRob3V0IHByZXZpb3VzIGltcGFjdCBsb2NhdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICBpZiAod2FzQXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgdmFyIF9uZXdJbmRleCA9IGZyb21SZW9yZGVyKHtcbiAgICAgIGlzTW92aW5nRm9yd2FyZDogaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgaXNJbkhvbWVMaXN0OiBpc0luSG9tZUxpc3QsXG4gICAgICBsb2NhdGlvbjogd2FzQXQuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb25cbiAgICB9KTtcblxuICAgIGlmIChfbmV3SW5kZXggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBsYXN0OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgICBkaXNwbGFjZWRCeTogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgICBpbmRleDogX25ld0luZGV4XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbmV3SW5kZXggPSBmcm9tQ29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkOiBpc01vdmluZ0ZvcndhcmQsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgY29tYmluZTogd2FzQXQuY29tYmluZSxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuXG4gIGlmIChuZXdJbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59KTtcblxudmFyIGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZGlzcGxhY2VkID0gX3JlZi5kaXNwbGFjZWQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsLFxuICAgICAgY29tYmluZVdpdGggPSBfcmVmLmNvbWJpbmVXaXRoLFxuICAgICAgZGlzcGxhY2VkQnkgPSBfcmVmLmRpc3BsYWNlZEJ5O1xuICB2YXIgaXNEaXNwbGFjZWQgPSBCb29sZWFuKGRpc3BsYWNlZC52aXNpYmxlW2NvbWJpbmVXaXRoXSB8fCBkaXNwbGFjZWQuaW52aXNpYmxlW2NvbWJpbmVXaXRoXSk7XG5cbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lV2l0aCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICByZXR1cm4gaXNEaXNwbGFjZWQgPyBvcmlnaW4gOiBuZWdhdGUoZGlzcGxhY2VkQnkucG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIGlzRGlzcGxhY2VkID8gZGlzcGxhY2VkQnkucG9pbnQgOiBvcmlnaW47XG59KTtcblxudmFyIHdoZW5Db21iaW5pbmcgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWwsXG4gICAgICBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXM7XG4gIHZhciBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAhY29tYmluZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgY29tYmluZVdpdGggPSBjb21iaW5lLmRyYWdnYWJsZUlkO1xuICB2YXIgY2VudGVyID0gZHJhZ2dhYmxlc1tjb21iaW5lV2l0aF0ucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICB2YXIgZGlzcGxhY2VCeSA9IGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCh7XG4gICAgZGlzcGxhY2VkOiBpbXBhY3QuZGlzcGxhY2VkLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWwsXG4gICAgY29tYmluZVdpdGg6IGNvbWJpbmVXaXRoLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnlcbiAgfSk7XG4gIHJldHVybiBhZGQoY2VudGVyLCBkaXNwbGFjZUJ5KTtcbn0pO1xuXG52YXIgZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlciA9IGZ1bmN0aW9uIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgYm94KSB7XG4gIHJldHVybiBib3gubWFyZ2luW2F4aXMuc3RhcnRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbn07XG5cbnZhciBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciA9IGZ1bmN0aW9uIGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGJveCkge1xuICByZXR1cm4gYm94Lm1hcmdpbltheGlzLmVuZF0gKyBib3guYm9yZGVyQm94W2F4aXMuc2l6ZV0gLyAyO1xufTtcblxudmFyIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciA9IGZ1bmN0aW9uIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCB0YXJnZXQsIGlzTW92aW5nKSB7XG4gIHJldHVybiB0YXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5tYXJnaW5bYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5ib3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNTaXplXSAvIDI7XG59O1xuXG52YXIgZ29BZnRlciA9IGZ1bmN0aW9uIGdvQWZ0ZXIoX3JlZikge1xuICB2YXIgYXhpcyA9IF9yZWYuYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvID0gX3JlZi5tb3ZlUmVsYXRpdmVUbyxcbiAgICAgIGlzTW92aW5nID0gX3JlZi5pc01vdmluZztcbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuZW5kXSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xufTtcbnZhciBnb0JlZm9yZSA9IGZ1bmN0aW9uIGdvQmVmb3JlKF9yZWYyKSB7XG4gIHZhciBheGlzID0gX3JlZjIuYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvID0gX3JlZjIubW92ZVJlbGF0aXZlVG8sXG4gICAgICBpc01vdmluZyA9IF9yZWYyLmlzTW92aW5nO1xuICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3hbYXhpcy5zdGFydF0gLSBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlcihheGlzLCBpc01vdmluZyksIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3gsIGlzTW92aW5nKSk7XG59O1xudmFyIGdvSW50b1N0YXJ0ID0gZnVuY3Rpb24gZ29JbnRvU3RhcnQoX3JlZjMpIHtcbiAgdmFyIGF4aXMgPSBfcmVmMy5heGlzLFxuICAgICAgbW92ZUludG8gPSBfcmVmMy5tb3ZlSW50byxcbiAgICAgIGlzTW92aW5nID0gX3JlZjMuaXNNb3Zpbmc7XG4gIHJldHVybiBwYXRjaChheGlzLmxpbmUsIG1vdmVJbnRvLmNvbnRlbnRCb3hbYXhpcy5zdGFydF0gKyBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVJbnRvLmNvbnRlbnRCb3gsIGlzTW92aW5nKSk7XG59O1xuXG52YXIgd2hlblJlb3JkZXJpbmcgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlID0gX3JlZi5kcm9wcGFibGUsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgdmFyIGRyYWdnYWJsZVBhZ2UgPSBkcmFnZ2FibGUucGFnZTtcbiAgdmFyIGF4aXMgPSBkcm9wcGFibGUuYXhpcztcblxuICBpZiAoIWluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgIHJldHVybiBnb0ludG9TdGFydCh7XG4gICAgICBheGlzOiBheGlzLFxuICAgICAgbW92ZUludG86IGRyb3BwYWJsZS5wYWdlLFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkaXNwbGFjZWQgPSBpbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgZGlzcGxhY2VkQnkgPSBpbXBhY3QuZGlzcGxhY2VkQnk7XG4gIHZhciBjbG9zZXN0QWZ0ZXIgPSBkaXNwbGFjZWQuYWxsWzBdO1xuXG4gIGlmIChjbG9zZXN0QWZ0ZXIpIHtcbiAgICB2YXIgY2xvc2VzdCA9IGRyYWdnYWJsZXNbY2xvc2VzdEFmdGVyXTtcblxuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwoY2xvc2VzdEFmdGVyLCBhZnRlckNyaXRpY2FsKSkge1xuICAgICAgcmV0dXJuIGdvQmVmb3JlKHtcbiAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgbW92ZVJlbGF0aXZlVG86IGNsb3Nlc3QucGFnZSxcbiAgICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB3aXRoRGlzcGxhY2VtZW50ID0gb2Zmc2V0KGNsb3Nlc3QucGFnZSwgZGlzcGxhY2VkQnkucG9pbnQpO1xuICAgIHJldHVybiBnb0JlZm9yZSh7XG4gICAgICBheGlzOiBheGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG86IHdpdGhEaXNwbGFjZW1lbnQsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGxhc3QgPSBpbnNpZGVEZXN0aW5hdGlvbltpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggLSAxXTtcblxuICBpZiAobGFzdC5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgIHJldHVybiBkcmFnZ2FibGVQYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIH1cblxuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGxhc3QuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICB2YXIgcGFnZSA9IG9mZnNldChsYXN0LnBhZ2UsIG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSk7XG4gICAgcmV0dXJuIGdvQWZ0ZXIoe1xuICAgICAgYXhpczogYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiBwYWdlLFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBnb0FmdGVyKHtcbiAgICBheGlzOiBheGlzLFxuICAgIG1vdmVSZWxhdGl2ZVRvOiBsYXN0LnBhZ2UsXG4gICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgfSk7XG59KTtcblxudmFyIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPSAoZnVuY3Rpb24gKGRyb3BwYWJsZSwgcG9pbnQpIHtcbiAgdmFyIGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuXG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICByZXR1cm4gYWRkKHBvaW50LCBmcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQpO1xufSk7XG5cbnZhciBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gZnVuY3Rpb24gZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudChfcmVmKSB7XG4gIHZhciBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlID0gX3JlZi5kcm9wcGFibGUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgdmFyIGF0ID0gaW1wYWN0LmF0O1xuXG4gIGlmICghZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG5cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuXG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gd2hlblJlb3JkZXJpbmcoe1xuICAgICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGU6IGRyb3BwYWJsZSxcbiAgICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB3aGVuQ29tYmluaW5nKHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xuXG52YXIgZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3QgPSAoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgdmFyIHdpdGhvdXREaXNwbGFjZW1lbnQgPSBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50KGFyZ3MpO1xuICB2YXIgZHJvcHBhYmxlID0gYXJncy5kcm9wcGFibGU7XG4gIHZhciB3aXRoRGlzcGxhY2VtZW50ID0gZHJvcHBhYmxlID8gd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkcm9wcGFibGUsIHdpdGhvdXREaXNwbGFjZW1lbnQpIDogd2l0aG91dERpc3BsYWNlbWVudDtcbiAgcmV0dXJuIHdpdGhEaXNwbGFjZW1lbnQ7XG59KTtcblxudmFyIHNjcm9sbFZpZXdwb3J0ID0gKGZ1bmN0aW9uICh2aWV3cG9ydCwgbmV3U2Nyb2xsKSB7XG4gIHZhciBkaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCk7XG4gIHZhciBkaXNwbGFjZW1lbnQgPSBuZWdhdGUoZGlmZik7XG4gIHZhciBmcmFtZSA9IGdldFJlY3Qoe1xuICAgIHRvcDogbmV3U2Nyb2xsLnksXG4gICAgYm90dG9tOiBuZXdTY3JvbGwueSArIHZpZXdwb3J0LmZyYW1lLmhlaWdodCxcbiAgICBsZWZ0OiBuZXdTY3JvbGwueCxcbiAgICByaWdodDogbmV3U2Nyb2xsLnggKyB2aWV3cG9ydC5mcmFtZS53aWR0aFxuICB9KTtcbiAgdmFyIHVwZGF0ZWQgPSB7XG4gICAgZnJhbWU6IGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwsXG4gICAgICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gICAgICBjdXJyZW50OiBuZXdTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBkaWZmLFxuICAgICAgICBkaXNwbGFjZW1lbnQ6IGRpc3BsYWNlbWVudFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZWQ7XG59KTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlcyhpZHMsIGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGRyYWdnYWJsZXNbaWRdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJ5R2V0VmlzaWJsZShpZCwgZ3JvdXBzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3BsYWNlbWVudCA9IGdyb3Vwc1tpXS52aXNpYmxlW2lkXTtcblxuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBzcGVjdWxhdGl2ZWx5SW5jcmVhc2UgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIG1heFNjcm9sbENoYW5nZSA9IF9yZWYubWF4U2Nyb2xsQ2hhbmdlO1xuICB2YXIgc2Nyb2xsZWRWaWV3cG9ydCA9IHNjcm9sbFZpZXdwb3J0KHZpZXdwb3J0LCBhZGQodmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsIG1heFNjcm9sbENoYW5nZSkpO1xuICB2YXIgc2Nyb2xsZWREcm9wcGFibGUgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IHNjcm9sbERyb3BwYWJsZShkZXN0aW5hdGlvbiwgYWRkKGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKSA6IGRlc3RpbmF0aW9uO1xuICB2YXIgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIHZhciB3aXRoVmlld3BvcnRTY3JvbGwgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGdldERyYWdnYWJsZXMobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiBzY3JvbGxlZFZpZXdwb3J0LmZyYW1lLFxuICAgIGxhc3Q6IGxhc3QsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgdmFyIHdpdGhEcm9wcGFibGVTY3JvbGwgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGdldERyYWdnYWJsZXMobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uOiBzY3JvbGxlZERyb3BwYWJsZSxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0OiBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIHZhciBpbnZpc2libGUgPSB7fTtcbiAgdmFyIHZpc2libGUgPSB7fTtcbiAgdmFyIGdyb3VwcyA9IFtsYXN0LCB3aXRoVmlld3BvcnRTY3JvbGwsIHdpdGhEcm9wcGFibGVTY3JvbGxdO1xuICBsYXN0LmFsbC5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBkaXNwbGFjZW1lbnQgPSB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpO1xuXG4gICAgaWYgKGRpc3BsYWNlbWVudCkge1xuICAgICAgdmlzaWJsZVtpZF0gPSBkaXNwbGFjZW1lbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52aXNpYmxlW2lkXSA9IHRydWU7XG4gIH0pO1xuXG4gIHZhciBuZXdJbXBhY3QgPSBfZXh0ZW5kcyh7fSwgaW1wYWN0LCB7XG4gICAgZGlzcGxhY2VkOiB7XG4gICAgICBhbGw6IGxhc3QuYWxsLFxuICAgICAgaW52aXNpYmxlOiBpbnZpc2libGUsXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmV3SW1wYWN0O1xufSk7XG5cbnZhciB3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQgPSAoZnVuY3Rpb24gKHZpZXdwb3J0LCBwb2ludCkge1xuICByZXR1cm4gYWRkKHZpZXdwb3J0LnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCwgcG9pbnQpO1xufSk7XG5cbnZhciBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcGFnZUJvcmRlckJveENlbnRlciA9IF9yZWYucGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0O1xuICB2YXIgd2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UgPSB3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQodmlld3BvcnQsIHBhZ2VCb3JkZXJCb3hDZW50ZXIpO1xuICB2YXIgb2Zmc2V0ID0gc3VidHJhY3Qod2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gYWRkKGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlciwgb2Zmc2V0KTtcbn0pO1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24gPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgbmV3UGFnZUJvcmRlckJveENlbnRlciA9IF9yZWYubmV3UGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPSBfcmVmLndpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gICAgICBfcmVmJG9ubHlPbk1haW5BeGlzID0gX3JlZi5vbmx5T25NYWluQXhpcyxcbiAgICAgIG9ubHlPbk1haW5BeGlzID0gX3JlZiRvbmx5T25NYWluQXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJG9ubHlPbk1haW5BeGlzO1xuICB2YXIgY2hhbmdlTmVlZGVkID0gc3VidHJhY3QobmV3UGFnZUJvcmRlckJveENlbnRlciwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIHZhciBzaGlmdGVkID0gb2Zmc2V0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIGNoYW5nZU5lZWRlZCk7XG4gIHZhciBhcmdzID0ge1xuICAgIHRhcmdldDogc2hpZnRlZCxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIG9ubHlPbk1haW5BeGlzID8gaXNUb3RhbGx5VmlzaWJsZU9uQXhpcyhhcmdzKSA6IGlzVG90YWxseVZpc2libGUoYXJncyk7XG59KTtcblxudmFyIG1vdmVUb05leHRQbGFjZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gX3JlZi5pc01vdmluZ0ZvcndhcmQsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBwcmV2aW91c0ltcGFjdCA9IF9yZWYucHJldmlvdXNJbXBhY3QsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIgPSBfcmVmLnByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uID0gX3JlZi5wcmV2aW91c0NsaWVudFNlbGVjdGlvbixcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG5cbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIHZhciBpc0luSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcbiAgdmFyIGltcGFjdCA9IG1vdmVUb05leHRDb21iaW5lKHtcbiAgICBpc01vdmluZ0ZvcndhcmQ6IGlzTW92aW5nRm9yd2FyZCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0OiBwcmV2aW91c0ltcGFjdFxuICB9KSB8fCBtb3ZlVG9OZXh0SW5kZXgoe1xuICAgIGlzTW92aW5nRm9yd2FyZDogaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGlzSW5Ib21lTGlzdDogaXNJbkhvbWVMaXN0LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdDogcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG5cbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICB2YXIgaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA9IGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uKHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcGFnZUJvcmRlckJveENlbnRlcixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgb25seU9uTWFpbkF4aXM6IHRydWVcbiAgfSk7XG5cbiAgaWYgKGlzVmlzaWJsZUluTmV3TG9jYXRpb24pIHtcbiAgICB2YXIgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgICAgcGFnZUJvcmRlckJveENlbnRlcjogcGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudFNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICAgIH07XG4gIH1cblxuICB2YXIgZGlzdGFuY2UgPSBzdWJ0cmFjdChwYWdlQm9yZGVyQm94Q2VudGVyLCBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIpO1xuICB2YXIgY2F1dGlvdXMgPSBzcGVjdWxhdGl2ZWx5SW5jcmVhc2Uoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBtYXhTY3JvbGxDaGFuZ2U6IGRpc3RhbmNlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFNlbGVjdGlvbjogcHJldmlvdXNDbGllbnRTZWxlY3Rpb24sXG4gICAgaW1wYWN0OiBjYXV0aW91cyxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogZGlzdGFuY2VcbiAgfTtcbn0pO1xuXG52YXIgZ2V0S25vd25BY3RpdmUgPSBmdW5jdGlvbiBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpIHtcbiAgdmFyIHJlY3QgPSBkcm9wcGFibGUuc3ViamVjdC5hY3RpdmU7XG4gICFyZWN0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBjbGlwcGVkIGFyZWEgZnJvbSBkcm9wcGFibGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByZWN0O1xufTtcblxudmFyIGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IF9yZWYuaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgcGFnZUJvcmRlckJveENlbnRlciA9IF9yZWYucGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgZHJvcHBhYmxlcyA9IF9yZWYuZHJvcHBhYmxlcyxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydDtcbiAgdmFyIGFjdGl2ZSA9IHNvdXJjZS5zdWJqZWN0LmFjdGl2ZTtcblxuICBpZiAoIWFjdGl2ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGF4aXMgPSBzb3VyY2UuYXhpcztcbiAgdmFyIGlzQmV0d2VlblNvdXJjZUNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5zdGFydF0sIGFjdGl2ZVtheGlzLmVuZF0pO1xuICB2YXIgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgIHJldHVybiBkcm9wcGFibGUgIT09IHNvdXJjZTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlLmlzRW5hYmxlZDtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gQm9vbGVhbihkcm9wcGFibGUuc3ViamVjdC5hY3RpdmUpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgIHJldHVybiBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUodmlld3BvcnQuZnJhbWUpKGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSkpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgIHZhciBhY3RpdmVPZlRhcmdldCA9IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSk7XG5cbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gYWN0aXZlW2F4aXMuY3Jvc3NBeGlzRW5kXSA8IGFjdGl2ZU9mVGFyZ2V0W2F4aXMuY3Jvc3NBeGlzRW5kXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gPCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgdmFyIGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcbiAgICB2YXIgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkID0gaXNXaXRoaW4oYWN0aXZlT2ZUYXJnZXRbYXhpcy5zdGFydF0sIGFjdGl2ZU9mVGFyZ2V0W2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzQmV0d2VlblNvdXJjZUNsaXBwZWQoYWN0aXZlT2ZUYXJnZXRbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlblNvdXJjZUNsaXBwZWQoYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKSB8fCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQoYWN0aXZlW2F4aXMuc3RhcnRdKSB8fCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQoYWN0aXZlW2F4aXMuZW5kXSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgZmlyc3QgPSBnZXRLbm93bkFjdGl2ZShhKVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgICB2YXIgc2Vjb25kID0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5jcm9zc0F4aXNTdGFydF07XG5cbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gZmlyc3QgLSBzZWNvbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY29uZCAtIGZpcnN0O1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSwgaW5kZXgsIGFycmF5KSB7XG4gICAgcmV0dXJuIGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5jcm9zc0F4aXNTdGFydF0gPT09IGdldEtub3duQWN0aXZlKGFycmF5WzBdKVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgfSk7XG5cbiAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF07XG4gIH1cblxuICB2YXIgY29udGFpbnMgPSBjYW5kaWRhdGVzLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgdmFyIGlzV2l0aGluRHJvcHBhYmxlID0gaXNXaXRoaW4oZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLnN0YXJ0XSwgZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLmVuZF0pO1xuICAgIHJldHVybiBpc1dpdGhpbkRyb3BwYWJsZShwYWdlQm9yZGVyQm94Q2VudGVyW2F4aXMubGluZV0pO1xuICB9KTtcblxuICBpZiAoY29udGFpbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWzBdO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5zLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gY29udGFpbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF07XG4gICAgfSlbMF07XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGZpcnN0ID0gY2xvc2VzdChwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGEpKSk7XG4gICAgdmFyIHNlY29uZCA9IGNsb3Nlc3QocGFnZUJvcmRlckJveENlbnRlciwgZ2V0Q29ybmVycyhnZXRLbm93bkFjdGl2ZShiKSkpO1xuXG4gICAgaWYgKGZpcnN0ICE9PSBzZWNvbmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XTtcbiAgfSlbMF07XG59KTtcblxudmFyIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSB7XG4gIHZhciBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIHJldHVybiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpID8gc3VidHJhY3Qob3JpZ2luYWwsIGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpIDogb3JpZ2luYWw7XG59O1xudmFyIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94ID0gZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3goZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSB7XG4gIHZhciBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveDtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBvZmZzZXRCeVBvc2l0aW9uKG9yaWdpbmFsLCBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkpIDogb3JpZ2luYWw7XG59O1xuXG52YXIgZ2V0Q2xvc2VzdERyYWdnYWJsZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcGFnZUJvcmRlckJveENlbnRlciA9IF9yZWYucGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBzb3J0ZWQgPSBpbnNpZGVEZXN0aW5hdGlvbi5maWx0ZXIoZnVuY3Rpb24gKGRyYWdnYWJsZSkge1xuICAgIHJldHVybiBpc1RvdGFsbHlWaXNpYmxlKHtcbiAgICAgIHRhcmdldDogZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3goZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSxcbiAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBkaXN0YW5jZVRvQSA9IGRpc3RhbmNlKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZGVzdGluYXRpb24sIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGEsIGFmdGVyQ3JpdGljYWwpKSk7XG4gICAgdmFyIGRpc3RhbmNlVG9CID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYiwgYWZ0ZXJDcml0aWNhbCkpKTtcblxuICAgIGlmIChkaXN0YW5jZVRvQSA8IGRpc3RhbmNlVG9CKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKGRpc3RhbmNlVG9CIDwgZGlzdGFuY2VUb0EpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXg7XG4gIH0pO1xuICByZXR1cm4gc29ydGVkWzBdIHx8IG51bGw7XG59KTtcblxudmFyIGdldERpc3BsYWNlZEJ5ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiBnZXREaXNwbGFjZWRCeShheGlzLCBkaXNwbGFjZUJ5KSB7XG4gIHZhciBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZUJ5W2F4aXMubGluZV07XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGRpc3BsYWNlbWVudCxcbiAgICBwb2ludDogcGF0Y2goYXhpcy5saW5lLCBkaXNwbGFjZW1lbnQpXG4gIH07XG59KTtcblxudmFyIGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiBnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgcGxhY2Vob2xkZXJTaXplLCBkcmFnZ2FibGVzKSB7XG4gIHZhciBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG5cbiAgaWYgKGRyb3BwYWJsZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJykge1xuICAgIHJldHVybiBwYXRjaChheGlzLmxpbmUsIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdKTtcbiAgfVxuXG4gIHZhciBhdmFpbGFibGVTcGFjZSA9IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UuY29udGVudEJveFtheGlzLnNpemVdO1xuICB2YXIgaW5zaWRlRHJvcHBhYmxlID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIHZhciBzcGFjZVVzZWQgPSBpbnNpZGVEcm9wcGFibGUucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGRpbWVuc2lvbikge1xuICAgIHJldHVybiBzdW0gKyBkaW1lbnNpb24uY2xpZW50Lm1hcmdpbkJveFtheGlzLnNpemVdO1xuICB9LCAwKTtcbiAgdmFyIHJlcXVpcmVkU3BhY2UgPSBzcGFjZVVzZWQgKyBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXTtcbiAgdmFyIG5lZWRzVG9Hcm93QnkgPSByZXF1aXJlZFNwYWNlIC0gYXZhaWxhYmxlU3BhY2U7XG5cbiAgaWYgKG5lZWRzVG9Hcm93QnkgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbmVlZHNUb0dyb3dCeSk7XG59O1xuXG52YXIgd2l0aE1heFNjcm9sbCA9IGZ1bmN0aW9uIHdpdGhNYXhTY3JvbGwoZnJhbWUsIG1heCkge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGZyYW1lLCB7XG4gICAgc2Nyb2xsOiBfZXh0ZW5kcyh7fSwgZnJhbWUuc2Nyb2xsLCB7XG4gICAgICBtYXg6IG1heFxuICAgIH0pXG4gIH0pO1xufTtcblxudmFyIGFkZFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gYWRkUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpIHtcbiAgdmFyIGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhIWlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBub3QgYWRkIHBsYWNlaG9sZGVyIHNwYWNlIHRvIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISFkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYWRkIHBsYWNlaG9sZGVyIHNpemUgdG8gYSBzdWJqZWN0IHdoZW4gaXQgYWxyZWFkeSBoYXMgb25lJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgcGxhY2Vob2xkZXJTaXplID0gZ2V0RGlzcGxhY2VkQnkoZHJvcHBhYmxlLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KS5wb2ludDtcbiAgdmFyIHJlcXVpcmVkR3Jvd3RoID0gZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlcihkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcyk7XG4gIHZhciBhZGRlZCA9IHtcbiAgICBwbGFjZWhvbGRlclNpemU6IHBsYWNlaG9sZGVyU2l6ZSxcbiAgICBpbmNyZWFzZWRCeTogcmVxdWlyZWRHcm93dGgsXG4gICAgb2xkRnJhbWVNYXhTY3JvbGw6IGRyb3BwYWJsZS5mcmFtZSA/IGRyb3BwYWJsZS5mcmFtZS5zY3JvbGwubWF4IDogbnVsbFxuICB9O1xuXG4gIGlmICghZnJhbWUpIHtcbiAgICB2YXIgX3N1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogZHJvcHBhYmxlLmZyYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRyb3BwYWJsZSwge1xuICAgICAgc3ViamVjdDogX3N1YmplY3RcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBtYXhTY3JvbGwgPSByZXF1aXJlZEdyb3d0aCA/IGFkZChmcmFtZS5zY3JvbGwubWF4LCByZXF1aXJlZEdyb3d0aCkgOiBmcmFtZS5zY3JvbGwubWF4O1xuICB2YXIgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBtYXhTY3JvbGwpO1xuICB2YXIgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBhZGRlZCxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfSk7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZHJvcHBhYmxlLCB7XG4gICAgc3ViamVjdDogc3ViamVjdCxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfSk7XG59O1xudmFyIHJlbW92ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gcmVtb3ZlUGxhY2Vob2xkZXIoZHJvcHBhYmxlKSB7XG4gIHZhciBhZGRlZCA9IGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcjtcbiAgIWFkZGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbW92ZSBwbGFjZWhvbGRlciBmb3JtIHN1YmplY3Qgd2hlbiB0aGVyZSB3YXMgbm9uZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuXG4gIGlmICghZnJhbWUpIHtcbiAgICB2YXIgX3N1YmplY3QyID0gZ2V0U3ViamVjdCh7XG4gICAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogbnVsbCxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkcm9wcGFibGUsIHtcbiAgICAgIHN1YmplY3Q6IF9zdWJqZWN0MlxuICAgIH0pO1xuICB9XG5cbiAgdmFyIG9sZE1heFNjcm9sbCA9IGFkZGVkLm9sZEZyYW1lTWF4U2Nyb2xsO1xuICAhb2xkTWF4U2Nyb2xsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZHJvcHBhYmxlIHdpdGggZnJhbWUgdG8gaGF2ZSBvbGQgbWF4IGZyYW1lIHNjcm9sbCB3aGVuIHJlbW92aW5nIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBvbGRNYXhTY3JvbGwpO1xuICB2YXIgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWU6IG5ld0ZyYW1lLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICB9KTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkcm9wcGFibGUsIHtcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9KTtcbn07XG5cbnZhciBtb3ZlVG9OZXdEcm9wcGFibGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciA9IF9yZWYucHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgbW92ZVJlbGF0aXZlVG8gPSBfcmVmLm1vdmVSZWxhdGl2ZVRvLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcblxuICBpZiAoIW1vdmVSZWxhdGl2ZVRvKSB7XG4gICAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByb3Bvc2VkID0ge1xuICAgICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICAgIGRpc3BsYWNlZEJ5OiBub0Rpc3BsYWNlZEJ5LFxuICAgICAgYXQ6IHtcbiAgICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgICBpbXBhY3Q6IHByb3Bvc2VkLFxuICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgICB9KTtcbiAgICB2YXIgd2l0aFBsYWNlaG9sZGVyID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPyBkZXN0aW5hdGlvbiA6IGFkZFBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICAgIHZhciBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID0gaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24oe1xuICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbjogd2l0aFBsYWNlaG9sZGVyLFxuICAgICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID8gcHJvcG9zZWQgOiBudWxsO1xuICB9XG5cbiAgdmFyIGlzR29pbmdCZWZvcmVUYXJnZXQgPSBCb29sZWFuKHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdIDw9IG1vdmVSZWxhdGl2ZVRvLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdKTtcblxuICB2YXIgcHJvcG9zZWRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVsYXRpdmVUbyA9IG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaW5kZXg7XG5cbiAgICBpZiAobW92ZVJlbGF0aXZlVG8uZGVzY3JpcHRvci5pZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cblxuICAgIGlmIChpc0dvaW5nQmVmb3JlVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVsYXRpdmVUbyArIDE7XG4gIH0oKTtcblxuICB2YXIgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgbGFzdDogZW1wdHlHcm91cHMsXG4gICAgaW5kZXg6IHByb3Bvc2VkSW5kZXhcbiAgfSk7XG59KTtcblxudmFyIG1vdmVDcm9zc0F4aXMgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IF9yZWYuaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gX3JlZi5wcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGlzT3ZlciA9IF9yZWYuaXNPdmVyLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmLmRyb3BwYWJsZXMsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgZGVzdGluYXRpb24gPSBnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlKHtcbiAgICBpc01vdmluZ0ZvcndhcmQ6IGlzTW92aW5nRm9yd2FyZCxcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgc291cmNlOiBpc092ZXIsXG4gICAgZHJvcHBhYmxlczogZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgfSk7XG5cbiAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgdmFyIG1vdmVSZWxhdGl2ZVRvID0gZ2V0Q2xvc2VzdERyYWdnYWJsZSh7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHZhciBpbXBhY3QgPSBtb3ZlVG9OZXdEcm9wcGFibGUoe1xuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIG1vdmVSZWxhdGl2ZVRvOiBtb3ZlUmVsYXRpdmVUbyxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG5cbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICB2YXIgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gIH07XG59KTtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyID0gKGZ1bmN0aW9uIChpbXBhY3QpIHtcbiAgdmFyIGF0ID0gaW1wYWN0LmF0O1xuXG4gIGlmICghYXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gYXQuZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cblxuICByZXR1cm4gYXQuY29tYmluZS5kcm9wcGFibGVJZDtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlT3ZlciA9IGZ1bmN0aW9uIGdldERyb3BwYWJsZU92ZXIoaW1wYWN0LCBkcm9wcGFibGVzKSB7XG4gIHZhciBpZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIHJldHVybiBpZCA/IGRyb3BwYWJsZXNbaWRdIDogbnVsbDtcbn07XG5cbnZhciBtb3ZlSW5EaXJlY3Rpb24gPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG4gIHZhciBpc0FjdHVhbGx5T3ZlciA9IGdldERyb3BwYWJsZU92ZXIoc3RhdGUuaW1wYWN0LCBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXMpO1xuICB2YXIgaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCA9IEJvb2xlYW4oaXNBY3R1YWxseU92ZXIpO1xuICB2YXIgaG9tZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICB2YXIgaXNPdmVyID0gaXNBY3R1YWxseU92ZXIgfHwgaG9tZTtcbiAgdmFyIGRpcmVjdGlvbiA9IGlzT3Zlci5heGlzLmRpcmVjdGlvbjtcbiAgdmFyIGlzTW92aW5nT25NYWluQXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiAodHlwZSA9PT0gJ01PVkVfVVAnIHx8IHR5cGUgPT09ICdNT1ZFX0RPV04nKSB8fCBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAodHlwZSA9PT0gJ01PVkVfTEVGVCcgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnKTtcblxuICBpZiAoaXNNb3ZpbmdPbk1haW5BeGlzICYmICFpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gdHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnO1xuICB2YXIgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIHZhciBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIgPSBzdGF0ZS5jdXJyZW50LnBhZ2UuYm9yZGVyQm94Q2VudGVyO1xuICB2YXIgX3N0YXRlJGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9zdGF0ZSRkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzID0gX3N0YXRlJGRpbWVuc2lvbnMuZHJvcHBhYmxlcztcbiAgcmV0dXJuIGlzTW92aW5nT25NYWluQXhpcyA/IG1vdmVUb05leHRQbGFjZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkOiBpc01vdmluZ0ZvcndhcmQsXG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbjogc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KSA6IG1vdmVDcm9zc0F4aXMoe1xuICAgIGlzTW92aW5nRm9yd2FyZDogaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGlzT3ZlcjogaXNPdmVyLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJztcbn1cblxuZnVuY3Rpb24gaXNQb3NpdGlvbkluRnJhbWUoZnJhbWUpIHtcbiAgdmFyIGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIHZhciBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBmdW5jdGlvbiBydW4ocG9pbnQpIHtcbiAgICByZXR1cm4gaXNXaXRoaW5WZXJ0aWNhbChwb2ludC55KSAmJiBpc1dpdGhpbkhvcml6b250YWwocG9pbnQueCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEhhc092ZXJsYXAoZmlyc3QsIHNlY29uZCkge1xuICByZXR1cm4gZmlyc3QubGVmdCA8IHNlY29uZC5yaWdodCAmJiBmaXJzdC5yaWdodCA+IHNlY29uZC5sZWZ0ICYmIGZpcnN0LnRvcCA8IHNlY29uZC5ib3R0b20gJiYgZmlyc3QuYm90dG9tID4gc2Vjb25kLnRvcDtcbn1cblxuZnVuY3Rpb24gZ2V0RnVydGhlc3RBd2F5KF9yZWYpIHtcbiAgdmFyIHBhZ2VCb3JkZXJCb3ggPSBfcmVmLnBhZ2VCb3JkZXJCb3gsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGNhbmRpZGF0ZXMgPSBfcmVmLmNhbmRpZGF0ZXM7XG4gIHZhciBzdGFydENlbnRlciA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIHZhciBzb3J0ZWQgPSBjYW5kaWRhdGVzLm1hcChmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgdmFyIGF4aXMgPSBjYW5kaWRhdGUuYXhpcztcbiAgICB2YXIgdGFyZ2V0ID0gcGF0Y2goY2FuZGlkYXRlLmF4aXMubGluZSwgcGFnZUJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXSwgY2FuZGlkYXRlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNhbmRpZGF0ZS5kZXNjcmlwdG9yLmlkLFxuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKHN0YXJ0Q2VudGVyLCB0YXJnZXQpXG4gICAgfTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmRpc3RhbmNlIC0gYS5kaXN0YW5jZTtcbiAgfSk7XG4gIHJldHVybiBzb3J0ZWRbMF0gPyBzb3J0ZWRbMF0uaWQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXREcm9wcGFibGVPdmVyJDEoX3JlZjIpIHtcbiAgdmFyIHBhZ2VCb3JkZXJCb3ggPSBfcmVmMi5wYWdlQm9yZGVyQm94LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZjIuZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlcyA9IF9yZWYyLmRyb3BwYWJsZXM7XG4gIHZhciBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICghaXRlbS5pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlID0gaXRlbS5zdWJqZWN0LmFjdGl2ZTtcblxuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFnZXRIYXNPdmVybGFwKHBhZ2VCb3JkZXJCb3gsIGFjdGl2ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNQb3NpdGlvbkluRnJhbWUoYWN0aXZlKShwYWdlQm9yZGVyQm94LmNlbnRlcikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBheGlzID0gaXRlbS5heGlzO1xuICAgIHZhciBjaGlsZENlbnRlciA9IGFjdGl2ZS5jZW50ZXJbYXhpcy5jcm9zc0F4aXNMaW5lXTtcbiAgICB2YXIgY3Jvc3NBeGlzU3RhcnQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIHZhciBjcm9zc0F4aXNFbmQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzRW5kXTtcbiAgICB2YXIgaXNDb250YWluZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF0sIGFjdGl2ZVtheGlzLmNyb3NzQXhpc0VuZF0pO1xuICAgIHZhciBpc1N0YXJ0Q29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzU3RhcnQpO1xuICAgIHZhciBpc0VuZENvbnRhaW5lZCA9IGlzQ29udGFpbmVkKGNyb3NzQXhpc0VuZCk7XG5cbiAgICBpZiAoIWlzU3RhcnRDb250YWluZWQgJiYgIWlzRW5kQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdGFydENvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIGNyb3NzQXhpc1N0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyb3NzQXhpc0VuZCA+IGNoaWxkQ2VudGVyO1xuICB9KTtcblxuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXS5kZXNjcmlwdG9yLmlkO1xuICB9XG5cbiAgcmV0dXJuIGdldEZ1cnRoZXN0QXdheSh7XG4gICAgcGFnZUJvcmRlckJveDogcGFnZUJvcmRlckJveCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBjYW5kaWRhdGVzOiBjYW5kaWRhdGVzXG4gIH0pO1xufVxuXG52YXIgb2Zmc2V0UmVjdEJ5UG9zaXRpb24gPSBmdW5jdGlvbiBvZmZzZXRSZWN0QnlQb3NpdGlvbihyZWN0LCBwb2ludCkge1xuICByZXR1cm4gZ2V0UmVjdChvZmZzZXRCeVBvc2l0aW9uKHJlY3QsIHBvaW50KSk7XG59O1xuXG52YXIgd2l0aERyb3BwYWJsZVNjcm9sbCA9IChmdW5jdGlvbiAoZHJvcHBhYmxlLCBhcmVhKSB7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oYXJlYSwgZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWUpO1xufSk7XG5cbmZ1bmN0aW9uIGdldElzRGlzcGxhY2VkKF9yZWYpIHtcbiAgdmFyIGRpc3BsYWNlZCA9IF9yZWYuZGlzcGxhY2VkLFxuICAgICAgaWQgPSBfcmVmLmlkO1xuICByZXR1cm4gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtpZF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtpZF0pO1xufVxuXG5mdW5jdGlvbiBhdEluZGV4KF9yZWYpIHtcbiAgdmFyIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgY2xvc2VzdCA9IF9yZWYuY2xvc2VzdCxcbiAgICAgIGluSG9tZUxpc3QgPSBfcmVmLmluSG9tZUxpc3Q7XG5cbiAgaWYgKCFjbG9zZXN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWluSG9tZUxpc3QpIHtcbiAgICByZXR1cm4gY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4O1xuICB9XG5cbiAgaWYgKGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCA+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmluZGV4KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCAtIDE7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4O1xufVxuXG52YXIgZ2V0UmVvcmRlckltcGFjdCA9IChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgdmFyIHRhcmdldFJlY3QgPSBfcmVmMi5wYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYyLmRyYWdnYWJsZSxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZjIuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYyLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgbGFzdCA9IF9yZWYyLmxhc3QsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYyLnZpZXdwb3J0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYyLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgdmFyIGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICB2YXIgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VkQnkudmFsdWU7XG4gIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgdmFyIHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICB2YXIgY2xvc2VzdCA9IGZpbmQod2l0aG91dERyYWdnaW5nLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIHZhciBjaGlsZENlbnRlciA9IGNoaWxkLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmxpbmVdO1xuICAgIHZhciBkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChpZCwgYWZ0ZXJDcml0aWNhbCk7XG4gICAgdmFyIGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBsYXN0LFxuICAgICAgaWQ6IGlkXG4gICAgfSk7XG5cbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPCBjaGlsZENlbnRlciAtIGRpc3BsYWNlbWVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbmQgPD0gY2hpbGRDZW50ZXIgKyBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gIH0pO1xuICB2YXIgbmV3SW5kZXggPSBhdEluZGV4KHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBjbG9zZXN0OiBjbG9zZXN0LFxuICAgIGluSG9tZUxpc3Q6IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pXG4gIH0pO1xuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgbGFzdDogbGFzdCxcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgaW5kZXg6IG5ld0luZGV4XG4gIH0pO1xufSk7XG5cbnZhciBjb21iaW5lVGhyZXNob2xkRGl2aXNvciA9IDQ7XG52YXIgZ2V0Q29tYmluZUltcGFjdCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICB0YXJnZXRSZWN0ID0gX3JlZi5wYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICAgIHByZXZpb3VzSW1wYWN0ID0gX3JlZi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG5cbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIHZhciBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgdmFyIGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFtheGlzLmVuZF07XG4gIHZhciB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgdmFyIGNvbWJpbmVXaXRoID0gZmluZCh3aXRob3V0RHJhZ2dpbmcsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciBpZCA9IGNoaWxkLmRlc2NyaXB0b3IuaWQ7XG4gICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLnBhZ2UuYm9yZGVyQm94O1xuICAgIHZhciBjaGlsZFNpemUgPSBjaGlsZFJlY3RbYXhpcy5zaXplXTtcbiAgICB2YXIgdGhyZXNob2xkID0gY2hpbGRTaXplIC8gY29tYmluZVRocmVzaG9sZERpdmlzb3I7XG4gICAgdmFyIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGlkLCBhZnRlckNyaXRpY2FsKTtcbiAgICB2YXIgaXNEaXNwbGFjZWQgPSBnZXRJc0Rpc3BsYWNlZCh7XG4gICAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGlkOiBpZFxuICAgIH0pO1xuXG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxKSB7XG4gICAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVuZCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIHRocmVzaG9sZCAmJiB0YXJnZXRFbmQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gdGhyZXNob2xkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gLSBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIGRpc3BsYWNlbWVudCArIHRocmVzaG9sZCAmJiB0YXJnZXRFbmQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdICsgZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRTdGFydCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIHRocmVzaG9sZCAmJiB0YXJnZXRTdGFydCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gIH0pO1xuXG4gIGlmICghY29tYmluZVdpdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGltcGFjdDtcbn0pO1xuXG52YXIgZ2V0RHJhZ0ltcGFjdCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcGFnZU9mZnNldCA9IF9yZWYucGFnZU9mZnNldCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmLmRyb3BwYWJsZXMsXG4gICAgICBwcmV2aW91c0ltcGFjdCA9IF9yZWYucHJldmlvdXNJbXBhY3QsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgcGFnZUJvcmRlckJveCA9IG9mZnNldFJlY3RCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgcGFnZU9mZnNldCk7XG4gIHZhciBkZXN0aW5hdGlvbklkID0gZ2V0RHJvcHBhYmxlT3ZlciQxKHtcbiAgICBwYWdlQm9yZGVyQm94OiBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZXM6IGRyb3BwYWJsZXNcbiAgfSk7XG5cbiAgaWYgKCFkZXN0aW5hdGlvbklkKSB7XG4gICAgcmV0dXJuIG5vSW1wYWN0O1xuICB9XG5cbiAgdmFyIGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlc1tkZXN0aW5hdGlvbklkXTtcbiAgdmFyIGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgdmFyIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsID0gd2l0aERyb3BwYWJsZVNjcm9sbChkZXN0aW5hdGlvbiwgcGFnZUJvcmRlckJveCk7XG4gIHJldHVybiBnZXRDb21iaW5lSW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHByZXZpb3VzSW1wYWN0LFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KSB8fCBnZXRSZW9yZGVySW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBsYXN0OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59KTtcblxudmFyIHBhdGNoRHJvcHBhYmxlTWFwID0gKGZ1bmN0aW9uIChkcm9wcGFibGVzLCB1cGRhdGVkKSB7XG4gIHZhciBfZXh0ZW5kczI7XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkcm9wcGFibGVzLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMlt1cGRhdGVkLmRlc2NyaXB0b3IuaWRdID0gdXBkYXRlZCwgX2V4dGVuZHMyKSk7XG59KTtcblxudmFyIGNsZWFyVW51c2VkUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiBjbGVhclVudXNlZFBsYWNlaG9sZGVyKF9yZWYpIHtcbiAgdmFyIHByZXZpb3VzSW1wYWN0ID0gX3JlZi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgZHJvcHBhYmxlcyA9IF9yZWYuZHJvcHBhYmxlcztcbiAgdmFyIGxhc3QgPSB3aGF0SXNEcmFnZ2VkT3ZlcihwcmV2aW91c0ltcGFjdCk7XG4gIHZhciBub3cgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuXG4gIGlmICghbGFzdCkge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG5cbiAgaWYgKGxhc3QgPT09IG5vdykge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG5cbiAgdmFyIGxhc3REcm9wcGFibGUgPSBkcm9wcGFibGVzW2xhc3RdO1xuXG4gIGlmICghbGFzdERyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG5cbiAgdmFyIHVwZGF0ZWQgPSByZW1vdmVQbGFjZWhvbGRlcihsYXN0RHJvcHBhYmxlKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGRyb3BwYWJsZXMsIHVwZGF0ZWQpO1xufTtcblxudmFyIHJlY29tcHV0ZVBsYWNlaG9sZGVycyA9IChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgdmFyIGRyYWdnYWJsZSA9IF9yZWYyLmRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmMi5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlcyA9IF9yZWYyLmRyb3BwYWJsZXMsXG4gICAgICBwcmV2aW91c0ltcGFjdCA9IF9yZWYyLnByZXZpb3VzSW1wYWN0LFxuICAgICAgaW1wYWN0ID0gX3JlZjIuaW1wYWN0O1xuICB2YXIgY2xlYW5lZCA9IGNsZWFyVW51c2VkUGxhY2Vob2xkZXIoe1xuICAgIHByZXZpb3VzSW1wYWN0OiBwcmV2aW91c0ltcGFjdCxcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBkcm9wcGFibGVzOiBkcm9wcGFibGVzXG4gIH0pO1xuICB2YXIgaXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcblxuICBpZiAoIWlzT3Zlcikge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG5cbiAgdmFyIGRyb3BwYWJsZSA9IGRyb3BwYWJsZXNbaXNPdmVyXTtcblxuICBpZiAoaXNIb21lT2YoZHJhZ2dhYmxlLCBkcm9wcGFibGUpKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cblxuICBpZiAoZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cblxuICB2YXIgcGF0Y2hlZCA9IGFkZFBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGNsZWFuZWQsIHBhdGNoZWQpO1xufSk7XG5cbnZhciB1cGRhdGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGZvcmNlZENsaWVudFNlbGVjdGlvbiA9IF9yZWYuY2xpZW50U2VsZWN0aW9uLFxuICAgICAgZm9yY2VkRGltZW5zaW9ucyA9IF9yZWYuZGltZW5zaW9ucyxcbiAgICAgIGZvcmNlZFZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGZvcmNlZEltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3QgPSBfcmVmLnNjcm9sbEp1bXBSZXF1ZXN0O1xuICB2YXIgdmlld3BvcnQgPSBmb3JjZWRWaWV3cG9ydCB8fCBzdGF0ZS52aWV3cG9ydDtcbiAgdmFyIGRpbWVuc2lvbnMgPSBmb3JjZWREaW1lbnNpb25zIHx8IHN0YXRlLmRpbWVuc2lvbnM7XG4gIHZhciBjbGllbnRTZWxlY3Rpb24gPSBmb3JjZWRDbGllbnRTZWxlY3Rpb24gfHwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uO1xuICB2YXIgb2Zmc2V0ID0gc3VidHJhY3QoY2xpZW50U2VsZWN0aW9uLCBzdGF0ZS5pbml0aWFsLmNsaWVudC5zZWxlY3Rpb24pO1xuICB2YXIgY2xpZW50ID0ge1xuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKHN0YXRlLmluaXRpYWwuY2xpZW50LmJvcmRlckJveENlbnRlciwgb2Zmc2V0KVxuICB9O1xuICB2YXIgcGFnZSA9IHtcbiAgICBzZWxlY3Rpb246IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCksXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoY2xpZW50LmJvcmRlckJveENlbnRlciwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIG9mZnNldDogYWRkKGNsaWVudC5vZmZzZXQsIHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlKVxuICB9O1xuICB2YXIgY3VycmVudCA9IHtcbiAgICBjbGllbnQ6IGNsaWVudCxcbiAgICBwYWdlOiBwYWdlXG4gIH07XG5cbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgcGhhc2U6ICdDT0xMRUNUSU5HJ1xuICAgIH0sIHN0YXRlLCB7XG4gICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgY3VycmVudDogY3VycmVudFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICB2YXIgbmV3SW1wYWN0ID0gZm9yY2VkSW1wYWN0IHx8IGdldERyYWdJbXBhY3Qoe1xuICAgIHBhZ2VPZmZzZXQ6IHBhZ2Uub2Zmc2V0LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgdmFyIHdpdGhVcGRhdGVkUGxhY2Vob2xkZXJzID0gcmVjb21wdXRlUGxhY2Vob2xkZXJzKHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBpbXBhY3Q6IG5ld0ltcGFjdCxcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXNcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgZGltZW5zaW9uczoge1xuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlczogd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnNcbiAgICB9LFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogc2Nyb2xsSnVtcFJlcXVlc3QgfHwgbnVsbCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IHNjcm9sbEp1bXBSZXF1ZXN0ID8gZmFsc2UgOiBudWxsXG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlcyQxKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZHJhZ2dhYmxlc1tpZF07XG4gIH0pO1xufVxuXG52YXIgcmVjb21wdXRlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGUgPSBfcmVmLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgdmFyIGxhc3QgPSBpbXBhY3QuZGlzcGxhY2VkO1xuICB2YXIgYWZ0ZXJEcmFnZ2luZyA9IGdldERyYWdnYWJsZXMkMShsYXN0LmFsbCwgZHJhZ2dhYmxlcyk7XG4gIHZhciBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZm9yY2VTaG91bGRBbmltYXRlLFxuICAgIGxhc3Q6IGxhc3RcbiAgfSk7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaW1wYWN0LCB7XG4gICAgZGlzcGxhY2VkOiBkaXNwbGFjZWRcbiAgfSk7XG59KTtcblxudmFyIGdldENsaWVudEJvcmRlckJveENlbnRlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRyb3BwYWJsZSA9IF9yZWYuZHJvcHBhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGUsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgcmV0dXJuIGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICB9KTtcbn0pO1xuXG52YXIgcmVmcmVzaFNuYXAgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGZvcmNlZERpbWVuc2lvbnMgPSBfcmVmLmRpbWVuc2lvbnMsXG4gICAgICBmb3JjZWRWaWV3cG9ydCA9IF9yZWYudmlld3BvcnQ7XG4gICEoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBuZWVkc1Zpc2liaWxpdHlDaGVjayA9IHN0YXRlLmltcGFjdDtcbiAgdmFyIHZpZXdwb3J0ID0gZm9yY2VkVmlld3BvcnQgfHwgc3RhdGUudmlld3BvcnQ7XG4gIHZhciBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICB2YXIgZHJhZ2dhYmxlcyA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXMgPSBkaW1lbnNpb25zLmRyb3BwYWJsZXM7XG4gIHZhciBkcmFnZ2FibGUgPSBkcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIHZhciBpc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihuZWVkc1Zpc2liaWxpdHlDaGVjayk7XG4gICFpc092ZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG92ZXIgYSBkZXN0aW5hdGlvbiBpbiBTTkFQIG1vdmVtZW50IG1vZGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZXNbaXNPdmVyXTtcbiAgdmFyIGltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgaW1wYWN0OiBuZWVkc1Zpc2liaWxpdHlDaGVjayxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXNcbiAgfSk7XG4gIHZhciBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgY2xpZW50U2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH0pO1xufSk7XG5cbnZhciBnZXRIb21lTG9jYXRpb24gPSAoZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxuICB9O1xufSk7XG5cbnZhciBnZXRMaWZ0RWZmZWN0ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGhvbWUgPSBfcmVmLmhvbWUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0O1xuICB2YXIgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShob21lLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgdmFyIGluc2lkZUhvbWUgPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGhvbWUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIHZhciByYXdJbmRleCA9IGluc2lkZUhvbWUuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAhKHJhd0luZGV4ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkcmFnZ2FibGUgdG8gYmUgaW5zaWRlIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGFmdGVyRHJhZ2dpbmcgPSBpbnNpZGVIb21lLnNsaWNlKHJhd0luZGV4ICsgMSk7XG4gIHZhciBlZmZlY3RlZCA9IGFmdGVyRHJhZ2dpbmcucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgaXRlbSkge1xuICAgIHByZXZpb3VzW2l0ZW0uZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSwge30pO1xuICB2YXIgYWZ0ZXJDcml0aWNhbCA9IHtcbiAgICBpblZpcnR1YWxMaXN0OiBob21lLmRlc2NyaXB0b3IubW9kZSA9PT0gJ3ZpcnR1YWwnLFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBlZmZlY3RlZDogZWZmZWN0ZWRcbiAgfTtcbiAgdmFyIGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogYWZ0ZXJEcmFnZ2luZyxcbiAgICBkZXN0aW5hdGlvbjogaG9tZSxcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgbGFzdDogbnVsbCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgdmFyIGltcGFjdCA9IHtcbiAgICBkaXNwbGFjZWQ6IGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiBnZXRIb21lTG9jYXRpb24oZHJhZ2dhYmxlLmRlc2NyaXB0b3IpXG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfTtcbn0pO1xuXG52YXIgcGF0Y2hEaW1lbnNpb25NYXAgPSAoZnVuY3Rpb24gKGRpbWVuc2lvbnMsIHVwZGF0ZWQpIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogcGF0Y2hEcm9wcGFibGVNYXAoZGltZW5zaW9ucy5kcm9wcGFibGVzLCB1cGRhdGVkKVxuICB9O1xufSk7XG5cbnZhciBzdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG52YXIgZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBvZmZzZXREcmFnZ2FibGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgb2Zmc2V0JDEgPSBfcmVmLm9mZnNldCxcbiAgICAgIGluaXRpYWxXaW5kb3dTY3JvbGwgPSBfcmVmLmluaXRpYWxXaW5kb3dTY3JvbGw7XG4gIHZhciBjbGllbnQgPSBvZmZzZXQoZHJhZ2dhYmxlLmNsaWVudCwgb2Zmc2V0JDEpO1xuICB2YXIgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCBpbml0aWFsV2luZG93U2Nyb2xsKTtcblxuICB2YXIgbW92ZWQgPSBfZXh0ZW5kcyh7fSwgZHJhZ2dhYmxlLCB7XG4gICAgcGxhY2Vob2xkZXI6IF9leHRlbmRzKHt9LCBkcmFnZ2FibGUucGxhY2Vob2xkZXIsIHtcbiAgICAgIGNsaWVudDogY2xpZW50XG4gICAgfSksXG4gICAgY2xpZW50OiBjbGllbnQsXG4gICAgcGFnZTogcGFnZVxuICB9KTtcblxuICByZXR1cm4gbW92ZWQ7XG59KTtcblxudmFyIGdldEZyYW1lID0gKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgdmFyIGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBEcm9wcGFibGUgdG8gaGF2ZSBhIGZyYW1lJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gZnJhbWU7XG59KTtcblxudmFyIGFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFkZGl0aW9ucyA9IF9yZWYuYWRkaXRpb25zLFxuICAgICAgdXBkYXRlZERyb3BwYWJsZXMgPSBfcmVmLnVwZGF0ZWREcm9wcGFibGVzLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0O1xuICB2YXIgd2luZG93U2Nyb2xsQ2hhbmdlID0gdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWU7XG4gIHJldHVybiBhZGRpdGlvbnMubWFwKGZ1bmN0aW9uIChkcmFnZ2FibGUpIHtcbiAgICB2YXIgZHJvcHBhYmxlSWQgPSBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZDtcbiAgICB2YXIgbW9kaWZpZWQgPSB1cGRhdGVkRHJvcHBhYmxlc1tkcm9wcGFibGVJZF07XG4gICAgdmFyIGZyYW1lID0gZ2V0RnJhbWUobW9kaWZpZWQpO1xuICAgIHZhciBkcm9wcGFibGVTY3JvbGxDaGFuZ2UgPSBmcmFtZS5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgICB2YXIgdG90YWxDaGFuZ2UgPSBhZGQod2luZG93U2Nyb2xsQ2hhbmdlLCBkcm9wcGFibGVTY3JvbGxDaGFuZ2UpO1xuICAgIHZhciBtb3ZlZCA9IG9mZnNldERyYWdnYWJsZSh7XG4gICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIG9mZnNldDogdG90YWxDaGFuZ2UsXG4gICAgICBpbml0aWFsV2luZG93U2Nyb2xsOiB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbFxuICAgIH0pO1xuICAgIHJldHVybiBtb3ZlZDtcbiAgfSk7XG59KTtcblxudmFyIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBwdWJsaXNoZWQgPSBfcmVmLnB1Ymxpc2hlZDtcbiAgc3RhcnQoKTtcbiAgdmFyIHdpdGhTY3JvbGxDaGFuZ2UgPSBwdWJsaXNoZWQubW9kaWZpZWQubWFwKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbdXBkYXRlLmRyb3BwYWJsZUlkXTtcbiAgICB2YXIgc2Nyb2xsZWQgPSBzY3JvbGxEcm9wcGFibGUoZXhpc3RpbmcsIHVwZGF0ZS5zY3JvbGwpO1xuICAgIHJldHVybiBzY3JvbGxlZDtcbiAgfSk7XG5cbiAgdmFyIGRyb3BwYWJsZXMgPSBfZXh0ZW5kcyh7fSwgc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzLCB7fSwgdG9Ecm9wcGFibGVNYXAod2l0aFNjcm9sbENoYW5nZSkpO1xuXG4gIHZhciB1cGRhdGVkQWRkaXRpb25zID0gdG9EcmFnZ2FibGVNYXAoYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyh7XG4gICAgYWRkaXRpb25zOiBwdWJsaXNoZWQuYWRkaXRpb25zLFxuICAgIHVwZGF0ZWREcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KSk7XG5cbiAgdmFyIGRyYWdnYWJsZXMgPSBfZXh0ZW5kcyh7fSwgc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzLCB7fSwgdXBkYXRlZEFkZGl0aW9ucyk7XG5cbiAgcHVibGlzaGVkLnJlbW92YWxzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgZGVsZXRlIGRyYWdnYWJsZXNbaWRdO1xuICB9KTtcbiAgdmFyIGRpbWVuc2lvbnMgPSB7XG4gICAgZHJvcHBhYmxlczogZHJvcHBhYmxlcyxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzXG4gIH07XG4gIHZhciB3YXNPdmVySWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICB2YXIgd2FzT3ZlciA9IHdhc092ZXJJZCA/IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1t3YXNPdmVySWRdIDogbnVsbDtcbiAgdmFyIGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICB2YXIgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuXG4gIHZhciBfZ2V0TGlmdEVmZmVjdCA9IGdldExpZnRFZmZlY3Qoe1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGhvbWU6IGhvbWUsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSksXG4gICAgICBvbkxpZnRJbXBhY3QgPSBfZ2V0TGlmdEVmZmVjdC5pbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX2dldExpZnRFZmZlY3QuYWZ0ZXJDcml0aWNhbDtcblxuICB2YXIgcHJldmlvdXNJbXBhY3QgPSB3YXNPdmVyICYmIHdhc092ZXIuaXNDb21iaW5lRW5hYmxlZCA/IHN0YXRlLmltcGFjdCA6IG9uTGlmdEltcGFjdDtcbiAgdmFyIGltcGFjdCA9IGdldERyYWdJbXBhY3Qoe1xuICAgIHBhZ2VPZmZzZXQ6IHN0YXRlLmN1cnJlbnQucGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlOiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXSxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzLFxuICAgIHByZXZpb3VzSW1wYWN0OiBwcmV2aW91c0ltcGFjdCxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgZmluaXNoKCk7XG5cbiAgdmFyIGRyYWdnaW5nU3RhdGUgPSBfZXh0ZW5kcyh7XG4gICAgcGhhc2U6ICdEUkFHR0lORydcbiAgfSwgc3RhdGUsIHtcbiAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBvbkxpZnRJbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWwsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcblxuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiBkcmFnZ2luZ1N0YXRlO1xuICB9XG5cbiAgdmFyIGRyb3BQZW5kaW5nID0gX2V4dGVuZHMoe1xuICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJ1xuICB9LCBkcmFnZ2luZ1N0YXRlLCB7XG4gICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgIHJlYXNvbjogc3RhdGUucmVhc29uLFxuICAgIGlzV2FpdGluZzogZmFsc2VcbiAgfSk7XG5cbiAgcmV0dXJuIGRyb3BQZW5kaW5nO1xufSk7XG5cbnZhciBpc1NuYXBwaW5nID0gZnVuY3Rpb24gaXNTbmFwcGluZyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCc7XG59O1xuXG52YXIgcG9zdERyb3BwYWJsZUNoYW5nZSA9IGZ1bmN0aW9uIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIGlzRW5hYmxlZENoYW5naW5nKSB7XG4gIHZhciBkaW1lbnNpb25zID0gcGF0Y2hEaW1lbnNpb25NYXAoc3RhdGUuZGltZW5zaW9ucywgdXBkYXRlZCk7XG5cbiAgaWYgKCFpc1NuYXBwaW5nKHN0YXRlKSB8fCBpc0VuYWJsZWRDaGFuZ2luZykge1xuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgZGltZW5zaW9uczogZGltZW5zaW9uc1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgZGltZW5zaW9uczogZGltZW5zaW9uc1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5pc0RyYWdnaW5nICYmIHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHBoYXNlOiAnRFJBR0dJTkcnXG4gICAgfSwgc3RhdGUsIHtcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbnZhciBpZGxlID0ge1xuICBwaGFzZTogJ0lETEUnLFxuICBjb21wbGV0ZWQ6IG51bGwsXG4gIHNob3VsZEZsdXNoOiBmYWxzZVxufTtcbnZhciByZWR1Y2VyID0gKGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgc3RhdGUgPSBpZGxlO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBpZGxlLCB7XG4gICAgICBzaG91bGRGbHVzaDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTklUSUFMX1BVQkxJU0ggbXVzdCBjb21lIGFmdGVyIGEgSURMRSBwaGFzZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgX2FjdGlvbiRwYXlsb2FkID0gYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIGNyaXRpY2FsID0gX2FjdGlvbiRwYXlsb2FkLmNyaXRpY2FsLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb24gPSBfYWN0aW9uJHBheWxvYWQuY2xpZW50U2VsZWN0aW9uLFxuICAgICAgICB2aWV3cG9ydCA9IF9hY3Rpb24kcGF5bG9hZC52aWV3cG9ydCxcbiAgICAgICAgZGltZW5zaW9ucyA9IF9hY3Rpb24kcGF5bG9hZC5kaW1lbnNpb25zLFxuICAgICAgICBtb3ZlbWVudE1vZGUgPSBfYWN0aW9uJHBheWxvYWQubW92ZW1lbnRNb2RlO1xuICAgIHZhciBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgICB2YXIgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tjcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICAgIHZhciBjbGllbnQgPSB7XG4gICAgICBzZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGJvcmRlckJveENlbnRlcjogZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyLFxuICAgICAgb2Zmc2V0OiBvcmlnaW5cbiAgICB9O1xuICAgIHZhciBpbml0aWFsID0ge1xuICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNlbGVjdGlvbjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKSxcbiAgICAgICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpLFxuICAgICAgICBvZmZzZXQ6IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpc1dpbmRvd1Njcm9sbEFsbG93ZWQgPSB0b0Ryb3BwYWJsZUxpc3QoZGltZW5zaW9ucy5kcm9wcGFibGVzKS5ldmVyeShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICFpdGVtLmlzRml4ZWRPblBhZ2U7XG4gICAgfSk7XG5cbiAgICB2YXIgX2dldExpZnRFZmZlY3QgPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgaG9tZTogaG9tZSxcbiAgICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICAgIH0pLFxuICAgICAgICBpbXBhY3QgPSBfZ2V0TGlmdEVmZmVjdC5pbXBhY3QsXG4gICAgICAgIGFmdGVyQ3JpdGljYWwgPSBfZ2V0TGlmdEVmZmVjdC5hZnRlckNyaXRpY2FsO1xuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHBoYXNlOiAnRFJBR0dJTkcnLFxuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIGNyaXRpY2FsOiBjcml0aWNhbCxcbiAgICAgIG1vdmVtZW50TW9kZTogbW92ZW1lbnRNb2RlLFxuICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgIGluaXRpYWw6IGluaXRpYWwsXG4gICAgICBjdXJyZW50OiBpbml0aWFsLFxuICAgICAgaXNXaW5kb3dTY3JvbGxBbGxvd2VkOiBpc1dpbmRvd1Njcm9sbEFsbG93ZWQsXG4gICAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWwsXG4gICAgICBvbkxpZnRJbXBhY3Q6IGltcGFjdCxcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsLFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnQ09MTEVDVElPTl9TVEFSVElORycpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDb2xsZWN0aW9uIGNhbm5vdCBzdGFydCBmcm9tIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBfcmVzdWx0ID0gX2V4dGVuZHMoe1xuICAgICAgcGhhc2U6ICdDT0xMRUNUSU5HJ1xuICAgIH0sIHN0YXRlLCB7XG4gICAgICBwaGFzZTogJ0NPTExFQ1RJTkcnXG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3Jlc3VsdDtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSB7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiVW5leHBlY3RlZCBcIiArIGFjdGlvbi50eXBlICsgXCIgcmVjZWl2ZWQgaW4gcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCh7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBwdWJsaXNoZWQ6IGFjdGlvbi5wYXlsb2FkXG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBhY3Rpb24udHlwZSArIFwiIG5vdCBwZXJtaXR0ZWQgaW4gcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfY2xpZW50U2VsZWN0aW9uID0gYWN0aW9uLnBheWxvYWQuY2xpZW50O1xuXG4gICAgaWYgKGlzRXF1YWwoX2NsaWVudFNlbGVjdGlvbiwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgY2xpZW50U2VsZWN0aW9uOiBfY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0OiBpc1NuYXBwaW5nKHN0YXRlKSA/IHN0YXRlLmltcGFjdCA6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfU0NST0xMJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYWN0aW9uLnR5cGUgKyBcIiBub3QgcGVybWl0dGVkIGluIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgX2FjdGlvbiRwYXlsb2FkMiA9IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICBpZCA9IF9hY3Rpb24kcGF5bG9hZDIuaWQsXG4gICAgICAgIG5ld1Njcm9sbCA9IF9hY3Rpb24kcGF5bG9hZDIubmV3U2Nyb2xsO1xuICAgIHZhciB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsZWQgPSBzY3JvbGxEcm9wcGFibGUodGFyZ2V0LCBuZXdTY3JvbGwpO1xuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCBzY3JvbGxlZCwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkF0dGVtcHRpbmcgdG8gbW92ZSBpbiBhbiB1bnN1cHBvcnRlZCBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9hY3Rpb24kcGF5bG9hZDMgPSBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgX2lkID0gX2FjdGlvbiRwYXlsb2FkMy5pZCxcbiAgICAgICAgaXNFbmFibGVkID0gX2FjdGlvbiRwYXlsb2FkMy5pc0VuYWJsZWQ7XG4gICAgdmFyIF90YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbX2lkXTtcbiAgICAhX3RhcmdldCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6IFwiICsgX2lkICsgXCJdIHRvIHRvZ2dsZSBpdHMgZW5hYmxlZCBzdGF0ZVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIShfdGFyZ2V0LmlzRW5hYmxlZCAhPT0gaXNFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0VuYWJsZWQgdG8gXCIgKyBTdHJpbmcoaXNFbmFibGVkKSArIFwiXFxuICAgICAgYnV0IGl0IGlzIGFscmVhZHkgXCIgKyBTdHJpbmcoX3RhcmdldC5pc0VuYWJsZWQpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgdXBkYXRlZCA9IF9leHRlbmRzKHt9LCBfdGFyZ2V0LCB7XG4gICAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIHRydWUpO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgX2FjdGlvbiRwYXlsb2FkNCA9IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICBfaWQyID0gX2FjdGlvbiRwYXlsb2FkNC5pZCxcbiAgICAgICAgaXNDb21iaW5lRW5hYmxlZCA9IF9hY3Rpb24kcGF5bG9hZDQuaXNDb21iaW5lRW5hYmxlZDtcbiAgICB2YXIgX3RhcmdldDIgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbX2lkMl07XG4gICAgIV90YXJnZXQyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBmaW5kIERyb3BwYWJsZVtpZDogXCIgKyBfaWQyICsgXCJdIHRvIHRvZ2dsZSBpdHMgaXNDb21iaW5lRW5hYmxlZCBzdGF0ZVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIShfdGFyZ2V0Mi5pc0NvbWJpbmVFbmFibGVkICE9PSBpc0NvbWJpbmVFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0NvbWJpbmVFbmFibGVkIHRvIFwiICsgU3RyaW5nKGlzQ29tYmluZUVuYWJsZWQpICsgXCJcXG4gICAgICBidXQgaXQgaXMgYWxyZWFkeSBcIiArIFN0cmluZyhfdGFyZ2V0Mi5pc0NvbWJpbmVFbmFibGVkKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIF91cGRhdGVkID0gX2V4dGVuZHMoe30sIF90YXJnZXQyLCB7XG4gICAgICBpc0NvbWJpbmVFbmFibGVkOiBpc0NvbWJpbmVFbmFibGVkXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgX3VwZGF0ZWQsIHRydWUpO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRV9CWV9XSU5ET1dfU0NST0xMJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBtb3ZlIGJ5IHdpbmRvdyBpbiBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIXN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1dpbmRvdyBzY3JvbGxpbmcgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgZm9yIGZpeGVkIGxpc3RzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfbmV3U2Nyb2xsID0gYWN0aW9uLnBheWxvYWQubmV3U2Nyb2xsO1xuXG4gICAgaWYgKGlzRXF1YWwoc3RhdGUudmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsIF9uZXdTY3JvbGwpKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBfdmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydChzdGF0ZS52aWV3cG9ydCwgX25ld1Njcm9sbCk7XG5cbiAgICBpZiAoaXNTbmFwcGluZyhzdGF0ZSkpIHtcbiAgICAgIHJldHVybiByZWZyZXNoU25hcCh7XG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgdmlld3BvcnQ6IF92aWV3cG9ydFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICB2aWV3cG9ydDogX3ZpZXdwb3J0XG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfVklFV1BPUlRfTUFYX1NDUk9MTCcpIHtcbiAgICBpZiAoIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHZhciBtYXhTY3JvbGwgPSBhY3Rpb24ucGF5bG9hZC5tYXhTY3JvbGw7XG5cbiAgICBpZiAoaXNFcXVhbChtYXhTY3JvbGwsIHN0YXRlLnZpZXdwb3J0LnNjcm9sbC5tYXgpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIHdpdGhNYXhTY3JvbGwgPSBfZXh0ZW5kcyh7fSwgc3RhdGUudmlld3BvcnQsIHtcbiAgICAgIHNjcm9sbDogX2V4dGVuZHMoe30sIHN0YXRlLnZpZXdwb3J0LnNjcm9sbCwge1xuICAgICAgICBtYXg6IG1heFNjcm9sbFxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBwaGFzZTogJ0RSQUdHSU5HJ1xuICAgIH0sIHN0YXRlLCB7XG4gICAgICB2aWV3cG9ydDogd2l0aE1heFNjcm9sbFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRV9VUCcgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0RPV04nIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9MRUZUJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfUklHSFQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGFjdGlvbi50eXBlICsgXCIgcmVjZWl2ZWQgd2hpbGUgbm90IGluIERSQUdHSU5HIHBoYXNlXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBfcmVzdWx0MiA9IG1vdmVJbkRpcmVjdGlvbih7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICB0eXBlOiBhY3Rpb24udHlwZVxuICAgIH0pO1xuXG4gICAgaWYgKCFfcmVzdWx0Mikge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgaW1wYWN0OiBfcmVzdWx0Mi5pbXBhY3QsXG4gICAgICBjbGllbnRTZWxlY3Rpb246IF9yZXN1bHQyLmNsaWVudFNlbGVjdGlvbixcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBfcmVzdWx0Mi5zY3JvbGxKdW1wUmVxdWVzdFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgIHZhciByZWFzb24gPSBhY3Rpb24ucGF5bG9hZC5yZWFzb247XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IG1vdmUgaW50byB0aGUgRFJPUF9QRU5ESU5HIHBoYXNlIGZyb20gdGhlIENPTExFQ1RJTkcgcGhhc2UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgbmV3U3RhdGUgPSBfZXh0ZW5kcyh7XG4gICAgICBwaGFzZTogJ0RST1BfUEVORElORydcbiAgICB9LCBzdGF0ZSwge1xuICAgICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgICAgaXNXYWl0aW5nOiB0cnVlLFxuICAgICAgcmVhc29uOiByZWFzb25cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICB2YXIgX2FjdGlvbiRwYXlsb2FkNSA9IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICBjb21wbGV0ZWQgPSBfYWN0aW9uJHBheWxvYWQ1LmNvbXBsZXRlZCxcbiAgICAgICAgZHJvcER1cmF0aW9uID0gX2FjdGlvbiRwYXlsb2FkNS5kcm9wRHVyYXRpb24sXG4gICAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXQgPSBfYWN0aW9uJHBheWxvYWQ1Lm5ld0hvbWVDbGllbnRPZmZzZXQ7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBhbmltYXRlIGRyb3AgZnJvbSBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9yZXN1bHQzID0ge1xuICAgICAgcGhhc2U6ICdEUk9QX0FOSU1BVElORycsXG4gICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbjogZHJvcER1cmF0aW9uLFxuICAgICAgbmV3SG9tZUNsaWVudE9mZnNldDogbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgIGRpbWVuc2lvbnM6IHN0YXRlLmRpbWVuc2lvbnNcbiAgICB9O1xuICAgIHJldHVybiBfcmVzdWx0MztcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgdmFyIF9jb21wbGV0ZWQgPSBhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBoYXNlOiAnSURMRScsXG4gICAgICBjb21wbGV0ZWQ6IF9jb21wbGV0ZWQsXG4gICAgICBzaG91bGRGbHVzaDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufSk7XG5cbnZhciBiZWZvcmVJbml0aWFsQ2FwdHVyZSA9IGZ1bmN0aW9uIGJlZm9yZUluaXRpYWxDYXB0dXJlKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQkVGT1JFX0lOSVRJQUxfQ0FQVFVSRScsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBsaWZ0ID0gZnVuY3Rpb24gbGlmdChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0xJRlQnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgaW5pdGlhbFB1Ymxpc2ggPSBmdW5jdGlvbiBpbml0aWFsUHVibGlzaChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0lOSVRJQUxfUFVCTElTSCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBwdWJsaXNoV2hpbGVEcmFnZ2luZyA9IGZ1bmN0aW9uIHB1Ymxpc2hXaGlsZURyYWdnaW5nKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUFVCTElTSF9XSElMRV9EUkFHR0lORycsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBjb2xsZWN0aW9uU3RhcnRpbmcgPSBmdW5jdGlvbiBjb2xsZWN0aW9uU3RhcnRpbmcoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0NPTExFQ1RJT05fU1RBUlRJTkcnLFxuICAgIHBheWxvYWQ6IG51bGxcbiAgfTtcbn07XG52YXIgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gZnVuY3Rpb24gdXBkYXRlRHJvcHBhYmxlU2Nyb2xsKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9TQ1JPTEwnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gZnVuY3Rpb24gdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQgPSBmdW5jdGlvbiB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgbW92ZSA9IGZ1bmN0aW9uIG1vdmUoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIG1vdmVCeVdpbmRvd1Njcm9sbCA9IGZ1bmN0aW9uIG1vdmVCeVdpbmRvd1Njcm9sbChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ01PVkVfQllfV0lORE9XX1NDUk9MTCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCA9IGZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgbW92ZVVwID0gZnVuY3Rpb24gbW92ZVVwKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX1VQJyxcbiAgICBwYXlsb2FkOiBudWxsXG4gIH07XG59O1xudmFyIG1vdmVEb3duID0gZnVuY3Rpb24gbW92ZURvd24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ01PVkVfRE9XTicsXG4gICAgcGF5bG9hZDogbnVsbFxuICB9O1xufTtcbnZhciBtb3ZlUmlnaHQgPSBmdW5jdGlvbiBtb3ZlUmlnaHQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ01PVkVfUklHSFQnLFxuICAgIHBheWxvYWQ6IG51bGxcbiAgfTtcbn07XG52YXIgbW92ZUxlZnQgPSBmdW5jdGlvbiBtb3ZlTGVmdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9MRUZUJyxcbiAgICBwYXlsb2FkOiBudWxsXG4gIH07XG59O1xudmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0ZMVVNIJyxcbiAgICBwYXlsb2FkOiBudWxsXG4gIH07XG59O1xudmFyIGFuaW1hdGVEcm9wID0gZnVuY3Rpb24gYW5pbWF0ZURyb3AoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdEUk9QX0FOSU1BVEUnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgY29tcGxldGVEcm9wID0gZnVuY3Rpb24gY29tcGxldGVEcm9wKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRFJPUF9DT01QTEVURScsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBkcm9wID0gZnVuY3Rpb24gZHJvcChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0RST1AnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgZHJvcFBlbmRpbmcgPSBmdW5jdGlvbiBkcm9wUGVuZGluZyhhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0RST1BfUEVORElORycsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBkcm9wQW5pbWF0aW9uRmluaXNoZWQgPSBmdW5jdGlvbiBkcm9wQW5pbWF0aW9uRmluaXNoZWQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJyxcbiAgICBwYXlsb2FkOiBudWxsXG4gIH07XG59O1xuXG5mdW5jdGlvbiBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pIHtcbiAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluZGV4ZXMgPSBpbnNpZGVEZXN0aW5hdGlvbi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5kZXNjcmlwdG9yLmluZGV4O1xuICB9KTtcbiAgdmFyIGVycm9ycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjdXJyZW50ID0gaW5kZXhlc1tpXTtcbiAgICB2YXIgcHJldmlvdXMgPSBpbmRleGVzW2kgLSAxXTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBwcmV2aW91cyArIDEpIHtcbiAgICAgIGVycm9yc1tjdXJyZW50XSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmb3JtYXR0ZWQgPSBpbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgaGFzRXJyb3IgPSBCb29sZWFuKGVycm9yc1tpbmRleF0pO1xuICAgIHJldHVybiBoYXNFcnJvciA/IFwiW1xcdUQ4M0RcXHVERDI1XCIgKyBpbmRleCArIFwiXVwiIDogXCJcIiArIGluZGV4O1xuICB9KS5qb2luKCcsICcpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgIERldGVjdGVkIG5vbi1jb25zZWN1dGl2ZSA8RHJhZ2dhYmxlIC8+IGluZGV4ZXMuXFxuXFxuICAgIChUaGlzIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJ1Z3MpXFxuXFxuICAgIFwiICsgZm9ybWF0dGVkICsgXCJcXG4gIFwiKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShjcml0aWNhbC5kcm9wcGFibGUuaWQsIGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyk7XG4gICAgY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKTtcbiAgfVxufVxuXG52YXIgbGlmdCQxID0gKGZ1bmN0aW9uIChtYXJzaGFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSAhPT0gJ0xJRlQnKSB7XG4gICAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfYWN0aW9uJHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGlkID0gX2FjdGlvbiRwYXlsb2FkLmlkLFxuICAgICAgICAgICAgY2xpZW50U2VsZWN0aW9uID0gX2FjdGlvbiRwYXlsb2FkLmNsaWVudFNlbGVjdGlvbixcbiAgICAgICAgICAgIG1vdmVtZW50TW9kZSA9IF9hY3Rpb24kcGF5bG9hZC5tb3ZlbWVudE1vZGU7XG4gICAgICAgIHZhciBpbml0aWFsID0gZ2V0U3RhdGUoKTtcblxuICAgICAgICBpZiAoaW5pdGlhbC5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICAgICAgICBjb21wbGV0ZWQ6IGluaXRpYWwuY29tcGxldGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgIShnZXRTdGF0ZSgpLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBwaGFzZSB0byBzdGFydCBhIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpc3BhdGNoKGZsdXNoKCkpO1xuICAgICAgICBkaXNwYXRjaChiZWZvcmVJbml0aWFsQ2FwdHVyZSh7XG4gICAgICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgICAgIG1vdmVtZW50TW9kZTogbW92ZW1lbnRNb2RlXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHNjcm9sbE9wdGlvbnMgPSB7XG4gICAgICAgICAgc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5OiBtb3ZlbWVudE1vZGUgPT09ICdTTkFQJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgICAgICAgc2Nyb2xsT3B0aW9uczogc2Nyb2xsT3B0aW9uc1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfbWFyc2hhbCRzdGFydFB1Ymxpc2ggPSBtYXJzaGFsLnN0YXJ0UHVibGlzaGluZyhyZXF1ZXN0KSxcbiAgICAgICAgICAgIGNyaXRpY2FsID0gX21hcnNoYWwkc3RhcnRQdWJsaXNoLmNyaXRpY2FsLFxuICAgICAgICAgICAgZGltZW5zaW9ucyA9IF9tYXJzaGFsJHN0YXJ0UHVibGlzaC5kaW1lbnNpb25zLFxuICAgICAgICAgICAgdmlld3BvcnQgPSBfbWFyc2hhbCRzdGFydFB1Ymxpc2gudmlld3BvcnQ7XG5cbiAgICAgICAgdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKTtcbiAgICAgICAgZGlzcGF0Y2goaW5pdGlhbFB1Ymxpc2goe1xuICAgICAgICAgIGNyaXRpY2FsOiBjcml0aWNhbCxcbiAgICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgICAgIGNsaWVudFNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgICAgICAgIG1vdmVtZW50TW9kZTogbW92ZW1lbnRNb2RlLFxuICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIHN0eWxlID0gKGZ1bmN0aW9uIChtYXJzaGFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICAgICAgbWFyc2hhbC5kcmFnZ2luZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgICAgICAgIG1hcnNoYWwuZHJvcHBpbmcoYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdC5yZWFzb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICAgICAgICBtYXJzaGFsLnJlc3RpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgY3VydmVzID0ge1xuICBvdXRPZlRoZVdheTogJ2N1YmljLWJlemllcigwLjIsIDAsIDAsIDEpJyxcbiAgZHJvcDogJ2N1YmljLWJlemllciguMiwxLC4xLDEpJ1xufTtcbnZhciBjb21iaW5lID0ge1xuICBvcGFjaXR5OiB7XG4gICAgZHJvcDogMCxcbiAgICBjb21iaW5pbmc6IDAuN1xuICB9LFxuICBzY2FsZToge1xuICAgIGRyb3A6IDAuNzVcbiAgfVxufTtcbnZhciB0aW1pbmdzID0ge1xuICBvdXRPZlRoZVdheTogMC4yLFxuICBtaW5Ecm9wVGltZTogMC4zMyxcbiAgbWF4RHJvcFRpbWU6IDAuNTVcbn07XG52YXIgb3V0T2ZUaGVXYXlUaW1pbmcgPSB0aW1pbmdzLm91dE9mVGhlV2F5ICsgXCJzIFwiICsgY3VydmVzLm91dE9mVGhlV2F5O1xudmFyIHRyYW5zaXRpb25zID0ge1xuICBmbHVpZDogXCJvcGFjaXR5IFwiICsgb3V0T2ZUaGVXYXlUaW1pbmcsXG4gIHNuYXA6IFwidHJhbnNmb3JtIFwiICsgb3V0T2ZUaGVXYXlUaW1pbmcgKyBcIiwgb3BhY2l0eSBcIiArIG91dE9mVGhlV2F5VGltaW5nLFxuICBkcm9wOiBmdW5jdGlvbiBkcm9wKGR1cmF0aW9uKSB7XG4gICAgdmFyIHRpbWluZyA9IGR1cmF0aW9uICsgXCJzIFwiICsgY3VydmVzLmRyb3A7XG4gICAgcmV0dXJuIFwidHJhbnNmb3JtIFwiICsgdGltaW5nICsgXCIsIG9wYWNpdHkgXCIgKyB0aW1pbmc7XG4gIH0sXG4gIG91dE9mVGhlV2F5OiBcInRyYW5zZm9ybSBcIiArIG91dE9mVGhlV2F5VGltaW5nLFxuICBwbGFjZWhvbGRlcjogXCJoZWlnaHQgXCIgKyBvdXRPZlRoZVdheVRpbWluZyArIFwiLCB3aWR0aCBcIiArIG91dE9mVGhlV2F5VGltaW5nICsgXCIsIG1hcmdpbiBcIiArIG91dE9mVGhlV2F5VGltaW5nXG59O1xuXG52YXIgbW92ZVRvID0gZnVuY3Rpb24gbW92ZVRvKG9mZnNldCkge1xuICByZXR1cm4gaXNFcXVhbChvZmZzZXQsIG9yaWdpbikgPyBudWxsIDogXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXQueCArIFwicHgsIFwiICsgb2Zmc2V0LnkgKyBcInB4KVwiO1xufTtcblxudmFyIHRyYW5zZm9ybXMgPSB7XG4gIG1vdmVUbzogbW92ZVRvLFxuICBkcm9wOiBmdW5jdGlvbiBkcm9wKG9mZnNldCwgaXNDb21iaW5pbmcpIHtcbiAgICB2YXIgdHJhbnNsYXRlID0gbW92ZVRvKG9mZnNldCk7XG5cbiAgICBpZiAoIXRyYW5zbGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFpc0NvbWJpbmluZykge1xuICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNsYXRlICsgXCIgc2NhbGUoXCIgKyBjb21iaW5lLnNjYWxlLmRyb3AgKyBcIilcIjtcbiAgfVxufTtcblxudmFyIG1pbkRyb3BUaW1lID0gdGltaW5ncy5taW5Ecm9wVGltZSxcbiAgICBtYXhEcm9wVGltZSA9IHRpbWluZ3MubWF4RHJvcFRpbWU7XG52YXIgZHJvcFRpbWVSYW5nZSA9IG1heERyb3BUaW1lIC0gbWluRHJvcFRpbWU7XG52YXIgbWF4RHJvcFRpbWVBdERpc3RhbmNlID0gMTUwMDtcbnZhciBjYW5jZWxEcm9wTW9kaWZpZXIgPSAwLjY7XG52YXIgZ2V0RHJvcER1cmF0aW9uID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjdXJyZW50ID0gX3JlZi5jdXJyZW50LFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgcmVhc29uID0gX3JlZi5yZWFzb247XG4gIHZhciBkaXN0YW5jZSQxID0gZGlzdGFuY2UoY3VycmVudCwgZGVzdGluYXRpb24pO1xuXG4gIGlmIChkaXN0YW5jZSQxIDw9IDApIHtcbiAgICByZXR1cm4gbWluRHJvcFRpbWU7XG4gIH1cblxuICBpZiAoZGlzdGFuY2UkMSA+PSBtYXhEcm9wVGltZUF0RGlzdGFuY2UpIHtcbiAgICByZXR1cm4gbWF4RHJvcFRpbWU7XG4gIH1cblxuICB2YXIgcGVyY2VudGFnZSA9IGRpc3RhbmNlJDEgLyBtYXhEcm9wVGltZUF0RGlzdGFuY2U7XG4gIHZhciBkdXJhdGlvbiA9IG1pbkRyb3BUaW1lICsgZHJvcFRpbWVSYW5nZSAqIHBlcmNlbnRhZ2U7XG4gIHZhciB3aXRoRHVyYXRpb24gPSByZWFzb24gPT09ICdDQU5DRUwnID8gZHVyYXRpb24gKiBjYW5jZWxEcm9wTW9kaWZpZXIgOiBkdXJhdGlvbjtcbiAgcmV0dXJuIE51bWJlcih3aXRoRHVyYXRpb24udG9GaXhlZCgyKSk7XG59KTtcblxudmFyIGdldE5ld0hvbWVDbGllbnRPZmZzZXQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkaW1lbnNpb25zID0gX3JlZi5kaW1lbnNpb25zLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIGRyYWdnYWJsZXMgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzID0gZGltZW5zaW9ucy5kcm9wcGFibGVzO1xuICB2YXIgZHJvcHBhYmxlSWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICB2YXIgZGVzdGluYXRpb24gPSBkcm9wcGFibGVJZCA/IGRyb3BwYWJsZXNbZHJvcHBhYmxlSWRdIDogbnVsbDtcbiAgdmFyIGhvbWUgPSBkcm9wcGFibGVzW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXTtcbiAgdmFyIG5ld0NsaWVudENlbnRlciA9IGdldENsaWVudEJvcmRlckJveENlbnRlcih7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24gfHwgaG9tZSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgfSk7XG4gIHZhciBvZmZzZXQgPSBzdWJ0cmFjdChuZXdDbGllbnRDZW50ZXIsIGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlcik7XG4gIHJldHVybiBvZmZzZXQ7XG59KTtcblxudmFyIGdldERyb3BJbXBhY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICByZWFzb24gPSBfcmVmLnJlYXNvbixcbiAgICAgIGxhc3RJbXBhY3QgPSBfcmVmLmxhc3RJbXBhY3QsXG4gICAgICBob21lID0gX3JlZi5ob21lLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgb25MaWZ0SW1wYWN0ID0gX3JlZi5vbkxpZnRJbXBhY3Q7XG5cbiAgaWYgKCFsYXN0SW1wYWN0LmF0IHx8IHJlYXNvbiAhPT0gJ0RST1AnKSB7XG4gICAgdmFyIHJlY29tcHV0ZWRIb21lSW1wYWN0ID0gcmVjb21wdXRlKHtcbiAgICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICAgIGRlc3RpbmF0aW9uOiBob21lLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGltcGFjdDogcmVjb21wdXRlZEhvbWVJbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBpZiAobGFzdEltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiBsYXN0SW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICB2YXIgd2l0aG91dE1vdmVtZW50ID0gX2V4dGVuZHMoe30sIGxhc3RJbXBhY3QsIHtcbiAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgaW1wYWN0OiB3aXRob3V0TW92ZW1lbnQsXG4gICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICB9O1xufSk7XG5cbnZhciBkcm9wJDEgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGlmIChhY3Rpb24udHlwZSAhPT0gJ0RST1AnKSB7XG4gICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgdmFyIHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcblxuICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICAgICAgZGlzcGF0Y2goZHJvcFBlbmRpbmcoe1xuICAgICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1dhaXRpbmdGb3JEcm9wID0gc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnICYmIHN0YXRlLmlzV2FpdGluZztcbiAgICAgICEhaXNXYWl0aW5nRm9yRHJvcCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRFJPUCBhY3Rpb24gb2NjdXJyZWQgd2hpbGUgRFJPUF9QRU5ESU5HIGFuZCBzdGlsbCB3YWl0aW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBkcm9wIGluIHBoYXNlOiBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcbiAgICAgIHZhciBkaW1lbnNpb25zID0gc3RhdGUuZGltZW5zaW9ucztcbiAgICAgIHZhciBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcblxuICAgICAgdmFyIF9nZXREcm9wSW1wYWN0ID0gZ2V0RHJvcEltcGFjdCh7XG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICBsYXN0SW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWwsXG4gICAgICAgIG9uTGlmdEltcGFjdDogc3RhdGUub25MaWZ0SW1wYWN0LFxuICAgICAgICBob21lOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXSxcbiAgICAgICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgICAgICBkcmFnZ2FibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNcbiAgICAgIH0pLFxuICAgICAgICAgIGltcGFjdCA9IF9nZXREcm9wSW1wYWN0LmltcGFjdCxcbiAgICAgICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlID0gX2dldERyb3BJbXBhY3QuZGlkRHJvcEluc2lkZURyb3BwYWJsZTtcblxuICAgICAgdmFyIGRlc3RpbmF0aW9uID0gZGlkRHJvcEluc2lkZURyb3BwYWJsZSA/IHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCkgOiBudWxsO1xuICAgICAgdmFyIGNvbWJpbmUgPSBkaWREcm9wSW5zaWRlRHJvcHBhYmxlID8gdHJ5R2V0Q29tYmluZShpbXBhY3QpIDogbnVsbDtcbiAgICAgIHZhciBzb3VyY2UgPSB7XG4gICAgICAgIGluZGV4OiBjcml0aWNhbC5kcmFnZ2FibGUuaW5kZXgsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWRcbiAgICAgIH07XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBkcmFnZ2FibGVJZDogZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIHR5cGU6IGRyYWdnYWJsZS5kZXNjcmlwdG9yLnR5cGUsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgbW9kZTogc3RhdGUubW92ZW1lbnRNb2RlLFxuICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgICAgIGNvbWJpbmU6IGNvbWJpbmVcbiAgICAgIH07XG4gICAgICB2YXIgbmV3SG9tZUNsaWVudE9mZnNldCA9IGdldE5ld0hvbWVDbGllbnRPZmZzZXQoe1xuICAgICAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICAgICAgfSk7XG4gICAgICB2YXIgY29tcGxldGVkID0ge1xuICAgICAgICBjcml0aWNhbDogc3RhdGUuY3JpdGljYWwsXG4gICAgICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWwsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICBpbXBhY3Q6IGltcGFjdFxuICAgICAgfTtcbiAgICAgIHZhciBpc0FuaW1hdGlvblJlcXVpcmVkID0gIWlzRXF1YWwoc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LCBuZXdIb21lQ2xpZW50T2Zmc2V0KSB8fCBCb29sZWFuKHJlc3VsdC5jb21iaW5lKTtcblxuICAgICAgaWYgKCFpc0FuaW1hdGlvblJlcXVpcmVkKSB7XG4gICAgICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkcm9wRHVyYXRpb24gPSBnZXREcm9wRHVyYXRpb24oe1xuICAgICAgICBjdXJyZW50OiBzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgfSk7XG4gICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgbmV3SG9tZUNsaWVudE9mZnNldDogbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgZHJvcER1cmF0aW9uOiBkcm9wRHVyYXRpb24sXG4gICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkXG4gICAgICB9O1xuICAgICAgZGlzcGF0Y2goYW5pbWF0ZURyb3AoYXJncykpO1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGdldFdpbmRvd1Njcm9sbCA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJpbmRpbmcodXBkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gd2luZG93ICYmIGV2ZW50LnRhcmdldCAhPT0gd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxMaXN0ZW5lcihfcmVmKSB7XG4gIHZhciBvbldpbmRvd1Njcm9sbCA9IF9yZWYub25XaW5kb3dTY3JvbGw7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCkge1xuICAgIG9uV2luZG93U2Nyb2xsKGdldFdpbmRvd1Njcm9sbCgpKTtcbiAgfVxuXG4gIHZhciBzY2hlZHVsZWQgPSByYWZTY2hkKHVwZGF0ZVNjcm9sbCk7XG4gIHZhciBiaW5kaW5nID0gZ2V0V2luZG93U2Nyb2xsQmluZGluZyhzY2hlZHVsZWQpO1xuICB2YXIgdW5iaW5kID0gbm9vcDtcblxuICBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdW5iaW5kICE9PSBub29wO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgISFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IHNjcm9sbCBsaXN0ZW5lciB3aGVuIGFscmVhZHkgYWN0aXZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAhaXNBY3RpdmUoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIHNjcm9sbCBsaXN0ZW5lciB3aGVuIG5vdCBhY3RpdmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgc2NoZWR1bGVkLmNhbmNlbCgpO1xuICAgIHVuYmluZCgpO1xuICAgIHVuYmluZCA9IG5vb3A7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBzdG9wOiBzdG9wLFxuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZVxuICB9O1xufVxuXG52YXIgc2hvdWxkRW5kID0gZnVuY3Rpb24gc2hvdWxkRW5kKGFjdGlvbikge1xuICByZXR1cm4gYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScgfHwgYWN0aW9uLnR5cGUgPT09ICdGTFVTSCc7XG59O1xuXG52YXIgc2Nyb2xsTGlzdGVuZXIgPSAoZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHZhciBsaXN0ZW5lciA9IGdldFNjcm9sbExpc3RlbmVyKHtcbiAgICBvbldpbmRvd1Njcm9sbDogZnVuY3Rpb24gb25XaW5kb3dTY3JvbGwobmV3U2Nyb2xsKSB7XG4gICAgICBzdG9yZS5kaXNwYXRjaChtb3ZlQnlXaW5kb3dTY3JvbGwoe1xuICAgICAgICBuZXdTY3JvbGw6IG5ld1Njcm9sbFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICAgIGxpc3RlbmVyLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIHNob3VsZEVuZChhY3Rpb24pKSB7XG4gICAgICAgIGxpc3RlbmVyLnN0b3AoKTtcbiAgICAgIH1cblxuICAgICAgbmV4dChhY3Rpb24pO1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGdldEV4cGlyaW5nQW5ub3VuY2UgPSAoZnVuY3Rpb24gKGFubm91bmNlKSB7XG4gIHZhciB3YXNDYWxsZWQgPSBmYWxzZTtcbiAgdmFyIGlzRXhwaXJlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaXNFeHBpcmVkID0gdHJ1ZTtcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIHJlc3VsdChtZXNzYWdlKSB7XG4gICAgaWYgKHdhc0NhbGxlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnQW5ub3VuY2VtZW50IGFscmVhZHkgbWFkZS4gTm90IG1ha2luZyBhIHNlY29uZCBhbm5vdW5jZW1lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNFeHBpcmVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgICBBbm5vdW5jZW1lbnRzIGNhbm5vdCBiZSBtYWRlIGFzeW5jaHJvbm91c2x5LlxcbiAgICAgICAgRGVmYXVsdCBtZXNzYWdlIGhhcyBhbHJlYWR5IGJlZW4gYW5ub3VuY2VkLlxcbiAgICAgIFwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXNDYWxsZWQgPSB0cnVlO1xuICAgIGFubm91bmNlKG1lc3NhZ2UpO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9O1xuXG4gIHJlc3VsdC53YXNDYWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdhc0NhbGxlZDtcbiAgfTtcblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbnZhciBnZXRBc3luY01hcnNoYWwgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgZW50cmllcyA9IFtdO1xuXG4gIHZhciBleGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZSh0aW1lcklkKSB7XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KGVudHJpZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS50aW1lcklkID09PSB0aW1lcklkO1xuICAgIH0pO1xuICAgICEoaW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHRpbWVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIF9lbnRyaWVzJHNwbGljZSA9IGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKSxcbiAgICAgICAgZW50cnkgPSBfZW50cmllcyRzcGxpY2VbMF07XG5cbiAgICBlbnRyeS5jYWxsYmFjaygpO1xuICB9O1xuXG4gIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoZm4pIHtcbiAgICB2YXIgdGltZXJJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUodGltZXJJZCk7XG4gICAgfSk7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdGltZXJJZDogdGltZXJJZCxcbiAgICAgIGNhbGxiYWNrOiBmblxuICAgIH07XG4gICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNoYWxsb3cgPSBbXS5jb25jYXQoZW50cmllcyk7XG4gICAgZW50cmllcy5sZW5ndGggPSAwO1xuICAgIHNoYWxsb3cuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIGNsZWFyVGltZW91dChlbnRyeS50aW1lcklkKTtcbiAgICAgIGVudHJ5LmNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhZGQ6IGFkZCxcbiAgICBmbHVzaDogZmx1c2hcbiAgfTtcbn0pO1xuXG52YXIgYXJlTG9jYXRpb25zRXF1YWwgPSBmdW5jdGlvbiBhcmVMb2NhdGlvbnNFcXVhbChmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZmlyc3QgPT0gbnVsbCB8fCBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdC5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyb3BwYWJsZUlkICYmIGZpcnN0LmluZGV4ID09PSBzZWNvbmQuaW5kZXg7XG59O1xudmFyIGlzQ29tYmluZUVxdWFsID0gZnVuY3Rpb24gaXNDb21iaW5lRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZmlyc3QuZHJhZ2dhYmxlSWQgPT09IHNlY29uZC5kcmFnZ2FibGVJZCAmJiBmaXJzdC5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyb3BwYWJsZUlkO1xufTtcbnZhciBpc0NyaXRpY2FsRXF1YWwgPSBmdW5jdGlvbiBpc0NyaXRpY2FsRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGlzRHJhZ2dhYmxlRXF1YWwgPSBmaXJzdC5kcmFnZ2FibGUuaWQgPT09IHNlY29uZC5kcmFnZ2FibGUuaWQgJiYgZmlyc3QuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkICYmIGZpcnN0LmRyYWdnYWJsZS50eXBlID09PSBzZWNvbmQuZHJhZ2dhYmxlLnR5cGUgJiYgZmlyc3QuZHJhZ2dhYmxlLmluZGV4ID09PSBzZWNvbmQuZHJhZ2dhYmxlLmluZGV4O1xuICB2YXIgaXNEcm9wcGFibGVFcXVhbCA9IGZpcnN0LmRyb3BwYWJsZS5pZCA9PT0gc2Vjb25kLmRyb3BwYWJsZS5pZCAmJiBmaXJzdC5kcm9wcGFibGUudHlwZSA9PT0gc2Vjb25kLmRyb3BwYWJsZS50eXBlO1xuICByZXR1cm4gaXNEcmFnZ2FibGVFcXVhbCAmJiBpc0Ryb3BwYWJsZUVxdWFsO1xufTtcblxudmFyIHdpdGhUaW1pbmdzID0gZnVuY3Rpb24gd2l0aFRpbWluZ3Moa2V5LCBmbikge1xuICBzdGFydCgpO1xuICBmbigpO1xuICBmaW5pc2goKTtcbn07XG5cbnZhciBnZXREcmFnU3RhcnQgPSBmdW5jdGlvbiBnZXREcmFnU3RhcnQoY3JpdGljYWwsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGVJZDogY3JpdGljYWwuZHJhZ2dhYmxlLmlkLFxuICAgIHR5cGU6IGNyaXRpY2FsLmRyb3BwYWJsZS50eXBlLFxuICAgIHNvdXJjZToge1xuICAgICAgZHJvcHBhYmxlSWQ6IGNyaXRpY2FsLmRyb3BwYWJsZS5pZCxcbiAgICAgIGluZGV4OiBjcml0aWNhbC5kcmFnZ2FibGUuaW5kZXhcbiAgICB9LFxuICAgIG1vZGU6IG1vZGVcbiAgfTtcbn07XG5cbnZhciBleGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZShyZXNwb25kZXIsIGRhdGEsIGFubm91bmNlLCBnZXREZWZhdWx0TWVzc2FnZSkge1xuICBpZiAoIXJlc3BvbmRlcikge1xuICAgIGFubm91bmNlKGdldERlZmF1bHRNZXNzYWdlKGRhdGEpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgd2lsbEV4cGlyZSA9IGdldEV4cGlyaW5nQW5ub3VuY2UoYW5ub3VuY2UpO1xuICB2YXIgcHJvdmlkZWQgPSB7XG4gICAgYW5ub3VuY2U6IHdpbGxFeHBpcmVcbiAgfTtcbiAgcmVzcG9uZGVyKGRhdGEsIHByb3ZpZGVkKTtcblxuICBpZiAoIXdpbGxFeHBpcmUud2FzQ2FsbGVkKCkpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gIH1cbn07XG5cbnZhciBnZXRQdWJsaXNoZXIgPSAoZnVuY3Rpb24gKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSB7XG4gIHZhciBhc3luY01hcnNoYWwgPSBnZXRBc3luY01hcnNoYWwoKTtcbiAgdmFyIGRyYWdnaW5nID0gbnVsbDtcblxuICB2YXIgYmVmb3JlQ2FwdHVyZSA9IGZ1bmN0aW9uIGJlZm9yZUNhcHR1cmUoZHJhZ2dhYmxlSWQsIG1vZGUpIHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVDYXB0dXJlIGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB3aXRoVGltaW5ncygnb25CZWZvcmVDYXB0dXJlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZuID0gZ2V0UmVzcG9uZGVycygpLm9uQmVmb3JlQ2FwdHVyZTtcblxuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSB7XG4gICAgICAgICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICAgIG1vZGU6IG1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgZm4oYmVmb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgYmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBiZWZvcmVTdGFydChjcml0aWNhbCwgbW9kZSkge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZURyYWdTdGFydCBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgd2l0aFRpbWluZ3MoJ29uQmVmb3JlRHJhZ1N0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZuID0gZ2V0UmVzcG9uZGVycygpLm9uQmVmb3JlRHJhZ1N0YXJ0O1xuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoY3JpdGljYWwsIG1vZGUpIHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBkYXRhID0gZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBsYXN0Q3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgbGFzdExvY2F0aW9uOiBkYXRhLnNvdXJjZSxcbiAgICAgIGxhc3RDb21iaW5lOiBudWxsXG4gICAgfTtcbiAgICBhc3luY01hcnNoYWwuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdTdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ1N0YXJ0LCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoY3JpdGljYWwsIGltcGFjdCkge1xuICAgIHZhciBsb2NhdGlvbiA9IHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCk7XG4gICAgdmFyIGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnTW92ZSB3aGVuIG9uRHJhZ1N0YXJ0IGhhcyBub3QgYmVlbiBjYWxsZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGhhc0NyaXRpY2FsQ2hhbmdlZCA9ICFpc0NyaXRpY2FsRXF1YWwoY3JpdGljYWwsIGRyYWdnaW5nLmxhc3RDcml0aWNhbCk7XG5cbiAgICBpZiAoaGFzQ3JpdGljYWxDaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0Q3JpdGljYWwgPSBjcml0aWNhbDtcbiAgICB9XG5cbiAgICB2YXIgaGFzTG9jYXRpb25DaGFuZ2VkID0gIWFyZUxvY2F0aW9uc0VxdWFsKGRyYWdnaW5nLmxhc3RMb2NhdGlvbiwgbG9jYXRpb24pO1xuXG4gICAgaWYgKGhhc0xvY2F0aW9uQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuXG4gICAgdmFyIGhhc0dyb3VwaW5nQ2hhbmdlZCA9ICFpc0NvbWJpbmVFcXVhbChkcmFnZ2luZy5sYXN0Q29tYmluZSwgY29tYmluZSk7XG5cbiAgICBpZiAoaGFzR3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0Q29tYmluZSA9IGNvbWJpbmU7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNDcml0aWNhbENoYW5nZWQgJiYgIWhhc0xvY2F0aW9uQ2hhbmdlZCAmJiAhaGFzR3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7fSwgZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSwge1xuICAgICAgY29tYmluZTogY29tYmluZSxcbiAgICAgIGRlc3RpbmF0aW9uOiBsb2NhdGlvblxuICAgIH0pO1xuXG4gICAgYXN5bmNNYXJzaGFsLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnVXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnVXBkYXRlLCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ1VwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBmbHVzaCByZXNwb25kZXJzIHdoaWxlIGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGFzeW5jTWFyc2hhbC5mbHVzaCgpO1xuICB9O1xuXG4gIHZhciBkcm9wID0gZnVuY3Rpb24gZHJvcChyZXN1bHQpIHtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkRyYWdFbmQgd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBvbkRyYWdTdGFydCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gICAgd2l0aFRpbWluZ3MoJ29uRHJhZ0VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdFbmQsIHJlc3VsdCwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdFbmQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gX2V4dGVuZHMoe30sIGdldERyYWdTdGFydChkcmFnZ2luZy5sYXN0Q3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLCB7XG4gICAgICBjb21iaW5lOiBudWxsLFxuICAgICAgZGVzdGluYXRpb246IG51bGwsXG4gICAgICByZWFzb246ICdDQU5DRUwnXG4gICAgfSk7XG5cbiAgICBkcm9wKHJlc3VsdCk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBiZWZvcmVDYXB0dXJlOiBiZWZvcmVDYXB0dXJlLFxuICAgIGJlZm9yZVN0YXJ0OiBiZWZvcmVTdGFydCxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgZmx1c2g6IGZsdXNoLFxuICAgIGRyb3A6IGRyb3AsXG4gICAgYWJvcnQ6IGFib3J0XG4gIH07XG59KTtcblxudmFyIHJlc3BvbmRlcnMgPSAoZnVuY3Rpb24gKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSB7XG4gIHZhciBwdWJsaXNoZXIgPSBnZXRQdWJsaXNoZXIoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdCRUZPUkVfSU5JVElBTF9DQVBUVVJFJykge1xuICAgICAgICAgIHB1Ymxpc2hlci5iZWZvcmVDYXB0dXJlKGFjdGlvbi5wYXlsb2FkLmRyYWdnYWJsZUlkLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAgICAgICB2YXIgY3JpdGljYWwgPSBhY3Rpb24ucGF5bG9hZC5jcml0aWNhbDtcbiAgICAgICAgICBwdWJsaXNoZXIuYmVmb3JlU3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICAgIHB1Ymxpc2hlci5zdGFydChjcml0aWNhbCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0O1xuICAgICAgICAgIHB1Ymxpc2hlci5mbHVzaCgpO1xuICAgICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICBwdWJsaXNoZXIuZHJvcChyZXN1bHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoYWN0aW9uKTtcblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICAgICAgICBwdWJsaXNoZXIuYWJvcnQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICAgIHB1Ymxpc2hlci51cGRhdGUoc3RhdGUuY3JpdGljYWwsIHN0YXRlLmltcGFjdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgZHJvcEFuaW1hdGlvbkZpbmlzaCA9IChmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGlmIChhY3Rpb24udHlwZSAhPT0gJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJykge1xuICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICEoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmlzaCBhIGRyb3AgYW5pbWF0aW5nIHdoZW4gbm8gZHJvcCBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBzdG9yZS5kaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgICAgICBjb21wbGV0ZWQ6IHN0YXRlLmNvbXBsZXRlZFxuICAgICAgfSkpO1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsID0gKGZ1bmN0aW9uIChzdG9yZSkge1xuICB2YXIgdW5iaW5kID0gbnVsbDtcbiAgdmFyIGZyYW1lSWQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh1bmJpbmQpIHtcbiAgICAgIHVuYmluZCgpO1xuICAgICAgdW5iaW5kID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpIHtcbiAgICAgICAgY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgbmV4dChhY3Rpb24pO1xuXG4gICAgICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QX0FOSU1BVEUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJpbmRpbmcgPSB7XG4gICAgICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZm46IGZ1bmN0aW9uIGZsdXNoRHJvcEFuaW1hdGlvbigpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaChkcm9wQW5pbWF0aW9uRmluaXNoZWQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgICB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW2JpbmRpbmddKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyID0gKGZ1bmN0aW9uIChtYXJzaGFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICAgICAgICBtYXJzaGFsLnN0b3BQdWJsaXNoaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGZvY3VzID0gKGZ1bmN0aW9uIChtYXJzaGFsKSB7XG4gIHZhciBpc1dhdGNoaW5nID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICAgICAgaXNXYXRjaGluZyA9IHRydWU7XG4gICAgICAgICAgbWFyc2hhbC50cnlSZWNvcmRGb2N1cyhhY3Rpb24ucGF5bG9hZC5jcml0aWNhbC5kcmFnZ2FibGUuaWQpO1xuICAgICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChhY3Rpb24pO1xuXG4gICAgICAgIGlmICghaXNXYXRjaGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgICAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICAgICAgICBpc1dhdGNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQ7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LmNvbWJpbmUpIHtcbiAgICAgICAgICAgIG1hcnNoYWwudHJ5U2hpZnRSZWNvcmQocmVzdWx0LmRyYWdnYWJsZUlkLCByZXN1bHQuY29tYmluZS5kcmFnZ2FibGVJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIHNob3VsZFN0b3AgPSBmdW5jdGlvbiBzaG91bGRTdG9wKGFjdGlvbikge1xuICByZXR1cm4gYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScgfHwgYWN0aW9uLnR5cGUgPT09ICdGTFVTSCc7XG59O1xuXG52YXIgYXV0b1Njcm9sbCA9IChmdW5jdGlvbiAoYXV0b1Njcm9sbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChzaG91bGRTdG9wKGFjdGlvbikpIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwaGFzZSB0byBiZSBEUkFHR0lORyBhZnRlciBJTklUSUFMX1BVQkxJU0gnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgICAgYXV0b1Njcm9sbGVyLnN0YXJ0KHN0YXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgIGF1dG9TY3JvbGxlci5zY3JvbGwoc3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIHBlbmRpbmdEcm9wID0gKGZ1bmN0aW9uIChzdG9yZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgbmV4dChhY3Rpb24pO1xuXG4gICAgICBpZiAoYWN0aW9uLnR5cGUgIT09ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3N0QWN0aW9uU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAocG9zdEFjdGlvblN0YXRlLnBoYXNlICE9PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3N0QWN0aW9uU3RhdGUuaXNXYWl0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcCh7XG4gICAgICAgIHJlYXNvbjogcG9zdEFjdGlvblN0YXRlLnJlYXNvblxuICAgICAgfSkpO1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGNvbXBvc2VFbmhhbmNlcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fKHtcbiAgbmFtZTogJ3JlYWN0LWJlYXV0aWZ1bC1kbmQnXG59KSA6IGNvbXBvc2U7XG52YXIgY3JlYXRlU3RvcmUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRpbWVuc2lvbk1hcnNoYWwgPSBfcmVmLmRpbWVuc2lvbk1hcnNoYWwsXG4gICAgICBmb2N1c01hcnNoYWwgPSBfcmVmLmZvY3VzTWFyc2hhbCxcbiAgICAgIHN0eWxlTWFyc2hhbCA9IF9yZWYuc3R5bGVNYXJzaGFsLFxuICAgICAgZ2V0UmVzcG9uZGVycyA9IF9yZWYuZ2V0UmVzcG9uZGVycyxcbiAgICAgIGFubm91bmNlID0gX3JlZi5hbm5vdW5jZSxcbiAgICAgIGF1dG9TY3JvbGxlciA9IF9yZWYuYXV0b1Njcm9sbGVyO1xuICByZXR1cm4gY3JlYXRlU3RvcmUkMShyZWR1Y2VyLCBjb21wb3NlRW5oYW5jZXJzKGFwcGx5TWlkZGxld2FyZShzdHlsZShzdHlsZU1hcnNoYWwpLCBkaW1lbnNpb25NYXJzaGFsU3RvcHBlcihkaW1lbnNpb25NYXJzaGFsKSwgbGlmdCQxKGRpbWVuc2lvbk1hcnNoYWwpLCBkcm9wJDEsIGRyb3BBbmltYXRpb25GaW5pc2gsIGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsLCBwZW5kaW5nRHJvcCwgYXV0b1Njcm9sbChhdXRvU2Nyb2xsZXIpLCBzY3JvbGxMaXN0ZW5lciwgZm9jdXMoZm9jdXNNYXJzaGFsKSwgcmVzcG9uZGVycyhnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkpKSk7XG59KTtcblxudmFyIGNsZWFuJDEgPSBmdW5jdGlvbiBjbGVhbigpIHtcbiAgcmV0dXJuIHtcbiAgICBhZGRpdGlvbnM6IHt9LFxuICAgIHJlbW92YWxzOiB7fSxcbiAgICBtb2RpZmllZDoge31cbiAgfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVQdWJsaXNoZXIoX3JlZikge1xuICB2YXIgcmVnaXN0cnkgPSBfcmVmLnJlZ2lzdHJ5LFxuICAgICAgY2FsbGJhY2tzID0gX3JlZi5jYWxsYmFja3M7XG4gIHZhciBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICB2YXIgZnJhbWVJZCA9IG51bGw7XG5cbiAgdmFyIGNvbGxlY3QgPSBmdW5jdGlvbiBjb2xsZWN0KCkge1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZygpO1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICBzdGFydCgpO1xuICAgICAgdmFyIF9zdGFnaW5nID0gc3RhZ2luZyxcbiAgICAgICAgICBhZGRpdGlvbnMgPSBfc3RhZ2luZy5hZGRpdGlvbnMsXG4gICAgICAgICAgcmVtb3ZhbHMgPSBfc3RhZ2luZy5yZW1vdmFscyxcbiAgICAgICAgICBtb2RpZmllZCA9IF9zdGFnaW5nLm1vZGlmaWVkO1xuICAgICAgdmFyIGFkZGVkID0gT2JqZWN0LmtleXMoYWRkaXRpb25zKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QnlJZChpZCkuZ2V0RGltZW5zaW9uKG9yaWdpbik7XG4gICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXg7XG4gICAgICB9KTtcbiAgICAgIHZhciB1cGRhdGVkID0gT2JqZWN0LmtleXMobW9kaWZpZWQpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoaWQpO1xuICAgICAgICB2YXIgc2Nyb2xsID0gZW50cnkuY2FsbGJhY2tzLmdldFNjcm9sbFdoaWxlRHJhZ2dpbmcoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogaWQsXG4gICAgICAgICAgc2Nyb2xsOiBzY3JvbGxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgYWRkaXRpb25zOiBhZGRlZCxcbiAgICAgICAgcmVtb3ZhbHM6IE9iamVjdC5rZXlzKHJlbW92YWxzKSxcbiAgICAgICAgbW9kaWZpZWQ6IHVwZGF0ZWRcbiAgICAgIH07XG4gICAgICBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICAgICAgZmluaXNoKCk7XG4gICAgICBjYWxsYmFja3MucHVibGlzaChyZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoZW50cnkpIHtcbiAgICB2YXIgaWQgPSBlbnRyeS5kZXNjcmlwdG9yLmlkO1xuICAgIHN0YWdpbmcuYWRkaXRpb25zW2lkXSA9IGVudHJ5O1xuICAgIHN0YWdpbmcubW9kaWZpZWRbZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZF0gPSB0cnVlO1xuXG4gICAgaWYgKHN0YWdpbmcucmVtb3ZhbHNbaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5yZW1vdmFsc1tpZF07XG4gICAgfVxuXG4gICAgY29sbGVjdCgpO1xuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoZW50cnkpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgc3RhZ2luZy5yZW1vdmFsc1tkZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgc3RhZ2luZy5tb2RpZmllZFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSA9IHRydWU7XG5cbiAgICBpZiAoc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF0pIHtcbiAgICAgIGRlbGV0ZSBzdGFnaW5nLmFkZGl0aW9uc1tkZXNjcmlwdG9yLmlkXTtcbiAgICB9XG5cbiAgICBjb2xsZWN0KCk7XG4gIH07XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmICghZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIGZyYW1lSWQgPSBudWxsO1xuICAgIHN0YWdpbmcgPSBjbGVhbiQxKCk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhZGQ6IGFkZCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBzdG9wOiBzdG9wXG4gIH07XG59XG5cbnZhciBnZXRNYXhTY3JvbGwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHNjcm9sbEhlaWdodCA9IF9yZWYuc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGggPSBfcmVmLnNjcm9sbFdpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGg7XG4gIHZhciBtYXhTY3JvbGwgPSBzdWJ0cmFjdCh7XG4gICAgeDogc2Nyb2xsV2lkdGgsXG4gICAgeTogc2Nyb2xsSGVpZ2h0XG4gIH0sIHtcbiAgICB4OiB3aWR0aCxcbiAgICB5OiBoZWlnaHRcbiAgfSk7XG4gIHZhciBhZGp1c3RlZE1heFNjcm9sbCA9IHtcbiAgICB4OiBNYXRoLm1heCgwLCBtYXhTY3JvbGwueCksXG4gICAgeTogTWF0aC5tYXgoMCwgbWF4U2Nyb2xsLnkpXG4gIH07XG4gIHJldHVybiBhZGp1c3RlZE1heFNjcm9sbDtcbn0pO1xuXG52YXIgZ2V0RG9jdW1lbnRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgIWRvYyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvYztcbn0pO1xuXG52YXIgZ2V0TWF4V2luZG93U2Nyb2xsID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICB2YXIgbWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsKHtcbiAgICBzY3JvbGxIZWlnaHQ6IGRvYy5zY3JvbGxIZWlnaHQsXG4gICAgc2Nyb2xsV2lkdGg6IGRvYy5zY3JvbGxXaWR0aCxcbiAgICB3aWR0aDogZG9jLmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogZG9jLmNsaWVudEhlaWdodFxuICB9KTtcbiAgcmV0dXJuIG1heFNjcm9sbDtcbn0pO1xuXG52YXIgZ2V0Vmlld3BvcnQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgc2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKCk7XG4gIHZhciBtYXhTY3JvbGwgPSBnZXRNYXhXaW5kb3dTY3JvbGwoKTtcbiAgdmFyIHRvcCA9IHNjcm9sbC55O1xuICB2YXIgbGVmdCA9IHNjcm9sbC54O1xuICB2YXIgZG9jID0gZ2V0RG9jdW1lbnRFbGVtZW50KCk7XG4gIHZhciB3aWR0aCA9IGRvYy5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGRvYy5jbGllbnRIZWlnaHQ7XG4gIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgdmFyIGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgYm90dG9tOiBib3R0b21cbiAgfSk7XG4gIHZhciB2aWV3cG9ydCA9IHtcbiAgICBmcmFtZTogZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGwsXG4gICAgICBjdXJyZW50OiBzY3JvbGwsXG4gICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB2aWV3cG9ydDtcbn0pO1xuXG52YXIgZ2V0SW5pdGlhbFB1Ymxpc2ggPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGNyaXRpY2FsID0gX3JlZi5jcml0aWNhbCxcbiAgICAgIHNjcm9sbE9wdGlvbnMgPSBfcmVmLnNjcm9sbE9wdGlvbnMsXG4gICAgICByZWdpc3RyeSA9IF9yZWYucmVnaXN0cnk7XG4gIHN0YXJ0KCk7XG4gIHZhciB2aWV3cG9ydCA9IGdldFZpZXdwb3J0KCk7XG4gIHZhciB3aW5kb3dTY3JvbGwgPSB2aWV3cG9ydC5zY3JvbGwuY3VycmVudDtcbiAgdmFyIGhvbWUgPSBjcml0aWNhbC5kcm9wcGFibGU7XG4gIHZhciBkcm9wcGFibGVzID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEFsbEJ5VHlwZShob21lLnR5cGUpLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuY2FsbGJhY2tzLmdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsKHdpbmRvd1Njcm9sbCwgc2Nyb2xsT3B0aW9ucyk7XG4gIH0pO1xuICB2YXIgZHJhZ2dhYmxlcyA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRBbGxCeVR5cGUoY3JpdGljYWwuZHJhZ2dhYmxlLnR5cGUpLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuZ2V0RGltZW5zaW9uKHdpbmRvd1Njcm9sbCk7XG4gIH0pO1xuICB2YXIgZGltZW5zaW9ucyA9IHtcbiAgICBkcmFnZ2FibGVzOiB0b0RyYWdnYWJsZU1hcChkcmFnZ2FibGVzKSxcbiAgICBkcm9wcGFibGVzOiB0b0Ryb3BwYWJsZU1hcChkcm9wcGFibGVzKVxuICB9O1xuICBmaW5pc2goKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgIGNyaXRpY2FsOiBjcml0aWNhbCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZW50cnkpIHtcbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnaW5nLmlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IudHlwZSAhPT0gZHJhZ2dpbmcudHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBob21lID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZCk7XG5cbiAgaWYgKGhvbWUuZGVzY3JpcHRvci5tb2RlICE9PSAndmlydHVhbCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgWW91IGFyZSBhdHRlbXB0aW5nIHRvIGFkZCBvciByZW1vdmUgYSBEcmFnZ2FibGUgW2lkOiBcIiArIGVudHJ5LmRlc2NyaXB0b3IuaWQgKyBcIl1cXG4gICAgICB3aGlsZSBhIGRyYWcgaXMgb2NjdXJyaW5nLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciB2aXJ0dWFsIGxpc3RzLlxcblxcbiAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvYmxvYi9tYXN0ZXIvZG9jcy9wYXR0ZXJucy92aXJ0dWFsLWxpc3RzLm1kXFxuICAgIFwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGNyZWF0ZURpbWVuc2lvbk1hcnNoYWwgPSAoZnVuY3Rpb24gKHJlZ2lzdHJ5LCBjYWxsYmFja3MpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBudWxsO1xuICB2YXIgcHVibGlzaGVyID0gY3JlYXRlUHVibGlzaGVyKHtcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIHB1Ymxpc2g6IGNhbGxiYWNrcy5wdWJsaXNoV2hpbGVEcmFnZ2luZyxcbiAgICAgIGNvbGxlY3Rpb25TdGFydGluZzogY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZ1xuICAgIH0sXG4gICAgcmVnaXN0cnk6IHJlZ2lzdHJ5XG4gIH0pO1xuXG4gIHZhciB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQgPSBmdW5jdGlvbiB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQoaWQsIGlzRW5hYmxlZCkge1xuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgdXBkYXRlIGlzIGVuYWJsZWQgZmxhZyBvZiBEcm9wcGFibGUgXCIgKyBpZCArIFwiIGFzIGl0IGlzIG5vdCByZWdpc3RlcmVkXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgaXNFbmFibGVkOiBpc0VuYWJsZWRcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCA9IGZ1bmN0aW9uIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQoaWQsIGlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IHVwZGF0ZSBpc0NvbWJpbmVFbmFibGVkIGZsYWcgb2YgRHJvcHBhYmxlIFwiICsgaWQgKyBcIiBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZDogaXNDb21iaW5lRW5hYmxlZFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciB1cGRhdGVEcm9wcGFibGVTY3JvbGwgPSBmdW5jdGlvbiB1cGRhdGVEcm9wcGFibGVTY3JvbGwoaWQsIG5ld1Njcm9sbCkge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgdXBkYXRlIHRoZSBzY3JvbGwgb24gRHJvcHBhYmxlIFwiICsgaWQgKyBcIiBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZVNjcm9sbCh7XG4gICAgICBpZDogaWQsXG4gICAgICBuZXdTY3JvbGw6IG5ld1Njcm9sbFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzY3JvbGxEcm9wcGFibGUgPSBmdW5jdGlvbiBzY3JvbGxEcm9wcGFibGUoaWQsIGNoYW5nZSkge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKS5jYWxsYmFja3Muc2Nyb2xsKGNoYW5nZSk7XG4gIH07XG5cbiAgdmFyIHN0b3BQdWJsaXNoaW5nID0gZnVuY3Rpb24gc3RvcFB1Ymxpc2hpbmcoKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHVibGlzaGVyLnN0b3AoKTtcbiAgICB2YXIgaG9tZSA9IGNvbGxlY3Rpb24uY3JpdGljYWwuZHJvcHBhYmxlO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LmNhbGxiYWNrcy5kcmFnU3RvcHBlZCgpO1xuICAgIH0pO1xuICAgIGNvbGxlY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICBjb2xsZWN0aW9uID0gbnVsbDtcbiAgfTtcblxuICB2YXIgc3Vic2NyaWJlciA9IGZ1bmN0aW9uIHN1YnNjcmliZXIoZXZlbnQpIHtcbiAgICAhY29sbGVjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBvbmx5IGJlIHN1YnNjcmliZWQgd2hlbiBhIGNvbGxlY3Rpb24gaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBkcmFnZ2luZyA9IGNvbGxlY3Rpb24uY3JpdGljYWwuZHJhZ2dhYmxlO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdBRERJVElPTicpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5hZGQoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAnUkVNT1ZBTCcpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5yZW1vdmUoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgc3RhcnRQdWJsaXNoaW5nID0gZnVuY3Rpb24gc3RhcnRQdWJsaXNoaW5nKHJlcXVlc3QpIHtcbiAgICAhIWNvbGxlY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgY2FwdHVyaW5nIGNyaXRpY2FsIGRpbWVuc2lvbnMgYXMgdGhlcmUgaXMgYWxyZWFkeSBhIGNvbGxlY3Rpb24nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQocmVxdWVzdC5kcmFnZ2FibGVJZCk7XG4gICAgdmFyIGhvbWUgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKTtcbiAgICB2YXIgY3JpdGljYWwgPSB7XG4gICAgICBkcmFnZ2FibGU6IGVudHJ5LmRlc2NyaXB0b3IsXG4gICAgICBkcm9wcGFibGU6IGhvbWUuZGVzY3JpcHRvclxuICAgIH07XG4gICAgdmFyIHVuc3Vic2NyaWJlID0gcmVnaXN0cnkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIGNvbGxlY3Rpb24gPSB7XG4gICAgICBjcml0aWNhbDogY3JpdGljYWwsXG4gICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICB9O1xuICAgIHJldHVybiBnZXRJbml0aWFsUHVibGlzaCh7XG4gICAgICBjcml0aWNhbDogY3JpdGljYWwsXG4gICAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgICBzY3JvbGxPcHRpb25zOiByZXF1ZXN0LnNjcm9sbE9wdGlvbnNcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbWFyc2hhbCA9IHtcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQ6IHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkOiB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIHNjcm9sbERyb3BwYWJsZTogc2Nyb2xsRHJvcHBhYmxlLFxuICAgIHVwZGF0ZURyb3BwYWJsZVNjcm9sbDogdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgIHN0YXJ0UHVibGlzaGluZzogc3RhcnRQdWJsaXNoaW5nLFxuICAgIHN0b3BQdWJsaXNoaW5nOiBzdG9wUHVibGlzaGluZ1xuICB9O1xuICByZXR1cm4gbWFyc2hhbDtcbn0pO1xuXG52YXIgY2FuU3RhcnREcmFnID0gKGZ1bmN0aW9uIChzdGF0ZSwgaWQpIHtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5waGFzZSAhPT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5jb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkID09PSBpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbiA9PT0gJ0RST1AnO1xufSk7XG5cbnZhciBzY3JvbGxXaW5kb3cgPSAoZnVuY3Rpb24gKGNoYW5nZSkge1xuICB3aW5kb3cuc2Nyb2xsQnkoY2hhbmdlLngsIGNoYW5nZS55KTtcbn0pO1xuXG52YXIgZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChkcm9wcGFibGVzKSB7XG4gIHJldHVybiB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICBpZiAoIWRyb3BwYWJsZS5pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWRyb3BwYWJsZS5mcmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn0pO1xuXG52YXIgZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIgPSBmdW5jdGlvbiBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3Zlcih0YXJnZXQsIGRyb3BwYWJsZXMpIHtcbiAgdmFyIG1heWJlID0gZmluZChnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyhkcm9wcGFibGVzKSwgZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgICFkcm9wcGFibGUuZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHJlc3VsdCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gaXNQb3NpdGlvbkluRnJhbWUoZHJvcHBhYmxlLmZyYW1lLnBhZ2VNYXJnaW5Cb3gpKHRhcmdldCk7XG4gIH0pO1xuICByZXR1cm4gbWF5YmU7XG59O1xuXG52YXIgZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgZHJvcHBhYmxlcyA9IF9yZWYuZHJvcHBhYmxlcztcblxuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICB2YXIgX2RpbWVuc2lvbiA9IGRyb3BwYWJsZXNbZGVzdGluYXRpb25dO1xuXG4gICAgaWYgKCFfZGltZW5zaW9uLmZyYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2RpbWVuc2lvbjtcbiAgfVxuXG4gIHZhciBkaW1lbnNpb24gPSBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlcihjZW50ZXIsIGRyb3BwYWJsZXMpO1xuICByZXR1cm4gZGltZW5zaW9uO1xufSk7XG5cbnZhciBjb25maWcgPSB7XG4gIHN0YXJ0RnJvbVBlcmNlbnRhZ2U6IDAuMjUsXG4gIG1heFNjcm9sbEF0UGVyY2VudGFnZTogMC4wNSxcbiAgbWF4UGl4ZWxTY3JvbGw6IDI4LFxuICBlYXNlOiBmdW5jdGlvbiBlYXNlKHBlcmNlbnRhZ2UpIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocGVyY2VudGFnZSwgMik7XG4gIH0sXG4gIGR1cmF0aW9uRGFtcGVuaW5nOiB7XG4gICAgc3RvcERhbXBlbmluZ0F0OiAxMjAwLFxuICAgIGFjY2VsZXJhdGVBdDogMzYwXG4gIH1cbn07XG5cbnZhciBnZXREaXN0YW5jZVRocmVzaG9sZHMgPSAoZnVuY3Rpb24gKGNvbnRhaW5lciwgYXhpcykge1xuICB2YXIgc3RhcnRTY3JvbGxpbmdGcm9tID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBjb25maWcuc3RhcnRGcm9tUGVyY2VudGFnZTtcbiAgdmFyIG1heFNjcm9sbFZhbHVlQXQgPSBjb250YWluZXJbYXhpcy5zaXplXSAqIGNvbmZpZy5tYXhTY3JvbGxBdFBlcmNlbnRhZ2U7XG4gIHZhciB0aHJlc2hvbGRzID0ge1xuICAgIHN0YXJ0U2Nyb2xsaW5nRnJvbTogc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIG1heFNjcm9sbFZhbHVlQXQ6IG1heFNjcm9sbFZhbHVlQXRcbiAgfTtcbiAgcmV0dXJuIHRocmVzaG9sZHM7XG59KTtcblxudmFyIGdldFBlcmNlbnRhZ2UgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN0YXJ0T2ZSYW5nZSA9IF9yZWYuc3RhcnRPZlJhbmdlLFxuICAgICAgZW5kT2ZSYW5nZSA9IF9yZWYuZW5kT2ZSYW5nZSxcbiAgICAgIGN1cnJlbnQgPSBfcmVmLmN1cnJlbnQ7XG4gIHZhciByYW5nZSA9IGVuZE9mUmFuZ2UgLSBzdGFydE9mUmFuZ2U7XG5cbiAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgIERldGVjdGVkIGRpc3RhbmNlIHJhbmdlIG9mIDAgaW4gdGhlIGZsdWlkIGF1dG8gc2Nyb2xsZXJcXG4gICAgICBUaGlzIGlzIHVuZXhwZWN0ZWQgYW5kIHdvdWxkIGNhdXNlIGEgZGl2aWRlIGJ5IDAgaXNzdWUuXFxuICAgICAgTm90IGFsbG93aW5nIGFuIGF1dG8gc2Nyb2xsXFxuICAgIFwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBjdXJyZW50SW5SYW5nZSA9IGN1cnJlbnQgLSBzdGFydE9mUmFuZ2U7XG4gIHZhciBwZXJjZW50YWdlID0gY3VycmVudEluUmFuZ2UgLyByYW5nZTtcbiAgcmV0dXJuIHBlcmNlbnRhZ2U7XG59KTtcblxudmFyIG1pblNjcm9sbCA9IDE7XG5cbnZhciBnZXRWYWx1ZUZyb21EaXN0YW5jZSA9IChmdW5jdGlvbiAoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMpIHtcbiAgaWYgKGRpc3RhbmNlVG9FZGdlID4gdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChkaXN0YW5jZVRvRWRnZSA8PSB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQpIHtcbiAgICByZXR1cm4gY29uZmlnLm1heFBpeGVsU2Nyb2xsO1xuICB9XG5cbiAgaWYgKGRpc3RhbmNlVG9FZGdlID09PSB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSkge1xuICAgIHJldHVybiBtaW5TY3JvbGw7XG4gIH1cblxuICB2YXIgcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0ID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQsXG4gICAgZW5kT2ZSYW5nZTogdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20sXG4gICAgY3VycmVudDogZGlzdGFuY2VUb0VkZ2VcbiAgfSk7XG4gIHZhciBwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSA9IDEgLSBwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQ7XG4gIHZhciBzY3JvbGwgPSBjb25maWcubWF4UGl4ZWxTY3JvbGwgKiBjb25maWcuZWFzZShwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn0pO1xuXG52YXIgYWNjZWxlcmF0ZUF0ID0gY29uZmlnLmR1cmF0aW9uRGFtcGVuaW5nLmFjY2VsZXJhdGVBdDtcbnZhciBzdG9wQXQgPSBjb25maWcuZHVyYXRpb25EYW1wZW5pbmcuc3RvcERhbXBlbmluZ0F0O1xudmFyIGRhbXBlblZhbHVlQnlUaW1lID0gKGZ1bmN0aW9uIChwcm9wb3NlZFNjcm9sbCwgZHJhZ1N0YXJ0VGltZSkge1xuICB2YXIgc3RhcnRPZlJhbmdlID0gZHJhZ1N0YXJ0VGltZTtcbiAgdmFyIGVuZE9mUmFuZ2UgPSBzdG9wQXQ7XG4gIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICB2YXIgcnVuVGltZSA9IG5vdyAtIHN0YXJ0T2ZSYW5nZTtcblxuICBpZiAocnVuVGltZSA+PSBzdG9wQXQpIHtcbiAgICByZXR1cm4gcHJvcG9zZWRTY3JvbGw7XG4gIH1cblxuICBpZiAocnVuVGltZSA8IGFjY2VsZXJhdGVBdCkge1xuICAgIHJldHVybiBtaW5TY3JvbGw7XG4gIH1cblxuICB2YXIgYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IGFjY2VsZXJhdGVBdCxcbiAgICBlbmRPZlJhbmdlOiBlbmRPZlJhbmdlLFxuICAgIGN1cnJlbnQ6IHJ1blRpbWVcbiAgfSk7XG4gIHZhciBzY3JvbGwgPSBwcm9wb3NlZFNjcm9sbCAqIGNvbmZpZy5lYXNlKGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufSk7XG5cbnZhciBnZXRWYWx1ZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZGlzdGFuY2VUb0VkZ2UgPSBfcmVmLmRpc3RhbmNlVG9FZGdlLFxuICAgICAgdGhyZXNob2xkcyA9IF9yZWYudGhyZXNob2xkcyxcbiAgICAgIGRyYWdTdGFydFRpbWUgPSBfcmVmLmRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nID0gX3JlZi5zaG91bGRVc2VUaW1lRGFtcGVuaW5nO1xuICB2YXIgc2Nyb2xsID0gZ2V0VmFsdWVGcm9tRGlzdGFuY2UoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMpO1xuXG4gIGlmIChzY3JvbGwgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICghc2hvdWxkVXNlVGltZURhbXBlbmluZykge1xuICAgIHJldHVybiBzY3JvbGw7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXgoZGFtcGVuVmFsdWVCeVRpbWUoc2Nyb2xsLCBkcmFnU3RhcnRUaW1lKSwgbWluU2Nyb2xsKTtcbn0pO1xuXG52YXIgZ2V0U2Nyb2xsT25BeGlzID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjb250YWluZXIgPSBfcmVmLmNvbnRhaW5lcixcbiAgICAgIGRpc3RhbmNlVG9FZGdlcyA9IF9yZWYuZGlzdGFuY2VUb0VkZ2VzLFxuICAgICAgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIGF4aXMgPSBfcmVmLmF4aXMsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nID0gX3JlZi5zaG91bGRVc2VUaW1lRGFtcGVuaW5nO1xuICB2YXIgdGhyZXNob2xkcyA9IGdldERpc3RhbmNlVGhyZXNob2xkcyhjb250YWluZXIsIGF4aXMpO1xuICB2YXIgaXNDbG9zZXJUb0VuZCA9IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0gPCBkaXN0YW5jZVRvRWRnZXNbYXhpcy5zdGFydF07XG5cbiAgaWYgKGlzQ2xvc2VyVG9FbmQpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUoe1xuICAgICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0sXG4gICAgICB0aHJlc2hvbGRzOiB0aHJlc2hvbGRzLFxuICAgICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAtMSAqIGdldFZhbHVlKHtcbiAgICBkaXN0YW5jZVRvRWRnZTogZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdLFxuICAgIHRocmVzaG9sZHM6IHRocmVzaG9sZHMsXG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gIH0pO1xufSk7XG5cbnZhciBhZGp1c3RGb3JTaXplTGltaXRzID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjb250YWluZXIgPSBfcmVmLmNvbnRhaW5lcixcbiAgICAgIHN1YmplY3QgPSBfcmVmLnN1YmplY3QsXG4gICAgICBwcm9wb3NlZFNjcm9sbCA9IF9yZWYucHJvcG9zZWRTY3JvbGw7XG4gIHZhciBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPSBzdWJqZWN0LmhlaWdodCA+IGNvbnRhaW5lci5oZWlnaHQ7XG4gIHZhciBpc1Rvb0JpZ0hvcml6b250YWxseSA9IHN1YmplY3Qud2lkdGggPiBjb250YWluZXIud2lkdGg7XG5cbiAgaWYgKCFpc1Rvb0JpZ0hvcml6b250YWxseSAmJiAhaXNUb29CaWdWZXJ0aWNhbGx5KSB7XG4gICAgcmV0dXJuIHByb3Bvc2VkU2Nyb2xsO1xuICB9XG5cbiAgaWYgKGlzVG9vQmlnSG9yaXpvbnRhbGx5ICYmIGlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBpc1Rvb0JpZ0hvcml6b250YWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC54LFxuICAgIHk6IGlzVG9vQmlnVmVydGljYWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC55XG4gIH07XG59KTtcblxudmFyIGNsZWFuJDIgPSBhcHBseShmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xufSk7XG52YXIgZ2V0U2Nyb2xsID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcmFnU3RhcnRUaW1lID0gX3JlZi5kcmFnU3RhcnRUaW1lLFxuICAgICAgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gX3JlZi5zdWJqZWN0LFxuICAgICAgY2VudGVyID0gX3JlZi5jZW50ZXIsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nID0gX3JlZi5zaG91bGRVc2VUaW1lRGFtcGVuaW5nO1xuICB2YXIgZGlzdGFuY2VUb0VkZ2VzID0ge1xuICAgIHRvcDogY2VudGVyLnkgLSBjb250YWluZXIudG9wLFxuICAgIHJpZ2h0OiBjb250YWluZXIucmlnaHQgLSBjZW50ZXIueCxcbiAgICBib3R0b206IGNvbnRhaW5lci5ib3R0b20gLSBjZW50ZXIueSxcbiAgICBsZWZ0OiBjZW50ZXIueCAtIGNvbnRhaW5lci5sZWZ0XG4gIH07XG4gIHZhciB5ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBkaXN0YW5jZVRvRWRnZXM6IGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lOiBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IHZlcnRpY2FsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgfSk7XG4gIHZhciB4ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBkaXN0YW5jZVRvRWRnZXM6IGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lOiBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IGhvcml6b250YWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICB9KTtcbiAgdmFyIHJlcXVpcmVkID0gY2xlYW4kMih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pO1xuXG4gIGlmIChpc0VxdWFsKHJlcXVpcmVkLCBvcmlnaW4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGltaXRlZCA9IGFkanVzdEZvclNpemVMaW1pdHMoe1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN1YmplY3Q6IHN1YmplY3QsXG4gICAgcHJvcG9zZWRTY3JvbGw6IHJlcXVpcmVkXG4gIH0pO1xuXG4gIGlmICghbGltaXRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGlzRXF1YWwobGltaXRlZCwgb3JpZ2luKSA/IG51bGwgOiBsaW1pdGVkO1xufSk7XG5cbnZhciBzbWFsbGVzdFNpZ25lZCA9IGFwcGx5KGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSA+IDAgPyAxIDogLTE7XG59KTtcbnZhciBnZXRPdmVybGFwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ2V0UmVtYWluZGVyID0gZnVuY3Rpb24gZ2V0UmVtYWluZGVyKHRhcmdldCwgbWF4KSB7XG4gICAgaWYgKHRhcmdldCA8IDApIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCA+IG1heCkge1xuICAgICAgcmV0dXJuIHRhcmdldCAtIG1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgY3VycmVudCA9IF9yZWYuY3VycmVudCxcbiAgICAgICAgbWF4ID0gX3JlZi5tYXgsXG4gICAgICAgIGNoYW5nZSA9IF9yZWYuY2hhbmdlO1xuICAgIHZhciB0YXJnZXRTY3JvbGwgPSBhZGQoY3VycmVudCwgY2hhbmdlKTtcbiAgICB2YXIgb3ZlcmxhcCA9IHtcbiAgICAgIHg6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueCwgbWF4LngpLFxuICAgICAgeTogZ2V0UmVtYWluZGVyKHRhcmdldFNjcm9sbC55LCBtYXgueSlcbiAgICB9O1xuXG4gICAgaWYgKGlzRXF1YWwob3ZlcmxhcCwgb3JpZ2luKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG92ZXJsYXA7XG4gIH07XG59KCk7XG52YXIgY2FuUGFydGlhbGx5U2Nyb2xsID0gZnVuY3Rpb24gY2FuUGFydGlhbGx5U2Nyb2xsKF9yZWYyKSB7XG4gIHZhciByYXdNYXggPSBfcmVmMi5tYXgsXG4gICAgICBjdXJyZW50ID0gX3JlZjIuY3VycmVudCxcbiAgICAgIGNoYW5nZSA9IF9yZWYyLmNoYW5nZTtcbiAgdmFyIG1heCA9IHtcbiAgICB4OiBNYXRoLm1heChjdXJyZW50LngsIHJhd01heC54KSxcbiAgICB5OiBNYXRoLm1heChjdXJyZW50LnksIHJhd01heC55KVxuICB9O1xuICB2YXIgc21hbGxlc3RDaGFuZ2UgPSBzbWFsbGVzdFNpZ25lZChjaGFuZ2UpO1xuICB2YXIgb3ZlcmxhcCA9IGdldE92ZXJsYXAoe1xuICAgIG1heDogbWF4LFxuICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgY2hhbmdlOiBzbWFsbGVzdENoYW5nZVxuICB9KTtcblxuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzbWFsbGVzdENoYW5nZS54ICE9PSAwICYmIG92ZXJsYXAueCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNtYWxsZXN0Q2hhbmdlLnkgIT09IDAgJiYgb3ZlcmxhcC55ID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGNhblNjcm9sbFdpbmRvdyA9IGZ1bmN0aW9uIGNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSB7XG4gIHJldHVybiBjYW5QYXJ0aWFsbHlTY3JvbGwoe1xuICAgIGN1cnJlbnQ6IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LFxuICAgIG1heDogdmlld3BvcnQuc2Nyb2xsLm1heCxcbiAgICBjaGFuZ2U6IGNoYW5nZVxuICB9KTtcbn07XG52YXIgZ2V0V2luZG93T3ZlcmxhcCA9IGZ1bmN0aW9uIGdldFdpbmRvd092ZXJsYXAodmlld3BvcnQsIGNoYW5nZSkge1xuICBpZiAoIWNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heCA9IHZpZXdwb3J0LnNjcm9sbC5tYXg7XG4gIHZhciBjdXJyZW50ID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgIG1heDogbWF4LFxuICAgIGNoYW5nZTogY2hhbmdlXG4gIH0pO1xufTtcbnZhciBjYW5TY3JvbGxEcm9wcGFibGUgPSBmdW5jdGlvbiBjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpIHtcbiAgdmFyIGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuXG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2FuUGFydGlhbGx5U2Nyb2xsKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlOiBjaGFuZ2VcbiAgfSk7XG59O1xudmFyIGdldERyb3BwYWJsZU92ZXJsYXAgPSBmdW5jdGlvbiBnZXREcm9wcGFibGVPdmVybGFwKGRyb3BwYWJsZSwgY2hhbmdlKSB7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlOiBjaGFuZ2VcbiAgfSk7XG59O1xuXG52YXIgZ2V0V2luZG93U2Nyb2xsQ2hhbmdlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBzdWJqZWN0ID0gX3JlZi5zdWJqZWN0LFxuICAgICAgY2VudGVyID0gX3JlZi5jZW50ZXIsXG4gICAgICBkcmFnU3RhcnRUaW1lID0gX3JlZi5kcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZztcbiAgdmFyIHNjcm9sbCA9IGdldFNjcm9sbCh7XG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHN1YmplY3Q6IHN1YmplY3QsXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICB9KTtcbiAgcmV0dXJuIHNjcm9sbCAmJiBjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufSk7XG5cbnZhciBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2UgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRyb3BwYWJsZSA9IF9yZWYuZHJvcHBhYmxlLFxuICAgICAgc3ViamVjdCA9IF9yZWYuc3ViamVjdCxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcgPSBfcmVmLnNob3VsZFVzZVRpbWVEYW1wZW5pbmc7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2Nyb2xsID0gZ2V0U2Nyb2xsKHtcbiAgICBkcmFnU3RhcnRUaW1lOiBkcmFnU3RhcnRUaW1lLFxuICAgIGNvbnRhaW5lcjogZnJhbWUucGFnZU1hcmdpbkJveCxcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgc2Nyb2xsKSA/IHNjcm9sbCA6IG51bGw7XG59KTtcblxudmFyIHNjcm9sbCQxID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBkcmFnU3RhcnRUaW1lID0gX3JlZi5kcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIHNjcm9sbFdpbmRvdyA9IF9yZWYuc2Nyb2xsV2luZG93LFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlID0gX3JlZi5zY3JvbGxEcm9wcGFibGU7XG4gIHZhciBjZW50ZXIgPSBzdGF0ZS5jdXJyZW50LnBhZ2UuYm9yZGVyQm94Q2VudGVyO1xuICB2YXIgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIHZhciBzdWJqZWN0ID0gZHJhZ2dhYmxlLnBhZ2UubWFyZ2luQm94O1xuXG4gIGlmIChzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQpIHtcbiAgICB2YXIgdmlld3BvcnQgPSBzdGF0ZS52aWV3cG9ydDtcblxuICAgIHZhciBfY2hhbmdlID0gZ2V0V2luZG93U2Nyb2xsQ2hhbmdlKHtcbiAgICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gICAgfSk7XG5cbiAgICBpZiAoX2NoYW5nZSkge1xuICAgICAgc2Nyb2xsV2luZG93KF9jaGFuZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkcm9wcGFibGUgPSBnZXRCZXN0U2Nyb2xsYWJsZURyb3BwYWJsZSh7XG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgZGVzdGluYXRpb246IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCksXG4gICAgZHJvcHBhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzXG4gIH0pO1xuXG4gIGlmICghZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoYW5nZSA9IGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSh7XG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBkcm9wcGFibGU6IGRyb3BwYWJsZSxcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgfSk7XG5cbiAgaWYgKGNoYW5nZSkge1xuICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgfVxufSk7XG5cbnZhciBjcmVhdGVGbHVpZFNjcm9sbGVyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzY3JvbGxXaW5kb3cgPSBfcmVmLnNjcm9sbFdpbmRvdyxcbiAgICAgIHNjcm9sbERyb3BwYWJsZSA9IF9yZWYuc2Nyb2xsRHJvcHBhYmxlO1xuICB2YXIgc2NoZWR1bGVXaW5kb3dTY3JvbGwgPSByYWZTY2hkKHNjcm9sbFdpbmRvdyk7XG4gIHZhciBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCA9IHJhZlNjaGQoc2Nyb2xsRHJvcHBhYmxlKTtcbiAgdmFyIGRyYWdnaW5nID0gbnVsbDtcblxuICB2YXIgdHJ5U2Nyb2xsID0gZnVuY3Rpb24gdHJ5U2Nyb2xsKHN0YXRlKSB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZsdWlkIHNjcm9sbCBpZiBub3QgZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9kcmFnZ2luZyA9IGRyYWdnaW5nLFxuICAgICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nID0gX2RyYWdnaW5nLnNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICAgIGRyYWdTdGFydFRpbWUgPSBfZHJhZ2dpbmcuZHJhZ1N0YXJ0VGltZTtcbiAgICBzY3JvbGwkMSh7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzY3JvbGxXaW5kb3c6IHNjaGVkdWxlV2luZG93U2Nyb2xsLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCxcbiAgICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHN0YXJ0JDEgPSBmdW5jdGlvbiBzdGFydCQxKHN0YXRlKSB7XG4gICAgc3RhcnQoKTtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGF1dG8gc2Nyb2xsaW5nIHdoZW4gYWxyZWFkeSBzdGFydGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBkcmFnU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgd2FzU2Nyb2xsTmVlZGVkID0gZmFsc2U7XG5cbiAgICB2YXIgZmFrZVNjcm9sbENhbGxiYWNrID0gZnVuY3Rpb24gZmFrZVNjcm9sbENhbGxiYWNrKCkge1xuICAgICAgd2FzU2Nyb2xsTmVlZGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2Nyb2xsJDEoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgZHJhZ1N0YXJ0VGltZTogMCxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IGZhbHNlLFxuICAgICAgc2Nyb2xsV2luZG93OiBmYWtlU2Nyb2xsQ2FsbGJhY2ssXG4gICAgICBzY3JvbGxEcm9wcGFibGU6IGZha2VTY3JvbGxDYWxsYmFja1xuICAgIH0pO1xuICAgIGRyYWdnaW5nID0ge1xuICAgICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHdhc1Njcm9sbE5lZWRlZFxuICAgIH07XG4gICAgZmluaXNoKCk7XG5cbiAgICBpZiAod2FzU2Nyb2xsTmVlZGVkKSB7XG4gICAgICB0cnlTY3JvbGwoc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlV2luZG93U2Nyb2xsLmNhbmNlbCgpO1xuICAgIHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsLmNhbmNlbCgpO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCQxLFxuICAgIHN0b3A6IHN0b3AsXG4gICAgc2Nyb2xsOiB0cnlTY3JvbGxcbiAgfTtcbn0pO1xuXG52YXIgY3JlYXRlSnVtcFNjcm9sbGVyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBtb3ZlID0gX3JlZi5tb3ZlLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlID0gX3JlZi5zY3JvbGxEcm9wcGFibGUsXG4gICAgICBzY3JvbGxXaW5kb3cgPSBfcmVmLnNjcm9sbFdpbmRvdztcblxuICB2YXIgbW92ZUJ5T2Zmc2V0ID0gZnVuY3Rpb24gbW92ZUJ5T2Zmc2V0KHN0YXRlLCBvZmZzZXQpIHtcbiAgICB2YXIgY2xpZW50ID0gYWRkKHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbiwgb2Zmc2V0KTtcbiAgICBtb3ZlKHtcbiAgICAgIGNsaWVudDogY2xpZW50XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4gPSBmdW5jdGlvbiBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuKGRyb3BwYWJsZSwgY2hhbmdlKSB7XG4gICAgaWYgKCFjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cblxuICAgIHZhciBvdmVybGFwID0gZ2V0RHJvcHBhYmxlT3ZlcmxhcChkcm9wcGFibGUsIGNoYW5nZSk7XG5cbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsID0gc3VidHJhY3QoY2hhbmdlLCBvdmVybGFwKTtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIHZhciByZW1haW5kZXIgPSBzdWJ0cmFjdChjaGFuZ2UsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIHJldHVybiByZW1haW5kZXI7XG4gIH07XG5cbiAgdmFyIHNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4gPSBmdW5jdGlvbiBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuKGlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGNoYW5nZSkge1xuICAgIGlmICghaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cblxuICAgIGlmICghY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBjaGFuZ2UpKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cblxuICAgIHZhciBvdmVybGFwID0gZ2V0V2luZG93T3ZlcmxhcCh2aWV3cG9ydCwgY2hhbmdlKTtcblxuICAgIGlmICghb3ZlcmxhcCkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsV2luZG93KHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIHZhciByZW1haW5kZXIgPSBzdWJ0cmFjdChjaGFuZ2UsIHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIHJldHVybiByZW1haW5kZXI7XG4gIH07XG5cbiAgdmFyIGp1bXBTY3JvbGxlciA9IGZ1bmN0aW9uIGp1bXBTY3JvbGxlcihzdGF0ZSkge1xuICAgIHZhciByZXF1ZXN0ID0gc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3Q7XG5cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVzdGluYXRpb24gPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICFkZXN0aW5hdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwZXJmb3JtIGEganVtcCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkZXN0aW5hdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZHJvcHBhYmxlUmVtYWluZGVyID0gc2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbihzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbZGVzdGluYXRpb25dLCByZXF1ZXN0KTtcblxuICAgIGlmICghZHJvcHBhYmxlUmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZpZXdwb3J0ID0gc3RhdGUudmlld3BvcnQ7XG4gICAgdmFyIHdpbmRvd1JlbWFpbmRlciA9IHNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4oc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkLCB2aWV3cG9ydCwgZHJvcHBhYmxlUmVtYWluZGVyKTtcblxuICAgIGlmICghd2luZG93UmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW92ZUJ5T2Zmc2V0KHN0YXRlLCB3aW5kb3dSZW1haW5kZXIpO1xuICB9O1xuXG4gIHJldHVybiBqdW1wU2Nyb2xsZXI7XG59KTtcblxudmFyIGNyZWF0ZUF1dG9TY3JvbGxlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc2Nyb2xsRHJvcHBhYmxlID0gX3JlZi5zY3JvbGxEcm9wcGFibGUsXG4gICAgICBzY3JvbGxXaW5kb3cgPSBfcmVmLnNjcm9sbFdpbmRvdyxcbiAgICAgIG1vdmUgPSBfcmVmLm1vdmU7XG4gIHZhciBmbHVpZFNjcm9sbGVyID0gY3JlYXRlRmx1aWRTY3JvbGxlcih7XG4gICAgc2Nyb2xsV2luZG93OiBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlOiBzY3JvbGxEcm9wcGFibGVcbiAgfSk7XG4gIHZhciBqdW1wU2Nyb2xsID0gY3JlYXRlSnVtcFNjcm9sbGVyKHtcbiAgICBtb3ZlOiBtb3ZlLFxuICAgIHNjcm9sbFdpbmRvdzogc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZTogc2Nyb2xsRHJvcHBhYmxlXG4gIH0pO1xuXG4gIHZhciBzY3JvbGwgPSBmdW5jdGlvbiBzY3JvbGwoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnRkxVSUQnKSB7XG4gICAgICBmbHVpZFNjcm9sbGVyLnNjcm9sbChzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5zY3JvbGxKdW1wUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGp1bXBTY3JvbGwoc3RhdGUpO1xuICB9O1xuXG4gIHZhciBzY3JvbGxlciA9IHtcbiAgICBzY3JvbGw6IHNjcm9sbCxcbiAgICBzdGFydDogZmx1aWRTY3JvbGxlci5zdGFydCxcbiAgICBzdG9wOiBmbHVpZFNjcm9sbGVyLnN0b3BcbiAgfTtcbiAgcmV0dXJuIHNjcm9sbGVyO1xufSk7XG5cbnZhciBwcmVmaXgkMSA9ICdkYXRhLXJiZCc7XG52YXIgZHJhZ0hhbmRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhc2UgPSBwcmVmaXgkMSArIFwiLWRyYWctaGFuZGxlXCI7XG4gIHJldHVybiB7XG4gICAgYmFzZTogYmFzZSxcbiAgICBkcmFnZ2FibGVJZDogYmFzZSArIFwiLWRyYWdnYWJsZS1pZFwiLFxuICAgIGNvbnRleHRJZDogYmFzZSArIFwiLWNvbnRleHQtaWRcIlxuICB9O1xufSgpO1xudmFyIGRyYWdnYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhc2UgPSBwcmVmaXgkMSArIFwiLWRyYWdnYWJsZVwiO1xuICByZXR1cm4ge1xuICAgIGJhc2U6IGJhc2UsXG4gICAgY29udGV4dElkOiBiYXNlICsgXCItY29udGV4dC1pZFwiLFxuICAgIGlkOiBiYXNlICsgXCItaWRcIlxuICB9O1xufSgpO1xudmFyIGRyb3BwYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhc2UgPSBwcmVmaXgkMSArIFwiLWRyb3BwYWJsZVwiO1xuICByZXR1cm4ge1xuICAgIGJhc2U6IGJhc2UsXG4gICAgY29udGV4dElkOiBiYXNlICsgXCItY29udGV4dC1pZFwiLFxuICAgIGlkOiBiYXNlICsgXCItaWRcIlxuICB9O1xufSgpO1xudmFyIHNjcm9sbENvbnRhaW5lciA9IHtcbiAgY29udGV4dElkOiBwcmVmaXgkMSArIFwiLXNjcm9sbC1jb250YWluZXItY29udGV4dC1pZFwiXG59O1xuXG52YXIgbWFrZUdldFNlbGVjdG9yID0gZnVuY3Rpb24gbWFrZUdldFNlbGVjdG9yKGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gXCJbXCIgKyBhdHRyaWJ1dGUgKyBcIj1cXFwiXCIgKyBjb250ZXh0ICsgXCJcXFwiXVwiO1xuICB9O1xufTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIGdldFN0eWxlcyhydWxlcywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIHJ1bGVzLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgIHZhciB2YWx1ZSA9IHJ1bGUuc3R5bGVzW3Byb3BlcnR5XTtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZS5zZWxlY3RvciArIFwiIHsgXCIgKyB2YWx1ZSArIFwiIH1cIjtcbiAgfSkuam9pbignICcpO1xufTtcblxudmFyIG5vUG9pbnRlckV2ZW50cyA9ICdwb2ludGVyLWV2ZW50czogbm9uZTsnO1xudmFyIGdldFN0eWxlcyQxID0gKGZ1bmN0aW9uIChjb250ZXh0SWQpIHtcbiAgdmFyIGdldFNlbGVjdG9yID0gbWFrZUdldFNlbGVjdG9yKGNvbnRleHRJZCk7XG5cbiAgdmFyIGRyYWdIYW5kbGUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3JhYkN1cnNvciA9IFwiXFxuICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XFxuICAgICAgY3Vyc29yOiBncmFiO1xcbiAgICBcIjtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdIYW5kbGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBhbHdheXM6IFwiXFxuICAgICAgICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApO1xcbiAgICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcXG4gICAgICAgIFwiLFxuICAgICAgICByZXN0aW5nOiBncmFiQ3Vyc29yLFxuICAgICAgICBkcmFnZ2luZzogbm9Qb2ludGVyRXZlbnRzLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiBncmFiQ3Vyc29yXG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBkcmFnZ2FibGUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IFwiXFxuICAgICAgdHJhbnNpdGlvbjogXCIgKyB0cmFuc2l0aW9ucy5vdXRPZlRoZVdheSArIFwiO1xcbiAgICBcIjtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdnYWJsZS5jb250ZXh0SWQpLFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIGRyYWdnaW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICB1c2VyQ2FuY2VsOiB0cmFuc2l0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBkcm9wcGFibGUkMSA9IHtcbiAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJvcHBhYmxlLmNvbnRleHRJZCksXG4gICAgc3R5bGVzOiB7XG4gICAgICBhbHdheXM6IFwib3ZlcmZsb3ctYW5jaG9yOiBub25lO1wiXG4gICAgfVxuICB9O1xuICB2YXIgYm9keSA9IHtcbiAgICBzZWxlY3RvcjogJ2JvZHknLFxuICAgIHN0eWxlczoge1xuICAgICAgZHJhZ2dpbmc6IFwiXFxuICAgICAgICBjdXJzb3I6IGdyYWJiaW5nO1xcbiAgICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgIG92ZXJmbG93LWFuY2hvcjogbm9uZTtcXG4gICAgICBcIlxuICAgIH1cbiAgfTtcbiAgdmFyIHJ1bGVzID0gW2RyYWdnYWJsZSQxLCBkcmFnSGFuZGxlJDEsIGRyb3BwYWJsZSQxLCBib2R5XTtcbiAgcmV0dXJuIHtcbiAgICBhbHdheXM6IGdldFN0eWxlcyhydWxlcywgJ2Fsd2F5cycpLFxuICAgIHJlc3Rpbmc6IGdldFN0eWxlcyhydWxlcywgJ3Jlc3RpbmcnKSxcbiAgICBkcmFnZ2luZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJhZ2dpbmcnKSxcbiAgICBkcm9wQW5pbWF0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdkcm9wQW5pbWF0aW5nJyksXG4gICAgdXNlckNhbmNlbDogZ2V0U3R5bGVzKHJ1bGVzLCAndXNlckNhbmNlbCcpXG4gIH07XG59KTtcblxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG52YXIgZ2V0SGVhZCA9IGZ1bmN0aW9uIGdldEhlYWQoKSB7XG4gIHZhciBoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xuICAhaGVhZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIHRoZSBoZWFkIHRvIGFwcGVuZCBhIHN0eWxlIHRvJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gaGVhZDtcbn07XG5cbnZhciBjcmVhdGVTdHlsZUVsID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVFbChub25jZSkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gIGlmIChub25jZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cblxuICBlbC50eXBlID0gJ3RleHQvY3NzJztcbiAgcmV0dXJuIGVsO1xufTtcblxuZnVuY3Rpb24gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpIHtcbiAgdmFyIHN0eWxlcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRTdHlsZXMkMShjb250ZXh0SWQpO1xuICB9LCBbY29udGV4dElkXSk7XG4gIHZhciBhbHdheXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBkeW5hbWljUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc2V0RHluYW1pY1N0eWxlID0gdXNlQ2FsbGJhY2sobWVtb2l6ZU9uZShmdW5jdGlvbiAocHJvcG9zZWQpIHtcbiAgICB2YXIgZWwgPSBkeW5hbWljUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9KSwgW10pO1xuICB2YXIgc2V0QWx3YXlzU3R5bGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocHJvcG9zZWQpIHtcbiAgICB2YXIgZWwgPSBhbHdheXNSZWYuY3VycmVudDtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2V0IGR5bmFtaWMgc3R5bGUgZWxlbWVudCBpZiBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGVsLnRleHRDb250ZW50ID0gcHJvcG9zZWQ7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgISghYWx3YXlzUmVmLmN1cnJlbnQgJiYgIWR5bmFtaWNSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdzdHlsZSBlbGVtZW50cyBhbHJlYWR5IG1vdW50ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGFsd2F5cyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIHZhciBkeW5hbWljID0gY3JlYXRlU3R5bGVFbChub25jZSk7XG4gICAgYWx3YXlzUmVmLmN1cnJlbnQgPSBhbHdheXM7XG4gICAgZHluYW1pY1JlZi5jdXJyZW50ID0gZHluYW1pYztcbiAgICBhbHdheXMuc2V0QXR0cmlidXRlKHByZWZpeCQxICsgXCItYWx3YXlzXCIsIGNvbnRleHRJZCk7XG4gICAgZHluYW1pYy5zZXRBdHRyaWJ1dGUocHJlZml4JDEgKyBcIi1keW5hbWljXCIsIGNvbnRleHRJZCk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGFsd2F5cyk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGR5bmFtaWMpO1xuICAgIHNldEFsd2F5c1N0eWxlKHN0eWxlcy5hbHdheXMpO1xuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICFjdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHVubW91bnQgcmVmIGFzIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIGdldEhlYWQoKS5yZW1vdmVDaGlsZChjdXJyZW50KTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgcmVtb3ZlKGFsd2F5c1JlZik7XG4gICAgICByZW1vdmUoZHluYW1pY1JlZik7XG4gICAgfTtcbiAgfSwgW25vbmNlLCBzZXRBbHdheXNTdHlsZSwgc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuYWx3YXlzLCBzdHlsZXMucmVzdGluZywgY29udGV4dElkXSk7XG4gIHZhciBkcmFnZ2luZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcmFnZ2luZyk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5kcmFnZ2luZ10pO1xuICB2YXIgZHJvcHBpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKHJlYXNvbiA9PT0gJ0RST1AnKSB7XG4gICAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLmRyb3BBbmltYXRpbmcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMudXNlckNhbmNlbCk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5kcm9wQW5pbWF0aW5nLCBzdHlsZXMudXNlckNhbmNlbF0pO1xuICB2YXIgcmVzdGluZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWR5bmFtaWNSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5yZXN0aW5nXSk7XG4gIHZhciBtYXJzaGFsID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRyYWdnaW5nOiBkcmFnZ2luZyxcbiAgICAgIGRyb3BwaW5nOiBkcm9wcGluZyxcbiAgICAgIHJlc3Rpbmc6IHJlc3RpbmdcbiAgICB9O1xuICB9LCBbZHJhZ2dpbmcsIGRyb3BwaW5nLCByZXN0aW5nXSk7XG4gIHJldHVybiBtYXJzaGFsO1xufVxuXG52YXIgZ2V0V2luZG93RnJvbUVsID0gKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZWwgJiYgZWwub3duZXJEb2N1bWVudCA/IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59KTtcblxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIGRyYWdnYWJsZUlkKSB7XG4gIHZhciBzZWxlY3RvciA9IFwiW1wiICsgZHJhZ0hhbmRsZS5jb250ZXh0SWQgKyBcIj1cXFwiXCIgKyBjb250ZXh0SWQgKyBcIlxcXCJdXCI7XG4gIHZhciBwb3NzaWJsZSA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuXG4gIGlmICghcG9zc2libGUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlVuYWJsZSB0byBmaW5kIGFueSBkcmFnIGhhbmRsZXMgaW4gdGhlIGNvbnRleHQgXFxcIlwiICsgY29udGV4dElkICsgXCJcXFwiXCIpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGhhbmRsZSA9IGZpbmQocG9zc2libGUsIGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCkgPT09IGRyYWdnYWJsZUlkO1xuICB9KTtcblxuICBpZiAoIWhhbmRsZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJVbmFibGUgdG8gZmluZCBkcmFnIGhhbmRsZSB3aXRoIGlkIFxcXCJcIiArIGRyYWdnYWJsZUlkICsgXCJcXFwiIGFzIG5vIGhhbmRsZSB3aXRoIGEgbWF0Y2hpbmcgaWQgd2FzIGZvdW5kXCIpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGhhbmRsZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdkcmFnIGhhbmRsZSBuZWVkcyB0byBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiB1c2VGb2N1c01hcnNoYWwoY29udGV4dElkKSB7XG4gIHZhciBlbnRyaWVzUmVmID0gdXNlUmVmKHt9KTtcbiAgdmFyIHJlY29yZFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHJlc3RvcmVGb2N1c0ZyYW1lUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIHJlZ2lzdGVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gcmVnaXN0ZXIoaWQsIGZvY3VzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgZm9jdXM6IGZvY3VzXG4gICAgfTtcbiAgICBlbnRyaWVzUmVmLmN1cnJlbnRbaWRdID0gZW50cnk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSB7XG4gICAgICB2YXIgZW50cmllcyA9IGVudHJpZXNSZWYuY3VycmVudDtcbiAgICAgIHZhciBjdXJyZW50ID0gZW50cmllc1tpZF07XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBlbnRyeSkge1xuICAgICAgICBkZWxldGUgZW50cmllc1tpZF07XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgdHJ5R2l2ZUZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5R2l2ZUZvY3VzKHRyeUdpdmVGb2N1c1RvKSB7XG4gICAgdmFyIGhhbmRsZSA9IGZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgdHJ5R2l2ZUZvY3VzVG8pO1xuXG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGhhbmRsZS5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2NvbnRleHRJZF0pO1xuICB2YXIgdHJ5U2hpZnRSZWNvcmQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlTaGlmdFJlY29yZChwcmV2aW91cywgcmVkaXJlY3RUbykge1xuICAgIGlmIChyZWNvcmRSZWYuY3VycmVudCA9PT0gcHJldmlvdXMpIHtcbiAgICAgIHJlY29yZFJlZi5jdXJyZW50ID0gcmVkaXJlY3RUbztcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKSB7XG4gICAgaWYgKHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHZhciByZWNvcmQgPSByZWNvcmRSZWYuY3VycmVudDtcblxuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICB0cnlHaXZlRm9jdXMocmVjb3JkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3RyeUdpdmVGb2N1c10pO1xuICB2YXIgdHJ5UmVjb3JkRm9jdXMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlSZWNvcmRGb2N1cyhpZCkge1xuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB2YXIgZm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZm9jdXNlZC5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCkgIT09IGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBpZDtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyRnJhbWVPblVubW91bnQoKSB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgdmFyIGZyYW1lSWQgPSByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHZhciBtYXJzaGFsID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVyOiByZWdpc3RlcixcbiAgICAgIHRyeVJlY29yZEZvY3VzOiB0cnlSZWNvcmRGb2N1cyxcbiAgICAgIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkOiB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCxcbiAgICAgIHRyeVNoaWZ0UmVjb3JkOiB0cnlTaGlmdFJlY29yZFxuICAgIH07XG4gIH0sIFtyZWdpc3RlciwgdHJ5UmVjb3JkRm9jdXMsIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkLCB0cnlTaGlmdFJlY29yZF0pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnaXN0cnkoKSB7XG4gIHZhciBlbnRyaWVzID0ge1xuICAgIGRyYWdnYWJsZXM6IHt9LFxuICAgIGRyb3BwYWJsZXM6IHt9XG4gIH07XG4gIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYikge1xuICAgIHN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIHZhciBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2IpO1xuXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCkge1xuICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREcmFnZ2FibGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGVudHJpZXMuZHJhZ2dhYmxlc1tpZF0gfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kRHJhZ2dhYmxlQnlJZChpZCk7XG4gICAgIWVudHJ5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBmaW5kIGRyYWdnYWJsZSBlbnRyeSB3aXRoIGlkIFtcIiArIGlkICsgXCJdXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cblxuICB2YXIgZHJhZ2dhYmxlQVBJID0ge1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihlbnRyeSkge1xuICAgICAgZW50cmllcy5kcmFnZ2FibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgICBub3RpZnkoe1xuICAgICAgICB0eXBlOiAnQURESVRJT04nLFxuICAgICAgICB2YWx1ZTogZW50cnlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZW50cnksIGxhc3QpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50LnVuaXF1ZUlkICE9PSBlbnRyeS51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyYWdnYWJsZXNbbGFzdC5kZXNjcmlwdG9yLmlkXTtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gdW5yZWdpc3RlcihlbnRyeSkge1xuICAgICAgdmFyIGRyYWdnYWJsZUlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICAgIHZhciBjdXJyZW50ID0gZmluZERyYWdnYWJsZUJ5SWQoZHJhZ2dhYmxlSWQpO1xuXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW50cnkudW5pcXVlSWQgIT09IGN1cnJlbnQudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2RyYWdnYWJsZUlkXTtcbiAgICAgIG5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdSRU1PVkFMJyxcbiAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEJ5SWQ6IGdldERyYWdnYWJsZUJ5SWQsXG4gICAgZmluZEJ5SWQ6IGZpbmREcmFnZ2FibGVCeUlkLFxuICAgIGV4aXN0czogZnVuY3Rpb24gZXhpc3RzKGlkKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihmaW5kRHJhZ2dhYmxlQnlJZChpZCkpO1xuICAgIH0sXG4gICAgZ2V0QWxsQnlUeXBlOiBmdW5jdGlvbiBnZXRBbGxCeVR5cGUodHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlcyhlbnRyaWVzLmRyYWdnYWJsZXMpLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LmRlc2NyaXB0b3IudHlwZSA9PT0gdHlwZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kRHJvcHBhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyb3BwYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREcm9wcGFibGVCeUlkKGlkKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZERyb3BwYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgZmluZCBkcm9wcGFibGUgZW50cnkgd2l0aCBpZCBbXCIgKyBpZCArIFwiXVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgdmFyIGRyb3BwYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZW50cnkpIHtcbiAgICAgIGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gdW5yZWdpc3RlcihlbnRyeSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaW5kRHJvcHBhYmxlQnlJZChlbnRyeS5kZXNjcmlwdG9yLmlkKTtcblxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXTtcbiAgICB9LFxuICAgIGdldEJ5SWQ6IGdldERyb3BwYWJsZUJ5SWQsXG4gICAgZmluZEJ5SWQ6IGZpbmREcm9wcGFibGVCeUlkLFxuICAgIGV4aXN0czogZnVuY3Rpb24gZXhpc3RzKGlkKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihmaW5kRHJvcHBhYmxlQnlJZChpZCkpO1xuICAgIH0sXG4gICAgZ2V0QWxsQnlUeXBlOiBmdW5jdGlvbiBnZXRBbGxCeVR5cGUodHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlcyhlbnRyaWVzLmRyb3BwYWJsZXMpLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LmRlc2NyaXB0b3IudHlwZSA9PT0gdHlwZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICBlbnRyaWVzLmRyYWdnYWJsZXMgPSB7fTtcbiAgICBlbnRyaWVzLmRyb3BwYWJsZXMgPSB7fTtcbiAgICBzdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZUFQSSxcbiAgICBkcm9wcGFibGU6IGRyb3BwYWJsZUFQSSxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBjbGVhbjogY2xlYW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUmVnaXN0cnkoKSB7XG4gIHZhciByZWdpc3RyeSA9IHVzZU1lbW8oY3JlYXRlUmVnaXN0cnksIFtdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZWdpc3RyeS5jbGVhbik7XG4gICAgfTtcbiAgfSwgW3JlZ2lzdHJ5XSk7XG4gIHJldHVybiByZWdpc3RyeTtcbn1cblxudmFyIFN0b3JlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBnZXRCb2R5RWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgIWJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5ib2R5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gYm9keTtcbn0pO1xuXG52YXIgdmlzdWFsbHlIaWRkZW4gPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB3aWR0aDogJzFweCcsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBib3JkZXI6ICcwJyxcbiAgcGFkZGluZzogJzAnLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgJ2NsaXAtcGF0aCc6ICdpbnNldCgxMDAlKSdcbn07XG5cbnZhciBnZXRJZCA9IGZ1bmN0aW9uIGdldElkKGNvbnRleHRJZCkge1xuICByZXR1cm4gXCJyYmQtYW5ub3VuY2VtZW50LVwiICsgY29udGV4dElkO1xufTtcbmZ1bmN0aW9uIHVzZUFubm91bmNlcihjb250ZXh0SWQpIHtcbiAgdmFyIGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldElkKGNvbnRleHRJZCk7XG4gIH0sIFtjb250ZXh0SWRdKTtcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJlZi5jdXJyZW50ID0gZWw7XG4gICAgZWwuaWQgPSBpZDtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXRvbWljJywgJ3RydWUnKTtcblxuICAgIF9leHRlbmRzKGVsLnN0eWxlLCB2aXN1YWxseUhpZGRlbik7XG5cbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICB2YXIgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG5cbiAgICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwgPT09IHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbaWRdKTtcbiAgdmFyIGFubm91bmNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB2YXIgZWwgPSByZWYuY3VycmVudDtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICBBIHNjcmVlbiByZWFkZXIgbWVzc2FnZSB3YXMgdHJ5aW5nIHRvIGJlIGFubm91bmNlZCBidXQgaXQgd2FzIHVuYWJsZSB0byBkbyBzby5cXG4gICAgICBUaGlzIGNhbiBvY2N1ciBpZiB5b3UgdW5tb3VudCB5b3VyIDxEcmFnRHJvcENvbnRleHQgLz4gaW4geW91ciBvbkRyYWdFbmQuXFxuICAgICAgQ29uc2lkZXIgY2FsbGluZyBwcm92aWRlZC5hbm5vdW5jZSgpIGJlZm9yZSB0aGUgdW5tb3VudCBzbyB0aGF0IHRoZSBpbnN0cnVjdGlvbiB3aWxsXFxuICAgICAgbm90IGJlIGxvc3QgZm9yIHVzZXJzIHJlbHlpbmcgb24gYSBzY3JlZW4gcmVhZGVyLlxcblxcbiAgICAgIE1lc3NhZ2Ugbm90IHBhc3NlZCB0byBzY3JlZW4gcmVhZGVyOlxcblxcbiAgICAgIFxcXCJcIiArIG1lc3NhZ2UgKyBcIlxcXCJcXG4gICAgXCIpIDogdm9pZCAwO1xuICB9LCBbXSk7XG4gIHJldHVybiBhbm5vdW5jZTtcbn1cblxudmFyIGNvdW50ID0gMDtcbnZhciBkZWZhdWx0cyA9IHtcbiAgc2VwYXJhdG9yOiAnOjonXG59O1xuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGNvdW50ID0gMDtcbn1cbmZ1bmN0aW9uIHVzZVVuaXF1ZUlkKHByZWZpeCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzO1xuICB9XG5cbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgb3B0aW9ucy5zZXBhcmF0b3IgKyBjb3VudCsrO1xuICB9LCBbb3B0aW9ucy5zZXBhcmF0b3IsIHByZWZpeF0pO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50SWQoX3JlZikge1xuICB2YXIgY29udGV4dElkID0gX3JlZi5jb250ZXh0SWQsXG4gICAgICB1bmlxdWVJZCA9IF9yZWYudW5pcXVlSWQ7XG4gIHJldHVybiBcInJiZC1oaWRkZW4tdGV4dC1cIiArIGNvbnRleHRJZCArIFwiLVwiICsgdW5pcXVlSWQ7XG59XG5mdW5jdGlvbiB1c2VIaWRkZW5UZXh0RWxlbWVudChfcmVmMikge1xuICB2YXIgY29udGV4dElkID0gX3JlZjIuY29udGV4dElkLFxuICAgICAgdGV4dCA9IF9yZWYyLnRleHQ7XG4gIHZhciB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdoaWRkZW4tdGV4dCcsIHtcbiAgICBzZXBhcmF0b3I6ICctJ1xuICB9KTtcbiAgdmFyIGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRJZCh7XG4gICAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICAgIHVuaXF1ZUlkOiB1bmlxdWVJZFxuICAgIH0pO1xuICB9LCBbdW5pcXVlSWQsIGNvbnRleHRJZF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuaWQgPSBpZDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHZhciBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcblxuICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpZCwgdGV4dF0pO1xuICByZXR1cm4gaWQ7XG59XG5cbnZhciBBcHBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxudmFyIHBlZXJEZXBlbmRlbmNpZXMgPSB7XG5cdHJlYWN0OiBcIl4xNi44LjUgfHwgXjE3LjAuMCB8fCBeMTguMC4wXCIsXG5cdFwicmVhY3QtZG9tXCI6IFwiXjE2LjguNSB8fCBeMTcuMC4wIHx8IF4xOC4wLjBcIlxufTtcblxudmFyIHNlbXZlciA9IC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKykvO1xuXG52YXIgZ2V0VmVyc2lvbiA9IGZ1bmN0aW9uIGdldFZlcnNpb24odmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHNlbXZlci5leGVjKHZhbHVlKTtcbiAgIShyZXN1bHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiVW5hYmxlIHRvIHBhcnNlIFJlYWN0IHZlcnNpb24gXCIgKyB2YWx1ZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgbWFqb3IgPSBOdW1iZXIocmVzdWx0WzFdKTtcbiAgdmFyIG1pbm9yID0gTnVtYmVyKHJlc3VsdFsyXSk7XG4gIHZhciBwYXRjaCA9IE51bWJlcihyZXN1bHRbM10pO1xuICByZXR1cm4ge1xuICAgIG1ham9yOiBtYWpvcixcbiAgICBtaW5vcjogbWlub3IsXG4gICAgcGF0Y2g6IHBhdGNoLFxuICAgIHJhdzogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBpc1NhdGlzZmllZCA9IGZ1bmN0aW9uIGlzU2F0aXNmaWVkKGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgaWYgKGFjdHVhbC5tYWpvciA+IGV4cGVjdGVkLm1ham9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYWN0dWFsLm1ham9yIDwgZXhwZWN0ZWQubWFqb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYWN0dWFsLm1pbm9yID4gZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhY3R1YWwubWlub3IgPCBleHBlY3RlZC5taW5vcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhY3R1YWwucGF0Y2ggPj0gZXhwZWN0ZWQucGF0Y2g7XG59O1xuXG52YXIgY2hlY2tSZWFjdFZlcnNpb24gPSAoZnVuY3Rpb24gKHBlZXJEZXBWYWx1ZSwgYWN0dWFsVmFsdWUpIHtcbiAgdmFyIHBlZXJEZXAgPSBnZXRWZXJzaW9uKHBlZXJEZXBWYWx1ZSk7XG4gIHZhciBhY3R1YWwgPSBnZXRWZXJzaW9uKGFjdHVhbFZhbHVlKTtcblxuICBpZiAoaXNTYXRpc2ZpZWQocGVlckRlcCwgYWN0dWFsKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgUmVhY3QgdmVyc2lvbjogW1wiICsgYWN0dWFsLnJhdyArIFwiXVxcbiAgICBkb2VzIG5vdCBzYXRpc2Z5IGV4cGVjdGVkIHBlZXIgZGVwZW5kZW5jeSB2ZXJzaW9uOiBbXCIgKyBwZWVyRGVwLnJhdyArIFwiXVxcblxcbiAgICBUaGlzIGNhbiByZXN1bHQgaW4gcnVuIHRpbWUgYnVncywgYW5kIGV2ZW4gZmF0YWwgY3Jhc2hlc1xcbiAgXCIpIDogdm9pZCAwO1xufSk7XG5cbnZhciBzdWZmaXggPSBcIlxcbiAgV2UgZXhwZWN0IGEgaHRtbDUgZG9jdHlwZTogPCFkb2N0eXBlIGh0bWw+XFxuICBUaGlzIGlzIHRvIGVuc3VyZSBjb25zaXN0ZW50IGJyb3dzZXIgbGF5b3V0IGFuZCBtZWFzdXJlbWVudFxcblxcbiAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvZ3VpZGVzL2RvY3R5cGUubWRcXG5cIjtcbnZhciBjaGVja0RvY3R5cGUgPSAoZnVuY3Rpb24gKGRvYykge1xuICB2YXIgZG9jdHlwZSA9IGRvYy5kb2N0eXBlO1xuXG4gIGlmICghZG9jdHlwZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICBObyA8IWRvY3R5cGUgaHRtbD4gZm91bmQuXFxuXFxuICAgICAgXCIgKyBzdWZmaXggKyBcIlxcbiAgICBcIikgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRvY3R5cGUubmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IGZvdW5kOiAoXCIgKyBkb2N0eXBlLm5hbWUgKyBcIilcXG5cXG4gICAgICBcIiArIHN1ZmZpeCArIFwiXFxuICAgIFwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIGlmIChkb2N0eXBlLnB1YmxpY0lkICE9PSAnJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICBVbmV4cGVjdGVkIDwhZG9jdHlwZT4gcHVibGljSWQgZm91bmQ6IChcIiArIGRvY3R5cGUucHVibGljSWQgKyBcIilcXG4gICAgICBBIGh0bWw1IGRvY3R5cGUgZG9lcyBub3QgaGF2ZSBhIHB1YmxpY0lkXFxuXFxuICAgICAgXCIgKyBzdWZmaXggKyBcIlxcbiAgICBcIikgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1c2VEZXYodXNlSG9vaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVzZUhvb2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VEZXZTZXR1cFdhcm5pbmcoZm4sIGlucHV0cykge1xuICB1c2VEZXYoZnVuY3Rpb24gKCkge1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihcIlxcbiAgICAgICAgICBBIHNldHVwIHByb2JsZW0gd2FzIGVuY291bnRlcmVkLlxcblxcbiAgICAgICAgICA+IFwiICsgZS5tZXNzYWdlICsgXCJcXG4gICAgICAgIFwiKTtcbiAgICAgIH1cbiAgICB9LCBpbnB1dHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlU3RhcnR1cFZhbGlkYXRpb24oKSB7XG4gIHVzZURldlNldHVwV2FybmluZyhmdW5jdGlvbiAoKSB7XG4gICAgY2hlY2tSZWFjdFZlcnNpb24ocGVlckRlcGVuZGVuY2llcy5yZWFjdCwgUmVhY3QudmVyc2lvbik7XG4gICAgY2hlY2tEb2N0eXBlKGRvY3VtZW50KTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyhjdXJyZW50KSB7XG4gIHZhciByZWYgPSB1c2VSZWYoY3VycmVudCk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBjdXJyZW50O1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgbG9jayA9IG51bGw7XG5cbiAgZnVuY3Rpb24gaXNDbGFpbWVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKGxvY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBY3RpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxvY2s7XG4gIH1cblxuICBmdW5jdGlvbiBjbGFpbShhYmFuZG9uKSB7XG4gICAgISFsb2NrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNsYWltIGxvY2sgYXMgaXQgaXMgYWxyZWFkeSBjbGFpbWVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBuZXdMb2NrID0ge1xuICAgICAgYWJhbmRvbjogYWJhbmRvblxuICAgIH07XG4gICAgbG9jayA9IG5ld0xvY2s7XG4gICAgcmV0dXJuIG5ld0xvY2s7XG4gIH1cblxuICBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICFsb2NrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbGVhc2UgbG9jayB3aGVuIHRoZXJlIGlzIG5vIGxvY2snKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbG9jayA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlBYmFuZG9uKCkge1xuICAgIGlmIChsb2NrKSB7XG4gICAgICBsb2NrLmFiYW5kb24oKTtcbiAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzQ2xhaW1lZDogaXNDbGFpbWVkLFxuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICBjbGFpbTogY2xhaW0sXG4gICAgcmVsZWFzZTogcmVsZWFzZSxcbiAgICB0cnlBYmFuZG9uOiB0cnlBYmFuZG9uXG4gIH07XG59XG5cbnZhciB0YWIgPSA5O1xudmFyIGVudGVyID0gMTM7XG52YXIgZXNjYXBlID0gMjc7XG52YXIgc3BhY2UgPSAzMjtcbnZhciBwYWdlVXAgPSAzMztcbnZhciBwYWdlRG93biA9IDM0O1xudmFyIGVuZCA9IDM1O1xudmFyIGhvbWUgPSAzNjtcbnZhciBhcnJvd0xlZnQgPSAzNztcbnZhciBhcnJvd1VwID0gMzg7XG52YXIgYXJyb3dSaWdodCA9IDM5O1xudmFyIGFycm93RG93biA9IDQwO1xuXG52YXIgX3ByZXZlbnRlZEtleXM7XG52YXIgcHJldmVudGVkS2V5cyA9IChfcHJldmVudGVkS2V5cyA9IHt9LCBfcHJldmVudGVkS2V5c1tlbnRlcl0gPSB0cnVlLCBfcHJldmVudGVkS2V5c1t0YWJdID0gdHJ1ZSwgX3ByZXZlbnRlZEtleXMpO1xudmFyIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyA9IChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKHByZXZlbnRlZEtleXNbZXZlbnQua2V5Q29kZV0pIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59KTtcblxudmFyIHN1cHBvcnRlZEV2ZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhc2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVzID0gW2Jhc2UsIFwibXNcIiArIGJhc2UsIFwid2Via2l0XCIgKyBiYXNlLCBcIm1velwiICsgYmFzZSwgXCJvXCIgKyBiYXNlXTtcbiAgdmFyIHN1cHBvcnRlZCA9IGZpbmQoY2FuZGlkYXRlcywgZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBcIm9uXCIgKyBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG4gIH0pO1xuICByZXR1cm4gc3VwcG9ydGVkIHx8IGJhc2U7XG59KCk7XG5cbnZhciBwcmltYXJ5QnV0dG9uID0gMDtcbnZhciBzbG9wcHlDbGlja1RocmVzaG9sZCA9IDU7XG5cbmZ1bmN0aW9uIGlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChvcmlnaW5hbCwgY3VycmVudCkge1xuICByZXR1cm4gTWF0aC5hYnMoY3VycmVudC54IC0gb3JpZ2luYWwueCkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQgfHwgTWF0aC5hYnMoY3VycmVudC55IC0gb3JpZ2luYWwueSkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQ7XG59XG5cbnZhciBpZGxlJDEgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcblxuZnVuY3Rpb24gZ2V0Q2FwdHVyZUJpbmRpbmdzKF9yZWYpIHtcbiAgdmFyIGNhbmNlbCA9IF9yZWYuY2FuY2VsLFxuICAgICAgY29tcGxldGVkID0gX3JlZi5jb21wbGV0ZWQsXG4gICAgICBnZXRQaGFzZSA9IF9yZWYuZ2V0UGhhc2UsXG4gICAgICBzZXRQaGFzZSA9IF9yZWYuc2V0UGhhc2U7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ21vdXNlbW92ZScsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uLFxuICAgICAgICAgIGNsaWVudFggPSBldmVudC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuXG4gICAgICBpZiAoYnV0dG9uICE9PSBwcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcblxuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYmUgSURMRScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBwZW5kaW5nID0gcGhhc2UucG9pbnQ7XG5cbiAgICAgIGlmICghaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkKHBlbmRpbmcsIHBvaW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgYWN0aW9ucyA9IHBoYXNlLmFjdGlvbnMuZmx1aWRMaWZ0KHBvaW50KTtcbiAgICAgIHNldFBoYXNlKHtcbiAgICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgICAgYWN0aW9uczogYWN0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2V1cCcsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICB2YXIgcGhhc2UgPSBnZXRQaGFzZSgpO1xuXG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICB2YXIgcGhhc2UgPSBnZXRQaGFzZSgpO1xuXG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogZnVuY3Rpb24gZm4oKSB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2Via2l0bW91c2Vmb3JjZWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgcGhhc2UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwaGFzZS5hY3Rpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCkpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuXG5mdW5jdGlvbiB1c2VNb3VzZVNlbnNvcihhcGkpIHtcbiAgdmFyIHBoYXNlUmVmID0gdXNlUmVmKGlkbGUkMSk7XG4gIHZhciB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCk7XG4gIHZhciBzdGFydENhcHR1cmVCaW5kaW5nID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgICBmbjogZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSBwcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG5cbiAgICAgICAgaWYgKCFkcmFnZ2FibGVJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb25zID0gYXBpLnRyeUdldExvY2soZHJhZ2dhYmxlSWQsIHN0b3AsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgICB9O1xuICAgICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYXBpXSk7XG4gIHZhciBwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnROYW1lOiAnd2Via2l0bW91c2Vmb3JjZXdpbGxiZWdpbicsXG4gICAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gYXBpLmZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlKGlkKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXBpLmNhbkdldExvY2soaWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYXBpXSk7XG4gIHZhciBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3ByZXZlbnRGb3JjZVByZXNzQmluZGluZywgc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nLCBzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIHZhciBzdG9wID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gcGhhc2VSZWYuY3VycmVudDtcblxuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBpZGxlJDE7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG4gIHZhciBjYW5jZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG5cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5jYW5jZWwoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5hYm9ydCgpO1xuICAgIH1cbiAgfSwgW3N0b3BdKTtcbiAgdmFyIGJpbmRDYXB0dXJpbmdFdmVudHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBiaW5kQ2FwdHVyaW5nRXZlbnRzKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgYmluZGluZ3MgPSBnZXRDYXB0dXJlQmluZGluZ3Moe1xuICAgICAgY2FuY2VsOiBjYW5jZWwsXG4gICAgICBjb21wbGV0ZWQ6IHN0b3AsXG4gICAgICBnZXRQaGFzZTogZnVuY3Rpb24gZ2V0UGhhc2UoKSB7XG4gICAgICAgIHJldHVybiBwaGFzZVJlZi5jdXJyZW50O1xuICAgICAgfSxcbiAgICAgIHNldFBoYXNlOiBmdW5jdGlvbiBzZXRQaGFzZShwaGFzZSkge1xuICAgICAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgYmluZGluZ3MsIG9wdGlvbnMpO1xuICB9LCBbY2FuY2VsLCBzdG9wXSk7XG4gIHZhciBzdGFydFBlbmRpbmdEcmFnID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCkge1xuICAgICEocGhhc2VSZWYuY3VycmVudC50eXBlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gbW92ZSBmcm9tIElETEUgdG8gUEVORElORyBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHBoYXNlUmVmLmN1cnJlbnQgPSB7XG4gICAgICB0eXBlOiAnUEVORElORycsXG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zXG4gICAgfTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICB9O1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xufVxuXG52YXIgX3Njcm9sbEp1bXBLZXlzO1xuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuXG52YXIgc2Nyb2xsSnVtcEtleXMgPSAoX3Njcm9sbEp1bXBLZXlzID0ge30sIF9zY3JvbGxKdW1wS2V5c1twYWdlRG93bl0gPSB0cnVlLCBfc2Nyb2xsSnVtcEtleXNbcGFnZVVwXSA9IHRydWUsIF9zY3JvbGxKdW1wS2V5c1tob21lXSA9IHRydWUsIF9zY3JvbGxKdW1wS2V5c1tlbmRdID0gdHJ1ZSwgX3Njcm9sbEp1bXBLZXlzKTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSB7XG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdG9wKCk7XG4gICAgYWN0aW9ucy5jYW5jZWwoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuZHJvcCgpO1xuICB9XG5cbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBzcGFjZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkcm9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93RG93bikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVEb3duKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93VXApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlVXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dSaWdodCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVSaWdodCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd0xlZnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlTGVmdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGxKdW1wS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyhldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZXVwJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdjbGljaycsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd3aGVlbCcsXG4gICAgZm46IGNhbmNlbCxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cblxuZnVuY3Rpb24gdXNlS2V5Ym9hcmRTZW5zb3IoYXBpKSB7XG4gIHZhciB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQxKTtcbiAgdmFyIHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgICBmbjogZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IHNwYWNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdnYWJsZUlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuXG4gICAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlRHJhZyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcHJlRHJhZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBpc0NhcHR1cmluZyA9IHRydWU7XG4gICAgICAgIHZhciBhY3Rpb25zID0gcHJlRHJhZy5zbmFwTGlmdCgpO1xuICAgICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgIWlzQ2FwdHVyaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3AgY2FwdHVyaW5nIGEga2V5Ym9hcmQgZHJhZyB3aGVuIG5vdCBjYXB0dXJpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgICAgaXNDYXB0dXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldERyYWdnaW5nQmluZGluZ3MoYWN0aW9ucywgc3RvcCksIHtcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthcGldKTtcbiAgdmFyIGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlTdGFydENhcHR1cmUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICB9O1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xufVxuXG52YXIgaWRsZSQyID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG52YXIgdGltZUZvckxvbmdQcmVzcyA9IDEyMDtcbnZhciBmb3JjZVByZXNzVGhyZXNob2xkID0gMC4xNTtcblxuZnVuY3Rpb24gZ2V0V2luZG93QmluZGluZ3MoX3JlZikge1xuICB2YXIgY2FuY2VsID0gX3JlZi5jYW5jZWwsXG4gICAgICBnZXRQaGFzZSA9IF9yZWYuZ2V0UGhhc2U7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ29yaWVudGF0aW9uY2hhbmdlJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NvbnRleHRtZW51JyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFuZGxlQmluZGluZ3MoX3JlZjIpIHtcbiAgdmFyIGNhbmNlbCA9IF9yZWYyLmNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZCA9IF9yZWYyLmNvbXBsZXRlZCxcbiAgICAgIGdldFBoYXNlID0gX3JlZjIuZ2V0UGhhc2U7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgb3B0aW9uczoge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcblxuICAgICAgaWYgKHBoYXNlLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGhhc2UuaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgdmFyIF9ldmVudCR0b3VjaGVzJCA9IGV2ZW50LnRvdWNoZXNbMF0sXG4gICAgICAgICAgY2xpZW50WCA9IF9ldmVudCR0b3VjaGVzJC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfZXZlbnQkdG91Y2hlcyQuY2xpZW50WTtcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwaGFzZS5hY3Rpb25zLm1vdmUocG9pbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoZW5kJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwaGFzZS5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGNhbmNlbCcsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGZvcmNlY2hhbmdlJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG5cbiAgICAgIGlmICghdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNGb3JjZVByZXNzID0gdG91Y2guZm9yY2UgPj0gZm9yY2VQcmVzc1RocmVzaG9sZDtcblxuICAgICAgaWYgKCFpc0ZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvdWxkUmVzcGVjdCA9IHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKTtcblxuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICBpZiAocGhhc2UuaGFzTW92ZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cblxuZnVuY3Rpb24gdXNlVG91Y2hTZW5zb3IoYXBpKSB7XG4gIHZhciBwaGFzZVJlZiA9IHVzZVJlZihpZGxlJDIpO1xuICB2YXIgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3ApO1xuICB2YXIgZ2V0UGhhc2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBnZXRQaGFzZSgpIHtcbiAgICByZXR1cm4gcGhhc2VSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB2YXIgc2V0UGhhc2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzZXRQaGFzZShwaGFzZSkge1xuICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTtcbiAgfSwgW10pO1xuICB2YXIgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICAgIGZuOiBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG5cbiAgICAgICAgaWYgKCFkcmFnZ2FibGVJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb25zID0gYXBpLnRyeUdldExvY2soZHJhZ2dhYmxlSWQsIHN0b3AsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgdmFyIGNsaWVudFggPSB0b3VjaC5jbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICAgIHk6IGNsaWVudFlcbiAgICAgICAgfTtcbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FwaV0pO1xuICB2YXIgbGlzdGVuRm9yQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGxpc3RlbkZvckNhcHR1cmUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIHZhciBzdG9wID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gcGhhc2VSZWYuY3VycmVudDtcblxuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnQubG9uZ1ByZXNzVGltZXJJZCk7XG4gICAgfVxuXG4gICAgc2V0UGhhc2UoaWRsZSQyKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIHZhciBjYW5jZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG5cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5jYW5jZWwoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5hYm9ydCgpO1xuICAgIH1cbiAgfSwgW3N0b3BdKTtcbiAgdmFyIGJpbmRDYXB0dXJpbmdFdmVudHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBiaW5kQ2FwdHVyaW5nRXZlbnRzKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgYXJncyA9IHtcbiAgICAgIGNhbmNlbDogY2FuY2VsLFxuICAgICAgY29tcGxldGVkOiBzdG9wLFxuICAgICAgZ2V0UGhhc2U6IGdldFBoYXNlXG4gICAgfTtcbiAgICB2YXIgdW5iaW5kVGFyZ2V0ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldEhhbmRsZUJpbmRpbmdzKGFyZ3MpLCBvcHRpb25zKTtcbiAgICB2YXIgdW5iaW5kV2luZG93ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldFdpbmRvd0JpbmRpbmdzKGFyZ3MpLCBvcHRpb25zKTtcblxuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gZnVuY3Rpb24gdW5iaW5kQWxsKCkge1xuICAgICAgdW5iaW5kVGFyZ2V0KCk7XG4gICAgICB1bmJpbmRXaW5kb3coKTtcbiAgICB9O1xuICB9LCBbY2FuY2VsLCBnZXRQaGFzZSwgc3RvcF0pO1xuICB2YXIgc3RhcnREcmFnZ2luZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0RHJhZ2dpbmcoKSB7XG4gICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IHN0YXJ0IGRyYWdnaW5nIGZyb20gcGhhc2UgXCIgKyBwaGFzZS50eXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwaGFzZS5wb2ludCk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICBoYXNNb3ZlZDogZmFsc2VcbiAgICB9KTtcbiAgfSwgW2dldFBoYXNlLCBzZXRQaGFzZV0pO1xuICB2YXIgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKGdldFBoYXNlKCkudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgbG9uZ1ByZXNzVGltZXJJZCA9IHNldFRpbWVvdXQoc3RhcnREcmFnZ2luZywgdGltZUZvckxvbmdQcmVzcyk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICAgIGxvbmdQcmVzc1RpbWVySWQ6IGxvbmdQcmVzc1RpbWVySWRcbiAgICB9KTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzLCBnZXRQaGFzZSwgc2V0UGhhc2UsIHN0YXJ0RHJhZ2dpbmddKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcblxuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjbGVhclRpbWVvdXQocGhhc2UubG9uZ1ByZXNzVGltZXJJZCk7XG4gICAgICAgIHNldFBoYXNlKGlkbGUkMik7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2dldFBoYXNlLCBsaXN0ZW5Gb3JDYXB0dXJlLCBzZXRQaGFzZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIHdlYmtpdEhhY2soKSB7XG4gICAgdmFyIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIHVuYmluZDtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHNlbnNvckhvb2tzKSB7XG4gIHVzZURldihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZpb3VzUmVmID0gdXNlUHJldmlvdXMoc2Vuc29ySG9va3MpO1xuICAgIHVzZURldlNldHVwV2FybmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAhKHByZXZpb3VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSBzZW5zb3JIb29rcy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNoYW5nZSB0aGUgYW1vdW50IG9mIHNlbnNvciBob29rcyBhZnRlciBtb3VudGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfSk7XG59XG5cbnZhciBpbnRlcmFjdGl2ZVRhZ05hbWVzID0ge1xuICBpbnB1dDogdHJ1ZSxcbiAgYnV0dG9uOiB0cnVlLFxuICB0ZXh0YXJlYTogdHJ1ZSxcbiAgc2VsZWN0OiB0cnVlLFxuICBvcHRpb246IHRydWUsXG4gIG9wdGdyb3VwOiB0cnVlLFxuICB2aWRlbzogdHJ1ZSxcbiAgYXVkaW86IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50LCBjdXJyZW50KSB7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaGFzQW5JbnRlcmFjdGl2ZVRhZyA9IEJvb2xlYW4oaW50ZXJhY3RpdmVUYWdOYW1lc1tjdXJyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKV0pO1xuXG4gIGlmIChoYXNBbkludGVyYWN0aXZlVGFnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgYXR0cmlidXRlID0gY3VycmVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuXG4gIGlmIChhdHRyaWJ1dGUgPT09ICd0cnVlJyB8fCBhdHRyaWJ1dGUgPT09ICcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoY3VycmVudCA9PT0gcGFyZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50LCBjdXJyZW50LnBhcmVudEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQoZHJhZ2dhYmxlLCBldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gIGlmICghaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQoZHJhZ2dhYmxlLCB0YXJnZXQpO1xufVxuXG52YXIgZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24gPSAoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBnZXRSZWN0KGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5jZW50ZXI7XG59KTtcblxuZnVuY3Rpb24gaXNFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIGdldFdpbmRvd0Zyb21FbChlbCkuRWxlbWVudDtcbn1cblxudmFyIHN1cHBvcnRlZE1hdGNoZXNOYW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYmFzZSA9ICdtYXRjaGVzJztcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBbYmFzZSwgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvciddO1xuICB2YXIgdmFsdWUgPSBmaW5kKGNhbmRpZGF0ZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gRWxlbWVudC5wcm90b3R5cGU7XG4gIH0pO1xuICByZXR1cm4gdmFsdWUgfHwgYmFzZTtcbn0oKTtcblxuZnVuY3Rpb24gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGVsW3N1cHBvcnRlZE1hdGNoZXNOYW1lXShzZWxlY3RvcikpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdFBvbnlmaWxsKGVsLnBhcmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gY2xvc2VzdCQxKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwuY2xvc2VzdCkge1xuICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0UG9ueWZpbGwoZWwsIHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IoY29udGV4dElkKSB7XG4gIHJldHVybiBcIltcIiArIGRyYWdIYW5kbGUuY29udGV4dElkICsgXCI9XFxcIlwiICsgY29udGV4dElkICsgXCJcXFwiXVwiO1xufVxuXG5mdW5jdGlvbiBmaW5kQ2xvc2VzdERyYWdIYW5kbGVGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gIGlmICghaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdldmVudC50YXJnZXQgbXVzdCBiZSBhIEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGNvbnRleHRJZCk7XG4gIHZhciBoYW5kbGUgPSBjbG9zZXN0JDEodGFyZ2V0LCBzZWxlY3Rvcik7XG5cbiAgaWYgKCFoYW5kbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbXVzdCBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCkge1xuICB2YXIgaGFuZGxlID0gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpO1xuXG4gIGlmICghaGFuZGxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKTtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGRyYWdnYWJsZUlkKSB7XG4gIHZhciBzZWxlY3RvciA9IFwiW1wiICsgZHJhZ2dhYmxlLmNvbnRleHRJZCArIFwiPVxcXCJcIiArIGNvbnRleHRJZCArIFwiXFxcIl1cIjtcbiAgdmFyIHBvc3NpYmxlID0gdG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gIHZhciBkcmFnZ2FibGUkMSA9IGZpbmQocG9zc2libGUsIGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoZHJhZ2dhYmxlLmlkKSA9PT0gZHJhZ2dhYmxlSWQ7XG4gIH0pO1xuXG4gIGlmICghZHJhZ2dhYmxlJDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaXNIdG1sRWxlbWVudChkcmFnZ2FibGUkMSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdEcmFnZ2FibGUgZWxlbWVudCBpcyBub3QgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGRyYWdnYWJsZSQxO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBfaXNBY3RpdmUoX3JlZikge1xuICB2YXIgZXhwZWN0ZWQgPSBfcmVmLmV4cGVjdGVkLFxuICAgICAgcGhhc2UgPSBfcmVmLnBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlID0gX3JlZi5pc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuID0gX3JlZi5zaG91bGRXYXJuO1xuXG4gIGlmICghaXNMb2NrQWN0aXZlKCkpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgICAgQ2Fubm90IHBlcmZvcm0gYWN0aW9uLlxcbiAgICAgICAgVGhlIHNlbnNvciBubyBsb25nZXIgaGFzIGFuIGFjdGlvbiBsb2NrLlxcblxcbiAgICAgICAgVGlwczpcXG5cXG4gICAgICAgIC0gVGhyb3cgYXdheSB5b3VyIGFjdGlvbiBoYW5kbGVycyB3aGVuIGZvcmNlU3RvcCgpIGlzIGNhbGxlZFxcbiAgICAgICAgLSBDaGVjayBhY3Rpb25zLmlzQWN0aXZlKCkgaWYgeW91IHJlYWxseSBuZWVkIHRvXFxuICAgICAgXCIpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChleHBlY3RlZCAhPT0gcGhhc2UpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgICAgQ2Fubm90IHBlcmZvcm0gYWN0aW9uLlxcbiAgICAgICAgVGhlIGFjdGlvbnMgeW91IHVzZWQgYmVsb25nIHRvIGFuIG91dGRhdGVkIHBoYXNlXFxuXFxuICAgICAgICBDdXJyZW50IHBoYXNlOiBcIiArIGV4cGVjdGVkICsgXCJcXG4gICAgICAgIFlvdSBjYWxsZWQgYW4gYWN0aW9uIGZyb20gb3V0ZGF0ZWQgcGhhc2U6IFwiICsgcGhhc2UgKyBcIlxcblxcbiAgICAgICAgVGlwczpcXG5cXG4gICAgICAgIC0gRG8gbm90IHVzZSBwcmVEcmFnQWN0aW9ucyBhY3Rpb25zIGFmdGVyIGNhbGxpbmcgcHJlRHJhZ0FjdGlvbnMubGlmdCgpXFxuICAgICAgXCIpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYW5TdGFydChfcmVmMikge1xuICB2YXIgbG9ja0FQSSA9IF9yZWYyLmxvY2tBUEksXG4gICAgICBzdG9yZSA9IF9yZWYyLnN0b3JlLFxuICAgICAgcmVnaXN0cnkgPSBfcmVmMi5yZWdpc3RyeSxcbiAgICAgIGRyYWdnYWJsZUlkID0gX3JlZjIuZHJhZ2dhYmxlSWQ7XG5cbiAgaWYgKGxvY2tBUEkuaXNDbGFpbWVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoZHJhZ2dhYmxlSWQpO1xuXG4gIGlmICghZW50cnkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIHdpdGggaWQ6IFwiICsgZHJhZ2dhYmxlSWQpIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghZW50cnkub3B0aW9ucy5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNhblN0YXJ0RHJhZyhzdG9yZS5nZXRTdGF0ZSgpLCBkcmFnZ2FibGVJZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdHJ5U3RhcnQoX3JlZjMpIHtcbiAgdmFyIGxvY2tBUEkgPSBfcmVmMy5sb2NrQVBJLFxuICAgICAgY29udGV4dElkID0gX3JlZjMuY29udGV4dElkLFxuICAgICAgc3RvcmUgPSBfcmVmMy5zdG9yZSxcbiAgICAgIHJlZ2lzdHJ5ID0gX3JlZjMucmVnaXN0cnksXG4gICAgICBkcmFnZ2FibGVJZCA9IF9yZWYzLmRyYWdnYWJsZUlkLFxuICAgICAgZm9yY2VTZW5zb3JTdG9wID0gX3JlZjMuZm9yY2VTZW5zb3JTdG9wLFxuICAgICAgc291cmNlRXZlbnQgPSBfcmVmMy5zb3VyY2VFdmVudDtcbiAgdmFyIHNob3VsZFN0YXJ0ID0gY2FuU3RhcnQoe1xuICAgIGxvY2tBUEk6IGxvY2tBUEksXG4gICAgc3RvcmU6IHN0b3JlLFxuICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICBkcmFnZ2FibGVJZDogZHJhZ2dhYmxlSWRcbiAgfSk7XG5cbiAgaWYgKCFzaG91bGRTdGFydCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoZHJhZ2dhYmxlSWQpO1xuICB2YXIgZWwgPSBmaW5kRHJhZ2dhYmxlKGNvbnRleHRJZCwgZW50cnkuZGVzY3JpcHRvci5pZCk7XG5cbiAgaWYgKCFlbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJVbmFibGUgdG8gZmluZCBkcmFnZ2FibGUgZWxlbWVudCB3aXRoIGlkOiBcIiArIGRyYWdnYWJsZUlkKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzb3VyY2VFdmVudCAmJiAhZW50cnkub3B0aW9ucy5jYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyAmJiBpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQoZWwsIHNvdXJjZUV2ZW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxvY2sgPSBsb2NrQVBJLmNsYWltKGZvcmNlU2Vuc29yU3RvcCB8fCBub29wKTtcbiAgdmFyIHBoYXNlID0gJ1BSRV9EUkFHJztcblxuICBmdW5jdGlvbiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpIHtcbiAgICByZXR1cm4gZW50cnkub3B0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTG9ja0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gbG9ja0FQSS5pc0FjdGl2ZShsb2NrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeURpc3BhdGNoKGV4cGVjdGVkLCBnZXRBY3Rpb24pIHtcbiAgICBpZiAoX2lzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZTogaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogdHJ1ZVxuICAgIH0pKSB7XG4gICAgICBzdG9yZS5kaXNwYXRjaChnZXRBY3Rpb24oKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nID0gdHJ5RGlzcGF0Y2guYmluZChudWxsLCAnRFJBR0dJTkcnKTtcblxuICBmdW5jdGlvbiBsaWZ0JDEoYXJncykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgICAgcGhhc2UgPSAnQ09NUExFVEVEJztcbiAgICB9XG5cbiAgICBpZiAocGhhc2UgIT09ICdQUkVfRFJBRycpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgIShwaGFzZSA9PT0gJ1BSRV9EUkFHJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IGxpZnQgaW4gcGhhc2UgXCIgKyBwaGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHN0b3JlLmRpc3BhdGNoKGxpZnQoYXJncy5saWZ0QWN0aW9uQXJncykpO1xuICAgIHBoYXNlID0gJ0RSQUdHSU5HJztcblxuICAgIGZ1bmN0aW9uIGZpbmlzaChyZWFzb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYXJncy5jbGVhbnVwKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLnNob3VsZEJsb2NrTmV4dENsaWNrKSB7XG4gICAgICAgIHZhciB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgICAgICBldmVudE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgZm46IHByZXZlbnREZWZhdWx0LFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgICAgc2V0VGltZW91dCh1bmJpbmQpO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3Aoe1xuICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiBfaXNBY3RpdmUoe1xuICAgICAgICAgIGV4cGVjdGVkOiAnRFJBR0dJTkcnLFxuICAgICAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgICAgICBpc0xvY2tBY3RpdmU6IGlzTG9ja0FjdGl2ZSxcbiAgICAgICAgICBzaG91bGRXYXJuOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZpbmlzaCgnRFJPUCcsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZpbmlzaCgnQ0FOQ0VMJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSwgYXJncy5hY3Rpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdWlkTGlmdChjbGllbnRTZWxlY3Rpb24pIHtcbiAgICB2YXIgbW92ZSQxID0gcmFmU2NoZChmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb3ZlKHtcbiAgICAgICAgICBjbGllbnQ6IGNsaWVudFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBhcGkgPSBsaWZ0JDEoe1xuICAgICAgbGlmdEFjdGlvbkFyZ3M6IHtcbiAgICAgICAgaWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICAgICAgbW92ZW1lbnRNb2RlOiAnRkxVSUQnXG4gICAgICB9LFxuICAgICAgY2xlYW51cDogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgcmV0dXJuIG1vdmUkMS5jYW5jZWwoKTtcbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIG1vdmU6IG1vdmUkMVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYXBpLCB7XG4gICAgICBtb3ZlOiBtb3ZlJDFcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNuYXBMaWZ0KCkge1xuICAgIHZhciBhY3Rpb25zID0ge1xuICAgICAgbW92ZVVwOiBmdW5jdGlvbiBtb3ZlVXAkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVVcCk7XG4gICAgICB9LFxuICAgICAgbW92ZVJpZ2h0OiBmdW5jdGlvbiBtb3ZlUmlnaHQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVSaWdodCk7XG4gICAgICB9LFxuICAgICAgbW92ZURvd246IGZ1bmN0aW9uIG1vdmVEb3duJDEoKSB7XG4gICAgICAgIHJldHVybiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlRG93bik7XG4gICAgICB9LFxuICAgICAgbW92ZUxlZnQ6IGZ1bmN0aW9uIG1vdmVMZWZ0JDEoKSB7XG4gICAgICAgIHJldHVybiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlTGVmdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbGlmdCQxKHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uOiBnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbihlbCksXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ1NOQVAnXG4gICAgICB9LFxuICAgICAgY2xlYW51cDogbm9vcCxcbiAgICAgIGFjdGlvbnM6IGFjdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0UHJlRHJhZygpIHtcbiAgICB2YXIgc2hvdWxkUmVsZWFzZSA9IF9pc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZTogaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZFJlbGVhc2UpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmVEcmFnID0ge1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgIHJldHVybiBfaXNBY3RpdmUoe1xuICAgICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgICAgcGhhc2U6IHBoYXNlLFxuICAgICAgICBpc0xvY2tBY3RpdmU6IGlzTG9ja0FjdGl2ZSxcbiAgICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGZsdWlkTGlmdDogZmx1aWRMaWZ0LFxuICAgIHNuYXBMaWZ0OiBzbmFwTGlmdCxcbiAgICBhYm9ydDogYWJvcnRQcmVEcmFnXG4gIH07XG4gIHJldHVybiBwcmVEcmFnO1xufVxuXG52YXIgZGVmYXVsdFNlbnNvcnMgPSBbdXNlTW91c2VTZW5zb3IsIHVzZUtleWJvYXJkU2Vuc29yLCB1c2VUb3VjaFNlbnNvcl07XG5mdW5jdGlvbiB1c2VTZW5zb3JNYXJzaGFsKF9yZWY0KSB7XG4gIHZhciBjb250ZXh0SWQgPSBfcmVmNC5jb250ZXh0SWQsXG4gICAgICBzdG9yZSA9IF9yZWY0LnN0b3JlLFxuICAgICAgcmVnaXN0cnkgPSBfcmVmNC5yZWdpc3RyeSxcbiAgICAgIGN1c3RvbVNlbnNvcnMgPSBfcmVmNC5jdXN0b21TZW5zb3JzLFxuICAgICAgZW5hYmxlRGVmYXVsdFNlbnNvcnMgPSBfcmVmNC5lbmFibGVEZWZhdWx0U2Vuc29ycztcbiAgdmFyIHVzZVNlbnNvcnMgPSBbXS5jb25jYXQoZW5hYmxlRGVmYXVsdFNlbnNvcnMgPyBkZWZhdWx0U2Vuc29ycyA6IFtdLCBjdXN0b21TZW5zb3JzIHx8IFtdKTtcbiAgdmFyIGxvY2tBUEkgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSgpO1xuICB9KVswXTtcbiAgdmFyIHRyeUFiYW5kb25Mb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBpZiAocHJldmlvdXMuaXNEcmFnZ2luZyAmJiAhY3VycmVudC5pc0RyYWdnaW5nKSB7XG4gICAgICBsb2NrQVBJLnRyeUFiYW5kb24oKTtcbiAgICB9XG4gIH0sIFtsb2NrQVBJXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbGlzdGVuVG9TdG9yZSgpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHZhciB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICB0cnlBYmFuZG9uTG9jayhwcmV2aW91cywgY3VycmVudCk7XG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbbG9ja0FQSSwgc3RvcmUsIHRyeUFiYW5kb25Mb2NrXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NrQVBJLnRyeUFiYW5kb247XG4gIH0sIFtsb2NrQVBJLnRyeUFiYW5kb25dKTtcbiAgdmFyIGNhbkdldExvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZHJhZ2dhYmxlSWQpIHtcbiAgICByZXR1cm4gY2FuU3RhcnQoe1xuICAgICAgbG9ja0FQSTogbG9ja0FQSSxcbiAgICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGVJZFxuICAgIH0pO1xuICB9LCBbbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIHZhciB0cnlHZXRMb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRyYWdnYWJsZUlkLCBmb3JjZVN0b3AsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHJ5U3RhcnQoe1xuICAgICAgbG9ja0FQSTogbG9ja0FQSSxcbiAgICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgZm9yY2VTZW5zb3JTdG9wOiBmb3JjZVN0b3AsXG4gICAgICBzb3VyY2VFdmVudDogb3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZUV2ZW50ID8gb3B0aW9ucy5zb3VyY2VFdmVudCA6IG51bGxcbiAgICB9KTtcbiAgfSwgW2NvbnRleHRJZCwgbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIHZhciBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcbiAgfSwgW2NvbnRleHRJZF0pO1xuICB2YXIgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoaWQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5Lm9wdGlvbnMgOiBudWxsO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIHZhciB0cnlSZWxlYXNlTG9jayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlbGVhc2VMb2NrKCkge1xuICAgIGlmICghbG9ja0FQSS5pc0NsYWltZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuXG4gICAgaWYgKHN0b3JlLmdldFN0YXRlKCkucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgfVxuICB9LCBbbG9ja0FQSSwgc3RvcmVdKTtcbiAgdmFyIGlzTG9ja0NsYWltZWQgPSB1c2VDYWxsYmFjayhsb2NrQVBJLmlzQ2xhaW1lZCwgW2xvY2tBUEldKTtcbiAgdmFyIGFwaSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5HZXRMb2NrOiBjYW5HZXRMb2NrLFxuICAgICAgdHJ5R2V0TG9jazogdHJ5R2V0TG9jayxcbiAgICAgIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQ6IGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsXG4gICAgICBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZTogZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsXG4gICAgICB0cnlSZWxlYXNlTG9jazogdHJ5UmVsZWFzZUxvY2ssXG4gICAgICBpc0xvY2tDbGFpbWVkOiBpc0xvY2tDbGFpbWVkXG4gICAgfTtcbiAgfSwgW2NhbkdldExvY2ssIHRyeUdldExvY2ssIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLCB0cnlSZWxlYXNlTG9jaywgaXNMb2NrQ2xhaW1lZF0pO1xuICB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHVzZVNlbnNvcnMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlU2Vuc29ycy5sZW5ndGg7IGkrKykge1xuICAgIHVzZVNlbnNvcnNbaV0oYXBpKTtcbiAgfVxufVxuXG52YXIgY3JlYXRlUmVzcG9uZGVycyA9IGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbmRlcnMocHJvcHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkJlZm9yZUNhcHR1cmU6IHByb3BzLm9uQmVmb3JlQ2FwdHVyZSxcbiAgICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gICAgb25EcmFnU3RhcnQ6IHByb3BzLm9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICAgIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTdG9yZShsYXp5UmVmKSB7XG4gICFsYXp5UmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzdG9yZSBmcm9tIGxhenkgcmVmJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gbGF6eVJlZi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBBcHAocHJvcHMpIHtcbiAgdmFyIGNvbnRleHRJZCA9IHByb3BzLmNvbnRleHRJZCxcbiAgICAgIHNldENhbGxiYWNrcyA9IHByb3BzLnNldENhbGxiYWNrcyxcbiAgICAgIHNlbnNvcnMgPSBwcm9wcy5zZW5zb3JzLFxuICAgICAgbm9uY2UgPSBwcm9wcy5ub25jZSxcbiAgICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IHByb3BzLmRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucztcbiAgdmFyIGxhenlTdG9yZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlU3RhcnR1cFZhbGlkYXRpb24oKTtcbiAgdmFyIGxhc3RQcm9wc1JlZiA9IHVzZVByZXZpb3VzKHByb3BzKTtcbiAgdmFyIGdldFJlc3BvbmRlcnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlc3BvbmRlcnMobGFzdFByb3BzUmVmLmN1cnJlbnQpO1xuICB9LCBbbGFzdFByb3BzUmVmXSk7XG4gIHZhciBhbm5vdW5jZSA9IHVzZUFubm91bmNlcihjb250ZXh0SWQpO1xuICB2YXIgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQgPSB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgdGV4dDogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zXG4gIH0pO1xuICB2YXIgc3R5bGVNYXJzaGFsID0gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpO1xuICB2YXIgbGF6eURpc3BhdGNoID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIGdldFN0b3JlKGxhenlTdG9yZVJlZikuZGlzcGF0Y2goYWN0aW9uKTtcbiAgfSwgW10pO1xuICB2YXIgbWFyc2hhbENhbGxiYWNrcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgcHVibGlzaFdoaWxlRHJhZ2dpbmc6IHB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsOiB1cGRhdGVEcm9wcGFibGVTY3JvbGwsXG4gICAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQ6IHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICAgIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQ6IHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBjb2xsZWN0aW9uU3RhcnRpbmc6IGNvbGxlY3Rpb25TdGFydGluZ1xuICAgIH0sIGxhenlEaXNwYXRjaCk7XG4gIH0sIFtsYXp5RGlzcGF0Y2hdKTtcbiAgdmFyIHJlZ2lzdHJ5ID0gdXNlUmVnaXN0cnkoKTtcbiAgdmFyIGRpbWVuc2lvbk1hcnNoYWwgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlRGltZW5zaW9uTWFyc2hhbChyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrcyk7XG4gIH0sIFtyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrc10pO1xuICB2YXIgYXV0b1Njcm9sbGVyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUF1dG9TY3JvbGxlcihfZXh0ZW5kcyh7XG4gICAgICBzY3JvbGxXaW5kb3c6IHNjcm9sbFdpbmRvdyxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogZGltZW5zaW9uTWFyc2hhbC5zY3JvbGxEcm9wcGFibGVcbiAgICB9LCBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgbW92ZTogbW92ZVxuICAgIH0sIGxhenlEaXNwYXRjaCkpKTtcbiAgfSwgW2RpbWVuc2lvbk1hcnNoYWwuc2Nyb2xsRHJvcHBhYmxlLCBsYXp5RGlzcGF0Y2hdKTtcbiAgdmFyIGZvY3VzTWFyc2hhbCA9IHVzZUZvY3VzTWFyc2hhbChjb250ZXh0SWQpO1xuICB2YXIgc3RvcmUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUoe1xuICAgICAgYW5ub3VuY2U6IGFubm91bmNlLFxuICAgICAgYXV0b1Njcm9sbGVyOiBhdXRvU2Nyb2xsZXIsXG4gICAgICBkaW1lbnNpb25NYXJzaGFsOiBkaW1lbnNpb25NYXJzaGFsLFxuICAgICAgZm9jdXNNYXJzaGFsOiBmb2N1c01hcnNoYWwsXG4gICAgICBnZXRSZXNwb25kZXJzOiBnZXRSZXNwb25kZXJzLFxuICAgICAgc3R5bGVNYXJzaGFsOiBzdHlsZU1hcnNoYWxcbiAgICB9KTtcbiAgfSwgW2Fubm91bmNlLCBhdXRvU2Nyb2xsZXIsIGRpbWVuc2lvbk1hcnNoYWwsIGZvY3VzTWFyc2hhbCwgZ2V0UmVzcG9uZGVycywgc3R5bGVNYXJzaGFsXSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAobGF6eVN0b3JlUmVmLmN1cnJlbnQgJiYgbGF6eVN0b3JlUmVmLmN1cnJlbnQgIT09IHN0b3JlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCd1bmV4cGVjdGVkIHN0b3JlIGNoYW5nZScpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIGxhenlTdG9yZVJlZi5jdXJyZW50ID0gc3RvcmU7XG4gIHZhciB0cnlSZXNldFN0b3JlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKTtcbiAgICB2YXIgc3RhdGUgPSBjdXJyZW50LmdldFN0YXRlKCk7XG5cbiAgICBpZiAoc3RhdGUucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgY3VycmVudC5kaXNwYXRjaChmbHVzaCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIGlzRHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiBzdGF0ZS5pc0RyYWdnaW5nIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnO1xuICB9LCBbXSk7XG4gIHZhciBhcHBDYWxsYmFja3MgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNEcmFnZ2luZzogaXNEcmFnZ2luZyxcbiAgICAgIHRyeUFib3J0OiB0cnlSZXNldFN0b3JlXG4gICAgfTtcbiAgfSwgW2lzRHJhZ2dpbmcsIHRyeVJlc2V0U3RvcmVdKTtcbiAgc2V0Q2FsbGJhY2tzKGFwcENhbGxiYWNrcyk7XG4gIHZhciBnZXRDYW5MaWZ0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGNhblN0YXJ0RHJhZyhnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCksIGlkKTtcbiAgfSwgW10pO1xuICB2YXIgZ2V0SXNNb3ZlbWVudEFsbG93ZWQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzTW92ZW1lbnRBbGxvd2VkKGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKSk7XG4gIH0sIFtdKTtcbiAgdmFyIGFwcENvbnRleHQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFyc2hhbDogZGltZW5zaW9uTWFyc2hhbCxcbiAgICAgIGZvY3VzOiBmb2N1c01hcnNoYWwsXG4gICAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICAgIGNhbkxpZnQ6IGdldENhbkxpZnQsXG4gICAgICBpc01vdmVtZW50QWxsb3dlZDogZ2V0SXNNb3ZlbWVudEFsbG93ZWQsXG4gICAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZDogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgICByZWdpc3RyeTogcmVnaXN0cnlcbiAgICB9O1xuICB9LCBbY29udGV4dElkLCBkaW1lbnNpb25NYXJzaGFsLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZm9jdXNNYXJzaGFsLCBnZXRDYW5MaWZ0LCBnZXRJc01vdmVtZW50QWxsb3dlZCwgcmVnaXN0cnldKTtcbiAgdXNlU2Vuc29yTWFyc2hhbCh7XG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgc3RvcmU6IHN0b3JlLFxuICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICBjdXN0b21TZW5zb3JzOiBzZW5zb3JzLFxuICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzOiBwcm9wcy5lbmFibGVEZWZhdWx0U2Vuc29ycyAhPT0gZmFsc2VcbiAgfSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyeVJlc2V0U3RvcmU7XG4gIH0sIFt0cnlSZXNldFN0b3JlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEFwcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYXBwQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICAgIHN0b3JlOiBzdG9yZVxuICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxuXG52YXIgY291bnQkMSA9IDA7XG5mdW5jdGlvbiByZXNldCQxKCkge1xuICBjb3VudCQxID0gMDtcbn1cbmZ1bmN0aW9uIHVzZUluc3RhbmNlQ291bnQoKSB7XG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIiArIGNvdW50JDErKztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiByZXNldFNlcnZlckNvbnRleHQoKSB7XG4gIHJlc2V0JDEoKTtcbiAgcmVzZXQoKTtcbn1cbmZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dChwcm9wcykge1xuICB2YXIgY29udGV4dElkID0gdXNlSW5zdGFuY2VDb3VudCgpO1xuICB2YXIgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gcHJvcHMuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zIHx8IHByZXNldC5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIG51bGwsIGZ1bmN0aW9uIChzZXRDYWxsYmFja3MpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHAsIHtcbiAgICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgICAgc2V0Q2FsbGJhY2tzOiBzZXRDYWxsYmFja3MsXG4gICAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzOiBwcm9wcy5lbmFibGVEZWZhdWx0U2Vuc29ycyxcbiAgICAgIHNlbnNvcnM6IHByb3BzLnNlbnNvcnMsXG4gICAgICBvbkJlZm9yZUNhcHR1cmU6IHByb3BzLm9uQmVmb3JlQ2FwdHVyZSxcbiAgICAgIG9uQmVmb3JlRHJhZ1N0YXJ0OiBwcm9wcy5vbkJlZm9yZURyYWdTdGFydCxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlLFxuICAgICAgb25EcmFnRW5kOiBwcm9wcy5vbkRyYWdFbmRcbiAgICB9LCBwcm9wcy5jaGlsZHJlbik7XG4gIH0pO1xufVxuXG52YXIgaXNFcXVhbCQxID0gZnVuY3Rpb24gaXNFcXVhbChiYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYmFzZSA9PT0gdmFsdWU7XG4gIH07XG59O1xuXG52YXIgaXNTY3JvbGwgPSBpc0VxdWFsJDEoJ3Njcm9sbCcpO1xudmFyIGlzQXV0byA9IGlzRXF1YWwkMSgnYXV0bycpO1xudmFyIGlzVmlzaWJsZSQxID0gaXNFcXVhbCQxKCd2aXNpYmxlJyk7XG5cbnZhciBpc0VpdGhlciA9IGZ1bmN0aW9uIGlzRWl0aGVyKG92ZXJmbG93LCBmbikge1xuICByZXR1cm4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSB8fCBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xufTtcblxudmFyIGlzQm90aCA9IGZ1bmN0aW9uIGlzQm90aChvdmVyZmxvdywgZm4pIHtcbiAgcmV0dXJuIGZuKG92ZXJmbG93Lm92ZXJmbG93WCkgJiYgZm4ob3ZlcmZsb3cub3ZlcmZsb3dZKTtcbn07XG5cbnZhciBpc0VsZW1lbnRTY3JvbGxhYmxlID0gZnVuY3Rpb24gaXNFbGVtZW50U2Nyb2xsYWJsZShlbCkge1xuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciBvdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IHN0eWxlLm92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1k6IHN0eWxlLm92ZXJmbG93WVxuICB9O1xuICByZXR1cm4gaXNFaXRoZXIob3ZlcmZsb3csIGlzU2Nyb2xsKSB8fCBpc0VpdGhlcihvdmVyZmxvdywgaXNBdXRvKTtcbn07XG5cbnZhciBpc0JvZHlTY3JvbGxhYmxlID0gZnVuY3Rpb24gaXNCb2R5U2Nyb2xsYWJsZSgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAhaHRtbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBodG1sU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcbiAgdmFyIGh0bWxPdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IGh0bWxTdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBodG1sU3R5bGUub3ZlcmZsb3dZXG4gIH07XG5cbiAgaWYgKGlzQm90aChodG1sT3ZlcmZsb3csIGlzVmlzaWJsZSQxKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgV2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHlvdXIgPGJvZHk+IGVsZW1lbnQgbWlnaHQgYmUgYSBzY3JvbGwgY29udGFpbmVyLlxcbiAgICBXZSBoYXZlIGZvdW5kIG5vIHJlbGlhYmxlIHdheSBvZiBkZXRlY3Rpbmcgd2hldGhlciB0aGUgPGJvZHk+IGVsZW1lbnQgaXMgYSBzY3JvbGwgY29udGFpbmVyLlxcbiAgICBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMgYSA8Ym9keT4gc2Nyb2xsIGJhciB3aWxsIGJlIG9uIHRoZSA8aHRtbD4gZWxlbWVudCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxcblxcbiAgICBCZWNhdXNlIHdlIGNhbm5vdCBkZXRlcm1pbmUgaWYgdGhlIDxib2R5PiBpcyBhIHNjcm9sbCBjb250YWluZXIsIGFuZCBnZW5lcmFsbHkgaXQgaXMgbm90IG9uZSxcXG4gICAgd2Ugd2lsbCBiZSB0cmVhdGluZyB0aGUgPGJvZHk+IGFzICpub3QqIGEgc2Nyb2xsIGNvbnRhaW5lclxcblxcbiAgICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvYmxvYi9tYXN0ZXIvZG9jcy9ndWlkZXMvaG93LXdlLWRldGVjdC1zY3JvbGwtY29udGFpbmVycy5tZFxcbiAgXCIpIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgZ2V0Q2xvc2VzdFNjcm9sbGFibGUgPSBmdW5jdGlvbiBnZXRDbG9zZXN0U2Nyb2xsYWJsZShlbCkge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIGlzQm9keVNjcm9sbGFibGUoKSA/IGVsIDogbnVsbDtcbiAgfVxuXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzRWxlbWVudFNjcm9sbGFibGUoZWwpKSB7XG4gICAgcmV0dXJuIGdldENsb3Nlc3RTY3JvbGxhYmxlKGVsLnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyA9IChmdW5jdGlvbiAoc2Nyb2xsYWJsZSkge1xuICBpZiAoIXNjcm9sbGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYW5vdGhlclNjcm9sbFBhcmVudCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHNjcm9sbGFibGUucGFyZW50RWxlbWVudCk7XG5cbiAgaWYgKCFhbm90aGVyU2Nyb2xsUGFyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICBEcm9wcGFibGU6IHVuc3VwcG9ydGVkIG5lc3RlZCBzY3JvbGwgY29udGFpbmVyIGRldGVjdGVkLlxcbiAgICBBIERyb3BwYWJsZSBjYW4gb25seSBoYXZlIG9uZSBzY3JvbGwgcGFyZW50ICh3aGljaCBjYW4gYmUgaXRzZWxmKVxcbiAgICBOZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxcblxcbiAgICBXZSBob3BlIHRvIHN1cHBvcnQgbmVzdGVkIHNjcm9sbCBjb250YWluZXJzIHNvb246IGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9pc3N1ZXMvMTMxXFxuICBcIikgOiB2b2lkIDA7XG59KTtcblxudmFyIGdldFNjcm9sbCQxID0gKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4ge1xuICAgIHg6IGVsLnNjcm9sbExlZnQsXG4gICAgeTogZWwuc2Nyb2xsVG9wXG4gIH07XG59KTtcblxudmFyIGdldElzRml4ZWQgPSBmdW5jdGlvbiBnZXRJc0ZpeGVkKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZ2V0SXNGaXhlZChlbC5wYXJlbnRFbGVtZW50KTtcbn07XG5cbnZhciBnZXRFbnYgPSAoZnVuY3Rpb24gKHN0YXJ0KSB7XG4gIHZhciBjbG9zZXN0U2Nyb2xsYWJsZSA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHN0YXJ0KTtcbiAgdmFyIGlzRml4ZWRPblBhZ2UgPSBnZXRJc0ZpeGVkKHN0YXJ0KTtcbiAgcmV0dXJuIHtcbiAgICBjbG9zZXN0U2Nyb2xsYWJsZTogY2xvc2VzdFNjcm9sbGFibGUsXG4gICAgaXNGaXhlZE9uUGFnZTogaXNGaXhlZE9uUGFnZVxuICB9O1xufSk7XG5cbnZhciBnZXREcm9wcGFibGVEaW1lbnNpb24gPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBfcmVmLmRlc2NyaXB0b3IsXG4gICAgICBpc0VuYWJsZWQgPSBfcmVmLmlzRW5hYmxlZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQgPSBfcmVmLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBpc0ZpeGVkT25QYWdlID0gX3JlZi5pc0ZpeGVkT25QYWdlLFxuICAgICAgZGlyZWN0aW9uID0gX3JlZi5kaXJlY3Rpb24sXG4gICAgICBjbGllbnQgPSBfcmVmLmNsaWVudCxcbiAgICAgIHBhZ2UgPSBfcmVmLnBhZ2UsXG4gICAgICBjbG9zZXN0ID0gX3JlZi5jbG9zZXN0O1xuXG4gIHZhciBmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxTaXplID0gY2xvc2VzdC5zY3JvbGxTaXplLFxuICAgICAgICBmcmFtZUNsaWVudCA9IGNsb3Nlc3QuY2xpZW50O1xuICAgIHZhciBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBzY3JvbGxTaXplLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBzY3JvbGxTaXplLnNjcm9sbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LmhlaWdodCxcbiAgICAgIHdpZHRoOiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LndpZHRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VNYXJnaW5Cb3g6IGNsb3Nlc3QucGFnZS5tYXJnaW5Cb3gsXG4gICAgICBmcmFtZUNsaWVudDogZnJhbWVDbGllbnQsXG4gICAgICBzY3JvbGxTaXplOiBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6IGNsb3Nlc3Quc2hvdWxkQ2xpcFN1YmplY3QsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgaW5pdGlhbDogY2xvc2VzdC5zY3JvbGwsXG4gICAgICAgIGN1cnJlbnQ6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgICAgZGlmZjoge1xuICAgICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgYXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHZlcnRpY2FsIDogaG9yaXpvbnRhbDtcbiAgdmFyIHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBheGlzOiBheGlzLFxuICAgIGZyYW1lOiBmcmFtZVxuICB9KTtcbiAgdmFyIGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaXNGaXhlZE9uUGFnZTogaXNGaXhlZE9uUGFnZSxcbiAgICBheGlzOiBheGlzLFxuICAgIGlzRW5hYmxlZDogaXNFbmFibGVkLFxuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHBhZ2U6IHBhZ2UsXG4gICAgZnJhbWU6IGZyYW1lLFxuICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn0pO1xuXG52YXIgZ2V0Q2xpZW50ID0gZnVuY3Rpb24gZ2V0Q2xpZW50KHRhcmdldFJlZiwgY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgdmFyIGJhc2UgPSBnZXRCb3godGFyZ2V0UmVmKTtcblxuICBpZiAoIWNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICBpZiAodGFyZ2V0UmVmICE9PSBjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgdmFyIHRvcCA9IGJhc2UucGFkZGluZ0JveC50b3AgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxUb3A7XG4gIHZhciBsZWZ0ID0gYmFzZS5wYWRkaW5nQm94LmxlZnQgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxMZWZ0O1xuICB2YXIgYm90dG9tID0gdG9wICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0O1xuICB2YXIgcmlnaHQgPSBsZWZ0ICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGg7XG4gIHZhciBwYWRkaW5nQm94ID0ge1xuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICBsZWZ0OiBsZWZ0XG4gIH07XG4gIHZhciBib3JkZXJCb3ggPSBleHBhbmQocGFkZGluZ0JveCwgYmFzZS5ib3JkZXIpO1xuICB2YXIgY2xpZW50ID0gY3JlYXRlQm94KHtcbiAgICBib3JkZXJCb3g6IGJvcmRlckJveCxcbiAgICBtYXJnaW46IGJhc2UubWFyZ2luLFxuICAgIGJvcmRlcjogYmFzZS5ib3JkZXIsXG4gICAgcGFkZGluZzogYmFzZS5wYWRkaW5nXG4gIH0pO1xuICByZXR1cm4gY2xpZW50O1xufTtcblxudmFyIGdldERpbWVuc2lvbiA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmVmID0gX3JlZi5yZWYsXG4gICAgICBkZXNjcmlwdG9yID0gX3JlZi5kZXNjcmlwdG9yLFxuICAgICAgZW52ID0gX3JlZi5lbnYsXG4gICAgICB3aW5kb3dTY3JvbGwgPSBfcmVmLndpbmRvd1Njcm9sbCxcbiAgICAgIGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgICAgaXNEcm9wRGlzYWJsZWQgPSBfcmVmLmlzRHJvcERpc2FibGVkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZCA9IF9yZWYuaXNDb21iaW5lRW5hYmxlZCxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0ID0gX3JlZi5zaG91bGRDbGlwU3ViamVjdDtcbiAgdmFyIGNsb3Nlc3RTY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICB2YXIgY2xpZW50ID0gZ2V0Q2xpZW50KHJlZiwgY2xvc2VzdFNjcm9sbGFibGUpO1xuICB2YXIgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCB3aW5kb3dTY3JvbGwpO1xuXG4gIHZhciBjbG9zZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcmFtZUNsaWVudCA9IGdldEJveChjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gICAgdmFyIHNjcm9sbFNpemUgPSB7XG4gICAgICBzY3JvbGxIZWlnaHQ6IGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudDogZnJhbWVDbGllbnQsXG4gICAgICBwYWdlOiB3aXRoU2Nyb2xsKGZyYW1lQ2xpZW50LCB3aW5kb3dTY3JvbGwpLFxuICAgICAgc2Nyb2xsOiBnZXRTY3JvbGwkMShjbG9zZXN0U2Nyb2xsYWJsZSksXG4gICAgICBzY3JvbGxTaXplOiBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6IHNob3VsZENsaXBTdWJqZWN0XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBkaW1lbnNpb24gPSBnZXREcm9wcGFibGVEaW1lbnNpb24oe1xuICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgaXNFbmFibGVkOiAhaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZDogaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpc0ZpeGVkT25QYWdlOiBlbnYuaXNGaXhlZE9uUGFnZSxcbiAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICBjbGllbnQ6IGNsaWVudCxcbiAgICBwYWdlOiBwYWdlLFxuICAgIGNsb3Nlc3Q6IGNsb3Nlc3RcbiAgfSk7XG4gIHJldHVybiBkaW1lbnNpb247XG59KTtcblxudmFyIGltbWVkaWF0ZSA9IHtcbiAgcGFzc2l2ZTogZmFsc2Vcbn07XG52YXIgZGVsYXllZCA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbnZhciBnZXRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5ID8gaW1tZWRpYXRlIDogZGVsYXllZDtcbn0pO1xuXG5mdW5jdGlvbiB1c2VSZXF1aXJlZENvbnRleHQoQ29udGV4dCkge1xuICB2YXIgcmVzdWx0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgIXJlc3VsdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHJlcXVpcmVkIGNvbnRleHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZykge1xuICByZXR1cm4gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlIHx8IG51bGw7XG59O1xuXG5mdW5jdGlvbiB1c2VEcm9wcGFibGVQdWJsaXNoZXIoYXJncykge1xuICB2YXIgd2hpbGVEcmFnZ2luZ1JlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGFwcENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIHZhciB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdkcm9wcGFibGUnKTtcbiAgdmFyIHJlZ2lzdHJ5ID0gYXBwQ29udGV4dC5yZWdpc3RyeSxcbiAgICAgIG1hcnNoYWwgPSBhcHBDb250ZXh0Lm1hcnNoYWw7XG4gIHZhciBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKGFyZ3MpO1xuICB2YXIgZGVzY3JpcHRvciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogYXJncy5kcm9wcGFibGVJZCxcbiAgICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICAgIG1vZGU6IGFyZ3MubW9kZVxuICAgIH07XG4gIH0sIFthcmdzLmRyb3BwYWJsZUlkLCBhcmdzLm1vZGUsIGFyZ3MudHlwZV0pO1xuICB2YXIgcHVibGlzaGVkRGVzY3JpcHRvclJlZiA9IHVzZVJlZihkZXNjcmlwdG9yKTtcbiAgdmFyIG1lbW9pemVkVXBkYXRlU2Nyb2xsID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lbW9pemVPbmUoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgc2Nyb2xsIHdoZW4gZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgc2Nyb2xsID0ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVTY3JvbGwoZGVzY3JpcHRvci5pZCwgc2Nyb2xsKTtcbiAgICB9KTtcbiAgfSwgW2Rlc2NyaXB0b3IuaWQsIG1hcnNoYWxdKTtcbiAgdmFyIGdldENsb3Nlc3RTY3JvbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuXG4gICAgaWYgKCFkcmFnZ2luZyB8fCAhZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTY3JvbGwkMShkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpO1xuICB9LCBbXSk7XG4gIHZhciB1cGRhdGVTY3JvbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbCA9IGdldENsb3Nlc3RTY3JvbGwoKTtcbiAgICBtZW1vaXplZFVwZGF0ZVNjcm9sbChzY3JvbGwueCwgc2Nyb2xsLnkpO1xuICB9LCBbZ2V0Q2xvc2VzdFNjcm9sbCwgbWVtb2l6ZWRVcGRhdGVTY3JvbGxdKTtcbiAgdmFyIHNjaGVkdWxlU2Nyb2xsVXBkYXRlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhZlNjaGQodXBkYXRlU2Nyb2xsKTtcbiAgfSwgW3VwZGF0ZVNjcm9sbF0pO1xuICB2YXIgb25DbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICB2YXIgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzY3JvbGwgb3B0aW9ucyB3aGlsZSBzY3JvbGxpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIG9wdGlvbnMgPSBkcmFnZ2luZy5zY3JvbGxPcHRpb25zO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5KSB7XG4gICAgICB1cGRhdGVTY3JvbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZSgpO1xuICB9LCBbc2NoZWR1bGVTY3JvbGxVcGRhdGUsIHVwZGF0ZVNjcm9sbF0pO1xuICB2YXIgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAod2luZG93U2Nyb2xsLCBvcHRpb25zKSB7XG4gICAgISF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCBhIGRyb3BwYWJsZSB3aGlsZSBhIGRyYWcgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBwcmV2aW91cyA9IHByZXZpb3VzUmVmLmN1cnJlbnQ7XG4gICAgdmFyIHJlZiA9IHByZXZpb3VzLmdldERyb3BwYWJsZVJlZigpO1xuICAgICFyZWYgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCB3aXRob3V0IGEgZHJvcHBhYmxlIHJlZicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZW52ID0gZ2V0RW52KHJlZik7XG4gICAgdmFyIGRyYWdnaW5nID0ge1xuICAgICAgcmVmOiByZWYsXG4gICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgZW52OiBlbnYsXG4gICAgICBzY3JvbGxPcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBkcmFnZ2luZztcbiAgICB2YXIgZGltZW5zaW9uID0gZ2V0RGltZW5zaW9uKHtcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgIGVudjogZW52LFxuICAgICAgd2luZG93U2Nyb2xsOiB3aW5kb3dTY3JvbGwsXG4gICAgICBkaXJlY3Rpb246IHByZXZpb3VzLmRpcmVjdGlvbixcbiAgICAgIGlzRHJvcERpc2FibGVkOiBwcmV2aW91cy5pc0Ryb3BEaXNhYmxlZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQ6IHByZXZpb3VzLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdDogIXByZXZpb3VzLmlnbm9yZUNvbnRhaW5lckNsaXBwaW5nXG4gICAgfSk7XG4gICAgdmFyIHNjcm9sbGFibGUgPSBlbnYuY2xvc2VzdFNjcm9sbGFibGU7XG5cbiAgICBpZiAoc2Nyb2xsYWJsZSkge1xuICAgICAgc2Nyb2xsYWJsZS5zZXRBdHRyaWJ1dGUoc2Nyb2xsQ29udGFpbmVyLmNvbnRleHRJZCwgYXBwQ29udGV4dC5jb250ZXh0SWQpO1xuICAgICAgc2Nyb2xsYWJsZS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbkNsb3Nlc3RTY3JvbGwsIGdldExpc3RlbmVyT3B0aW9ucyhkcmFnZ2luZy5zY3JvbGxPcHRpb25zKSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyhzY3JvbGxhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9LCBbYXBwQ29udGV4dC5jb250ZXh0SWQsIGRlc2NyaXB0b3IsIG9uQ2xvc2VzdFNjcm9sbCwgcHJldmlvdXNSZWZdKTtcbiAgdmFyIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIHZhciBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHJlY29sbGVjdCBEcm9wcGFibGUgY2xpZW50IGZvciBEcm9wcGFibGVzIHRoYXQgaGF2ZSBhIHNjcm9sbCBjb250YWluZXInKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldFNjcm9sbCQxKGNsb3Nlc3QpO1xuICB9LCBbXSk7XG4gIHZhciBkcmFnU3RvcHBlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3AgZHJhZyB3aGVuIG5vIGFjdGl2ZSBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlLmNhbmNlbCgpO1xuICAgIGNsb3Nlc3QucmVtb3ZlQXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQpO1xuICAgIGNsb3Nlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICB9LCBbb25DbG9zZXN0U2Nyb2xsLCBzY2hlZHVsZVNjcm9sbFVwZGF0ZV0pO1xuICB2YXIgc2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgIHZhciBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICFjbG9zZXN0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNjcm9sbCBhIGRyb3BwYWJsZSB3aXRoIG5vIGNsb3Nlc3Qgc2Nyb2xsYWJsZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjbG9zZXN0LnNjcm9sbFRvcCArPSBjaGFuZ2UueTtcbiAgICBjbG9zZXN0LnNjcm9sbExlZnQgKz0gY2hhbmdlLng7XG4gIH0sIFtdKTtcbiAgdmFyIGNhbGxiYWNrcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbDogZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsXG4gICAgICBnZXRTY3JvbGxXaGlsZURyYWdnaW5nOiBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLFxuICAgICAgZHJhZ1N0b3BwZWQ6IGRyYWdTdG9wcGVkLFxuICAgICAgc2Nyb2xsOiBzY3JvbGxcbiAgICB9O1xuICB9LCBbZHJhZ1N0b3BwZWQsIGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsLCBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLCBzY3JvbGxdKTtcbiAgdmFyIGVudHJ5ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXF1ZUlkOiB1bmlxdWVJZCxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICBjYWxsYmFja3M6IGNhbGxiYWNrc1xuICAgIH07XG4gIH0sIFtjYWxsYmFja3MsIGRlc2NyaXB0b3IsIHVuaXF1ZUlkXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudCA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLnJlZ2lzdGVyKGVudHJ5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdVbnN1cHBvcnRlZDogY2hhbmdpbmcgdGhlIGRyb3BwYWJsZUlkIG9yIHR5cGUgb2YgYSBEcm9wcGFibGUgZHVyaW5nIGEgZHJhZycpIDogdm9pZCAwO1xuICAgICAgICBkcmFnU3RvcHBlZCgpO1xuICAgICAgfVxuXG4gICAgICByZWdpc3RyeS5kcm9wcGFibGUudW5yZWdpc3RlcihlbnRyeSk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgZHJhZ1N0b3BwZWQsIGVudHJ5LCBtYXJzaGFsLCByZWdpc3RyeS5kcm9wcGFibGVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsICFhcmdzLmlzRHJvcERpc2FibGVkKTtcbiAgfSwgW2FyZ3MuaXNEcm9wRGlzYWJsZWQsIG1hcnNoYWxdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQocHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50LmlkLCBhcmdzLmlzQ29tYmluZUVuYWJsZWQpO1xuICB9LCBbYXJncy5pc0NvbWJpbmVFbmFibGVkLCBtYXJzaGFsXSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbnZhciBlbXB0eSA9IHtcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbWFyZ2luOiBub1NwYWNpbmdcbn07XG5cbnZhciBnZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZShfcmVmKSB7XG4gIHZhciBpc0FuaW1hdGluZ09wZW5Pbk1vdW50ID0gX3JlZi5pc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmLnBsYWNlaG9sZGVyLFxuICAgICAgYW5pbWF0ZSA9IF9yZWYuYW5pbWF0ZTtcblxuICBpZiAoaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuXG4gIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHdpZHRoOiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LndpZHRoLFxuICAgIG1hcmdpbjogcGxhY2Vob2xkZXIuY2xpZW50Lm1hcmdpblxuICB9O1xufTtcblxudmFyIGdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoX3JlZjIpIHtcbiAgdmFyIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQgPSBfcmVmMi5pc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmMi5wbGFjZWhvbGRlcixcbiAgICAgIGFuaW1hdGUgPSBfcmVmMi5hbmltYXRlO1xuICB2YXIgc2l6ZSA9IGdldFNpemUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQ6IGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgIGFuaW1hdGU6IGFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxheTogcGxhY2Vob2xkZXIuZGlzcGxheSxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgIG1hcmdpblRvcDogc2l6ZS5tYXJnaW4udG9wLFxuICAgIG1hcmdpblJpZ2h0OiBzaXplLm1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW5Cb3R0b206IHNpemUubWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW5MZWZ0OiBzaXplLm1hcmdpbi5sZWZ0LFxuICAgIGZsZXhTaHJpbms6ICcwJyxcbiAgICBmbGV4R3JvdzogJzAnLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB0cmFuc2l0aW9uOiBhbmltYXRlICE9PSAnbm9uZScgPyB0cmFuc2l0aW9ucy5wbGFjZWhvbGRlciA6IG51bGxcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHByb3BzKSB7XG4gIHZhciBhbmltYXRlT3BlblRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmICghYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW10pO1xuICB2YXIgYW5pbWF0ZSA9IHByb3BzLmFuaW1hdGUsXG4gICAgICBvblRyYW5zaXRpb25FbmQgPSBwcm9wcy5vblRyYW5zaXRpb25FbmQsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIGNvbnRleHRJZCA9IHByb3BzLmNvbnRleHRJZDtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUocHJvcHMuYW5pbWF0ZSA9PT0gJ29wZW4nKSxcbiAgICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50ID0gX3VzZVN0YXRlWzFdO1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc0FuaW1hdGluZ09wZW5Pbk1vdW50KSB7XG4gICAgICByZXR1cm4gbm9vcCQyO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcigpO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgICByZXR1cm4gbm9vcCQyO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybiBub29wJDI7XG4gICAgfVxuXG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcjtcbiAgfSwgW2FuaW1hdGUsIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcl0pO1xuICB2YXIgb25TaXplQ2hhbmdlRW5kID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvblRyYW5zaXRpb25FbmQoKTtcblxuICAgIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBbYW5pbWF0ZSwgb25DbG9zZSwgb25UcmFuc2l0aW9uRW5kXSk7XG4gIHZhciBzdHlsZSA9IGdldFN0eWxlKHtcbiAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50OiBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgIGFuaW1hdGU6IHByb3BzLmFuaW1hdGUsXG4gICAgcGxhY2Vob2xkZXI6IHByb3BzLnBsYWNlaG9sZGVyXG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wcy5wbGFjZWhvbGRlci50YWdOYW1lLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgICdkYXRhLXJiZC1wbGFjZWhvbGRlci1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25TaXplQ2hhbmdlRW5kLFxuICAgIHJlZjogcHJvcHMuaW5uZXJSZWZcbiAgfSk7XG59XG5cbnZhciBQbGFjZWhvbGRlciQxID0gUmVhY3QubWVtbyhQbGFjZWhvbGRlcik7XG5cbnZhciBEcm9wcGFibGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZWwpIHtcbiAgIShlbCAmJiBpc0h0bWxFbGVtZW50KGVsKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiXFxuICAgIHByb3ZpZGVkLmlubmVyUmVmIGhhcyBub3QgYmVlbiBwcm92aWRlZCB3aXRoIGEgSFRNTEVsZW1lbnQuXFxuXFxuICAgIFlvdSBjYW4gZmluZCBhIGd1aWRlIG9uIHVzaW5nIHRoZSBpbm5lclJlZiBjYWxsYmFjayBmdW5jdGlvbnMgYXQ6XFxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9ibG9iL21hc3Rlci9kb2NzL2d1aWRlcy91c2luZy1pbm5lci1yZWYubWRcXG4gIFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5cbmZ1bmN0aW9uIHJ1bkNoZWNrcyhhcmdzLCBjaGVja3MpIHtcbiAgY2hlY2tzLmZvckVhY2goZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgcmV0dXJuIGNoZWNrKGFyZ3MpO1xuICB9KTtcbn1cblxudmFyIHNoYXJlZCA9IFtmdW5jdGlvbiByZXF1aXJlZChfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICFwcm9wcy5kcm9wcGFibGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRHJvcHBhYmxlIHJlcXVpcmVzIGEgZHJvcHBhYmxlSWQgcHJvcCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISh0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJBIERyb3BwYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyb3BwYWJsZUlkLiBQcm92aWRlZDogW1wiICsgdHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkICsgXCJdXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIF9ib29sZWFuKF9yZWYyKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAhaXNCb29sZWFuKHByb3BzLmlzRHJvcERpc2FibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzRHJvcERpc2FibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNDb21iaW5lRW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpZ25vcmVDb250YWluZXJDbGlwcGluZyBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIHJlZihfcmVmMykge1xuICB2YXIgZ2V0RHJvcHBhYmxlUmVmID0gX3JlZjMuZ2V0RHJvcHBhYmxlUmVmO1xuICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXREcm9wcGFibGVSZWYoKSk7XG59XTtcbnZhciBzdGFuZGFyZCA9IFtmdW5jdGlvbiBwbGFjZWhvbGRlcihfcmVmNCkge1xuICB2YXIgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgIGdldFBsYWNlaG9sZGVyUmVmID0gX3JlZjQuZ2V0UGxhY2Vob2xkZXJSZWY7XG5cbiAgaWYgKCFwcm9wcy5wbGFjZWhvbGRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWYgPSBnZXRQbGFjZWhvbGRlclJlZigpO1xuXG4gIGlmIChyZWYpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgRHJvcHBhYmxlIHNldHVwIGlzc3VlIFtkcm9wcGFibGVJZDogXFxcIlwiICsgcHJvcHMuZHJvcHBhYmxlSWQgKyBcIlxcXCJdOlxcbiAgICAgIERyb3BwYWJsZVByb3ZpZGVkID4gcGxhY2Vob2xkZXIgY291bGQgbm90IGJlIGZvdW5kLlxcblxcbiAgICAgIFBsZWFzZSBiZSBzdXJlIHRvIGFkZCB0aGUge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfSBSZWFjdCBOb2RlIGFzIGEgY2hpbGQgb2YgeW91ciBEcm9wcGFibGUuXFxuICAgICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvYXBpL2Ryb3BwYWJsZS5tZFxcbiAgICBcIikgOiB2b2lkIDA7XG59XTtcbnZhciB2aXJ0dWFsID0gW2Z1bmN0aW9uIGhhc0Nsb25lKF9yZWY1KSB7XG4gIHZhciBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAhcHJvcHMucmVuZGVyQ2xvbmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IHByb3ZpZGUgYSBjbG9uZSByZW5kZXIgZnVuY3Rpb24gKHJlbmRlckNsb25lKSBmb3IgdmlydHVhbCBsaXN0cycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIGhhc05vUGxhY2Vob2xkZXIoX3JlZjYpIHtcbiAgdmFyIGdldFBsYWNlaG9sZGVyUmVmID0gX3JlZjYuZ2V0UGxhY2Vob2xkZXJSZWY7XG4gICEhZ2V0UGxhY2Vob2xkZXJSZWYoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHZpcnR1YWwgbGlzdCB0byBub3QgaGF2ZSBhIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufV07XG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uKGFyZ3MpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKGZ1bmN0aW9uICgpIHtcbiAgICBydW5DaGVja3MoYXJncywgc2hhcmVkKTtcblxuICAgIGlmIChhcmdzLnByb3BzLm1vZGUgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAgIHJ1bkNoZWNrcyhhcmdzLCBzdGFuZGFyZCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgdmlydHVhbCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIEFuaW1hdGVJbk91dCA9IGZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShBbmltYXRlSW5PdXQsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBBbmltYXRlSW5PdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JFB1cmVDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkUHVyZUNvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihfdGhpcy5wcm9wcy5vbiksXG4gICAgICBkYXRhOiBfdGhpcy5wcm9wcy5vbixcbiAgICAgIGFuaW1hdGU6IF90aGlzLnByb3BzLnNob3VsZEFuaW1hdGUgJiYgX3RoaXMucHJvcHMub24gPyAnb3BlbicgOiAnbm9uZSdcbiAgICB9O1xuXG4gICAgX3RoaXMub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5hbmltYXRlICE9PSAnY2xvc2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQW5pbWF0ZUluT3V0LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoIXByb3BzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihwcm9wcy5vbiksXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnbm9uZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnb3BlbidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLFxuICAgICAgICBhbmltYXRlOiAnY2xvc2UnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogJ2Nsb3NlJyxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBBbmltYXRlSW5PdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByb3ZpZGVkID0ge1xuICAgICAgb25DbG9zZTogdGhpcy5vbkNsb3NlLFxuICAgICAgZGF0YTogdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgYW5pbWF0ZTogdGhpcy5zdGF0ZS5hbmltYXRlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbihwcm92aWRlZCk7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGVJbk91dDtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbnZhciB6SW5kZXhPcHRpb25zID0ge1xuICBkcmFnZ2luZzogNTAwMCxcbiAgZHJvcEFuaW1hdGluZzogNDUwMFxufTtcblxudmFyIGdldERyYWdnaW5nVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGdldERyYWdnaW5nVHJhbnNpdGlvbihzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50LCBkcm9wcGluZykge1xuICBpZiAoZHJvcHBpbmcpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbnMuZHJvcChkcm9wcGluZy5kdXJhdGlvbik7XG4gIH1cblxuICBpZiAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5zbmFwO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zaXRpb25zLmZsdWlkO1xufTtcblxudmFyIGdldERyYWdnaW5nT3BhY2l0eSA9IGZ1bmN0aW9uIGdldERyYWdnaW5nT3BhY2l0eShpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSB7XG4gIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBpc0Ryb3BBbmltYXRpbmcgPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IGNvbWJpbmUub3BhY2l0eS5jb21iaW5pbmc7XG59O1xuXG52YXIgZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlID0gZnVuY3Rpb24gZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlKGRyYWdnaW5nKSB7XG4gIGlmIChkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGUgIT0gbnVsbCkge1xuICAgIHJldHVybiBkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cblxuICByZXR1cm4gZHJhZ2dpbmcubW9kZSA9PT0gJ1NOQVAnO1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdTdHlsZShkcmFnZ2luZykge1xuICB2YXIgZGltZW5zaW9uID0gZHJhZ2dpbmcuZGltZW5zaW9uO1xuICB2YXIgYm94ID0gZGltZW5zaW9uLmNsaWVudDtcbiAgdmFyIG9mZnNldCA9IGRyYWdnaW5nLm9mZnNldCxcbiAgICAgIGNvbWJpbmVXaXRoID0gZHJhZ2dpbmcuY29tYmluZVdpdGgsXG4gICAgICBkcm9wcGluZyA9IGRyYWdnaW5nLmRyb3BwaW5nO1xuICB2YXIgaXNDb21iaW5pbmcgPSBCb29sZWFuKGNvbWJpbmVXaXRoKTtcbiAgdmFyIHNob3VsZEFuaW1hdGUgPSBnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUoZHJhZ2dpbmcpO1xuICB2YXIgaXNEcm9wQW5pbWF0aW5nID0gQm9vbGVhbihkcm9wcGluZyk7XG4gIHZhciB0cmFuc2Zvcm0gPSBpc0Ryb3BBbmltYXRpbmcgPyB0cmFuc2Zvcm1zLmRyb3Aob2Zmc2V0LCBpc0NvbWJpbmluZykgOiB0cmFuc2Zvcm1zLm1vdmVUbyhvZmZzZXQpO1xuICB2YXIgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgdG9wOiBib3gubWFyZ2luQm94LnRvcCxcbiAgICBsZWZ0OiBib3gubWFyZ2luQm94LmxlZnQsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IGJveC5ib3JkZXJCb3gud2lkdGgsXG4gICAgaGVpZ2h0OiBib3guYm9yZGVyQm94LmhlaWdodCxcbiAgICB0cmFuc2l0aW9uOiBnZXREcmFnZ2luZ1RyYW5zaXRpb24oc2hvdWxkQW5pbWF0ZSwgZHJvcHBpbmcpLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIG9wYWNpdHk6IGdldERyYWdnaW5nT3BhY2l0eShpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSxcbiAgICB6SW5kZXg6IGlzRHJvcEFuaW1hdGluZyA/IHpJbmRleE9wdGlvbnMuZHJvcEFuaW1hdGluZyA6IHpJbmRleE9wdGlvbnMuZHJhZ2dpbmcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gIH07XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U3R5bGUoc2Vjb25kYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1zLm1vdmVUbyhzZWNvbmRhcnkub2Zmc2V0KSxcbiAgICB0cmFuc2l0aW9uOiBzZWNvbmRhcnkuc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCA/IG51bGwgOiAnbm9uZSdcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGUkMShtYXBwZWQpIHtcbiAgcmV0dXJuIG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnID8gZ2V0RHJhZ2dpbmdTdHlsZShtYXBwZWQpIDogZ2V0U2Vjb25kYXJ5U3R5bGUobWFwcGVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCkge1xuICBpZiAod2luZG93U2Nyb2xsID09PSB2b2lkIDApIHtcbiAgICB3aW5kb3dTY3JvbGwgPSBvcmlnaW47XG4gIH1cblxuICB2YXIgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciBib3JkZXJCb3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGNsaWVudCA9IGNhbGN1bGF0ZUJveChib3JkZXJCb3gsIGNvbXB1dGVkU3R5bGVzKTtcbiAgdmFyIHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgdmFyIHBsYWNlaG9sZGVyID0ge1xuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHRhZ05hbWU6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICBkaXNwbGF5OiBjb21wdXRlZFN0eWxlcy5kaXNwbGF5XG4gIH07XG4gIHZhciBkaXNwbGFjZUJ5ID0ge1xuICAgIHg6IGNsaWVudC5tYXJnaW5Cb3gud2lkdGgsXG4gICAgeTogY2xpZW50Lm1hcmdpbkJveC5oZWlnaHRcbiAgfTtcbiAgdmFyIGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICBkaXNwbGFjZUJ5OiBkaXNwbGFjZUJ5LFxuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHBhZ2U6IHBhZ2VcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgdmFyIHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQoJ2RyYWdnYWJsZScpO1xuICB2YXIgZGVzY3JpcHRvciA9IGFyZ3MuZGVzY3JpcHRvcixcbiAgICAgIHJlZ2lzdHJ5ID0gYXJncy5yZWdpc3RyeSxcbiAgICAgIGdldERyYWdnYWJsZVJlZiA9IGFyZ3MuZ2V0RHJhZ2dhYmxlUmVmLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgPSBhcmdzLmNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MgPSBhcmdzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgaXNFbmFibGVkID0gYXJncy5pc0VuYWJsZWQ7XG4gIHZhciBvcHRpb25zID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGlzRW5hYmxlZDogaXNFbmFibGVkXG4gICAgfTtcbiAgfSwgW2NhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBpc0VuYWJsZWQsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzXSk7XG4gIHZhciBnZXREaW1lbnNpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAod2luZG93U2Nyb2xsKSB7XG4gICAgdmFyIGVsID0gZ2V0RHJhZ2dhYmxlUmVmKCk7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBkaW1lbnNpb24gd2hlbiBubyByZWYgaXMgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBnZXREaW1lbnNpb24kMShkZXNjcmlwdG9yLCBlbCwgd2luZG93U2Nyb2xsKTtcbiAgfSwgW2Rlc2NyaXB0b3IsIGdldERyYWdnYWJsZVJlZl0pO1xuICB2YXIgZW50cnkgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pcXVlSWQ6IHVuaXF1ZUlkLFxuICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBnZXREaW1lbnNpb246IGdldERpbWVuc2lvblxuICAgIH07XG4gIH0sIFtkZXNjcmlwdG9yLCBnZXREaW1lbnNpb24sIG9wdGlvbnMsIHVuaXF1ZUlkXSk7XG4gIHZhciBwdWJsaXNoZWRSZWYgPSB1c2VSZWYoZW50cnkpO1xuICB2YXIgaXNGaXJzdFB1Ymxpc2hSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdHJ5LmRyYWdnYWJsZS5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWdpc3RyeS5kcmFnZ2FibGUudW5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW3JlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCkge1xuICAgICAgaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcHVibGlzaGVkUmVmLmN1cnJlbnQ7XG4gICAgcHVibGlzaGVkUmVmLmN1cnJlbnQgPSBlbnRyeTtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUudXBkYXRlKGVudHJ5LCBsYXN0KTtcbiAgfSwgW2VudHJ5LCByZWdpc3RyeS5kcmFnZ2FibGVdKTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZikge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHByZWZpeChpZCkge1xuICAgICAgcmV0dXJuIFwiRHJhZ2dhYmxlW2lkOiBcIiArIGlkICsgXCJdOiBcIjtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBwcm9wcy5kcmFnZ2FibGVJZDtcbiAgICAhaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgcmVxdWlyZXMgYSBkcmFnZ2FibGVJZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkRyYWdnYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyYWdnYWJsZUlkLlxcbiAgICAgIFByb3ZpZGVkOiBbdHlwZTogXCIgKyB0eXBlb2YgaWQgKyBcIl0gKHZhbHVlOiBcIiArIGlkICsgXCIpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhaXNJbnRlZ2VyKHByb3BzLmluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgcHJlZml4KGlkKSArIFwiIHJlcXVpcmVzIGFuIGludGVnZXIgaW5kZXggcHJvcFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvcHMubWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXRSZWYoKSk7XG5cbiAgICBpZiAocHJvcHMuaXNFbmFibGVkKSB7XG4gICAgICAhZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIHByZWZpeChpZCkgKyBcIiBVbmFibGUgdG8gZmluZCBkcmFnIGhhbmRsZVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUNsb25lUHJvcFZhbGlkYXRpb24oaXNDbG9uZSkge1xuICB1c2VEZXYoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbml0aWFsUmVmID0gdXNlUmVmKGlzQ2xvbmUpO1xuICAgIHVzZURldlNldHVwV2FybmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAhKGlzQ2xvbmUgPT09IGluaXRpYWxSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgaXNDbG9uZSBwcm9wIHZhbHVlIGNoYW5nZWQgZHVyaW5nIGNvbXBvbmVudCBsaWZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH0sIFtpc0Nsb25lXSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50SHRtbDVEbmQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gRHJhZ2dhYmxlKHByb3BzKSB7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBzZXRSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZWwpIHtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICB9LCBbXSk7XG4gIHZhciBnZXRSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG5cbiAgdmFyIF91c2VSZXF1aXJlZENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCksXG4gICAgICBjb250ZXh0SWQgPSBfdXNlUmVxdWlyZWRDb250ZXh0LmNvbnRleHRJZCxcbiAgICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkID0gX3VzZVJlcXVpcmVkQ29udGV4dC5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICAgIHJlZ2lzdHJ5ID0gX3VzZVJlcXVpcmVkQ29udGV4dC5yZWdpc3RyeTtcblxuICB2YXIgX3VzZVJlcXVpcmVkQ29udGV4dDIgPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCksXG4gICAgICB0eXBlID0gX3VzZVJlcXVpcmVkQ29udGV4dDIudHlwZSxcbiAgICAgIGRyb3BwYWJsZUlkID0gX3VzZVJlcXVpcmVkQ29udGV4dDIuZHJvcHBhYmxlSWQ7XG5cbiAgdmFyIGRlc2NyaXB0b3IgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHByb3BzLmRyYWdnYWJsZUlkLFxuICAgICAgaW5kZXg6IHByb3BzLmluZGV4LFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGRyb3BwYWJsZUlkOiBkcm9wcGFibGVJZFxuICAgIH07XG4gIH0sIFtwcm9wcy5kcmFnZ2FibGVJZCwgcHJvcHMuaW5kZXgsIHR5cGUsIGRyb3BwYWJsZUlkXSk7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgZHJhZ2dhYmxlSWQgPSBwcm9wcy5kcmFnZ2FibGVJZCxcbiAgICAgIGlzRW5hYmxlZCA9IHByb3BzLmlzRW5hYmxlZCxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzID0gcHJvcHMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyA9IHByb3BzLmNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgICAgaXNDbG9uZSA9IHByb3BzLmlzQ2xvbmUsXG4gICAgICBtYXBwZWQgPSBwcm9wcy5tYXBwZWQsXG4gICAgICBkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24gPSBwcm9wcy5kcm9wQW5pbWF0aW9uRmluaXNoZWQ7XG4gIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpO1xuICB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpO1xuXG4gIGlmICghaXNDbG9uZSkge1xuICAgIHZhciBmb3JQdWJsaXNoZXIgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICAgICAgZ2V0RHJhZ2dhYmxlUmVmOiBnZXRSZWYsXG4gICAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZFxuICAgICAgfTtcbiAgICB9LCBbZGVzY3JpcHRvciwgcmVnaXN0cnksIGdldFJlZiwgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLCBpc0VuYWJsZWRdKTtcbiAgICB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoZm9yUHVibGlzaGVyKTtcbiAgfVxuXG4gIHZhciBkcmFnSGFuZGxlUHJvcHMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNFbmFibGVkID8ge1xuICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgICAnZGF0YS1yYmQtZHJhZy1oYW5kbGUtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgICAnZGF0YS1yYmQtZHJhZy1oYW5kbGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICBvbkRyYWdTdGFydDogcHJldmVudEh0bWw1RG5kXG4gICAgfSA6IG51bGw7XG4gIH0sIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLCBkcmFnZ2FibGVJZCwgaXNFbmFibGVkXSk7XG4gIHZhciBvbk1vdmVFbmQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAobWFwcGVkLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW1hcHBlZC5kcm9wcGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uKCk7XG4gIH0sIFtkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24sIG1hcHBlZF0pO1xuICB2YXIgcHJvdmlkZWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZSQxKG1hcHBlZCk7XG4gICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnICYmIG1hcHBlZC5kcm9wcGluZyA/IG9uTW92ZUVuZCA6IG51bGw7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGlubmVyUmVmOiBzZXRSZWYsXG4gICAgICBkcmFnZ2FibGVQcm9wczoge1xuICAgICAgICAnZGF0YS1yYmQtZHJhZ2dhYmxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgICAgICdkYXRhLXJiZC1kcmFnZ2FibGUtaWQnOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBvblRyYW5zaXRpb25FbmQ6IG9uVHJhbnNpdGlvbkVuZFxuICAgICAgfSxcbiAgICAgIGRyYWdIYW5kbGVQcm9wczogZHJhZ0hhbmRsZVByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbY29udGV4dElkLCBkcmFnSGFuZGxlUHJvcHMsIGRyYWdnYWJsZUlkLCBtYXBwZWQsIG9uTW92ZUVuZCwgc2V0UmVmXSk7XG4gIHZhciBydWJyaWMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGRlc2NyaXB0b3IuaWQsXG4gICAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rlc2NyaXB0b3IuZHJvcHBhYmxlSWQsIGRlc2NyaXB0b3IuaWQsIGRlc2NyaXB0b3IuaW5kZXgsIGRlc2NyaXB0b3IudHlwZV0pO1xuICByZXR1cm4gY2hpbGRyZW4ocHJvdmlkZWQsIG1hcHBlZC5zbmFwc2hvdCwgcnVicmljKTtcbn1cblxudmFyIGlzU3RyaWN0RXF1YWwgPSAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59KTtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCA9IChmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHZhciBjb21iaW5lID0gcmVzdWx0LmNvbWJpbmUsXG4gICAgICBkZXN0aW5hdGlvbiA9IHJlc3VsdC5kZXN0aW5hdGlvbjtcblxuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cblxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBjb21iaW5lLmRyb3BwYWJsZUlkO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59KTtcblxudmFyIGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCA9IGZ1bmN0aW9uIGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC5jb21iaW5lID8gcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcblxudmFyIGdldENvbWJpbmVXaXRoRnJvbUltcGFjdCA9IGZ1bmN0aW9uIGdldENvbWJpbmVXaXRoRnJvbUltcGFjdChpbXBhY3QpIHtcbiAgcmV0dXJuIGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnID8gaW1wYWN0LmF0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlU2VsZWN0b3IoKSB7XG4gIHZhciBtZW1vaXplZE9mZnNldCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9KTtcbiAgdmFyIGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBkcm9wcGluZykge1xuICAgIHJldHVybiB7XG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgaXNDbG9uZTogaXNDbG9uZSxcbiAgICAgIGlzRHJvcEFuaW1hdGluZzogQm9vbGVhbihkcm9wcGluZyksXG4gICAgICBkcm9wQW5pbWF0aW9uOiBkcm9wcGluZyxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBkcmFnZ2luZ092ZXI6IGRyYWdnaW5nT3ZlcixcbiAgICAgIGNvbWJpbmVXaXRoOiBjb21iaW5lV2l0aCxcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3I6IG51bGxcbiAgICB9O1xuICB9KTtcbiAgdmFyIGdldE1lbW9pemVkUHJvcHMgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChvZmZzZXQsIG1vZGUsIGRpbWVuc2lvbiwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgZm9yY2VTaG91bGRBbmltYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcHBlZDoge1xuICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICBkcm9wcGluZzogbnVsbCxcbiAgICAgICAgZHJhZ2dpbmdPdmVyOiBkcmFnZ2luZ092ZXIsXG4gICAgICAgIGNvbWJpbmVXaXRoOiBjb21iaW5lV2l0aCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLFxuICAgICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgbnVsbClcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICB2YXIgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSBzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQ7XG4gICAgICB2YXIgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIHZhciBkcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICAgdmFyIGNvbWJpbmVXaXRoID0gZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0KHN0YXRlLmltcGFjdCk7XG4gICAgICB2YXIgZm9yY2VTaG91bGRBbmltYXRlID0gc3RhdGUuZm9yY2VTaG91bGRBbmltYXRlO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMobWVtb2l6ZWRPZmZzZXQob2Zmc2V0LngsIG9mZnNldC55KSwgc3RhdGUubW92ZW1lbnRNb2RlLCBkaW1lbnNpb24sIG93blByb3BzLmlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICB2YXIgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuXG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0Nsb25lID0gb3duUHJvcHMuaXNDbG9uZTtcbiAgICAgIHZhciBfZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIHZhciByZXN1bHQgPSBjb21wbGV0ZWQucmVzdWx0O1xuICAgICAgdmFyIG1vZGUgPSByZXN1bHQubW9kZTtcblxuICAgICAgdmFyIF9kcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQocmVzdWx0KTtcblxuICAgICAgdmFyIF9jb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdChyZXN1bHQpO1xuXG4gICAgICB2YXIgZHVyYXRpb24gPSBzdGF0ZS5kcm9wRHVyYXRpb247XG4gICAgICB2YXIgZHJvcHBpbmcgPSB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgY3VydmU6IGN1cnZlcy5kcm9wLFxuICAgICAgICBtb3ZlVG86IHN0YXRlLm5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgIG9wYWNpdHk6IF9jb21iaW5lV2l0aCA/IGNvbWJpbmUub3BhY2l0eS5kcm9wIDogbnVsbCxcbiAgICAgICAgc2NhbGU6IF9jb21iaW5lV2l0aCA/IGNvbWJpbmUuc2NhbGUuZHJvcCA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXBwZWQ6IHtcbiAgICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICAgIG9mZnNldDogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgICBkaW1lbnNpb246IF9kaW1lbnNpb24sXG4gICAgICAgICAgZHJvcHBpbmc6IGRyb3BwaW5nLFxuICAgICAgICAgIGRyYWdnaW5nT3ZlcjogX2RyYWdnaW5nT3ZlcixcbiAgICAgICAgICBjb21iaW5lV2l0aDogX2NvbWJpbmVXaXRoLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsLFxuICAgICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIF9kcmFnZ2luZ092ZXIsIF9jb21iaW5lV2l0aCwgZHJvcHBpbmcpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yKSB7XG4gIHJldHVybiB7XG4gICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgaXNEcm9wQW5pbWF0aW5nOiBmYWxzZSxcbiAgICBpc0Nsb25lOiBmYWxzZSxcbiAgICBkcm9wQW5pbWF0aW9uOiBudWxsLFxuICAgIG1vZGU6IG51bGwsXG4gICAgZHJhZ2dpbmdPdmVyOiBudWxsLFxuICAgIGNvbWJpbmVUYXJnZXRGb3I6IGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgY29tYmluZVdpdGg6IG51bGxcbiAgfTtcbn1cblxudmFyIGF0UmVzdCA9IHtcbiAgbWFwcGVkOiB7XG4gICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgb2Zmc2V0OiBvcmlnaW4sXG4gICAgY29tYmluZVRhcmdldEZvcjogbnVsbCxcbiAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50OiB0cnVlLFxuICAgIHNuYXBzaG90OiBnZXRTZWNvbmRhcnlTbmFwc2hvdChudWxsKVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTZWxlY3RvcigpIHtcbiAgdmFyIG1lbW9pemVkT2Zmc2V0ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH0pO1xuICB2YXIgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IG1lbW9pemVPbmUoZ2V0U2Vjb25kYXJ5U25hcHNob3QpO1xuICB2YXIgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCkge1xuICAgIGlmIChjb21iaW5lVGFyZ2V0Rm9yID09PSB2b2lkIDApIHtcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtYXBwZWQ6IHtcbiAgICAgICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBjb21iaW5lVGFyZ2V0Rm9yOiBjb21iaW5lVGFyZ2V0Rm9yLFxuICAgICAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50OiBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50LFxuICAgICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yKVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBnZXRGYWxsYmFjayA9IGZ1bmN0aW9uIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpIHtcbiAgICByZXR1cm4gY29tYmluZVRhcmdldEZvciA/IGdldE1lbW9pemVkUHJvcHMob3JpZ2luLCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKSA6IG51bGw7XG4gIH07XG5cbiAgdmFyIGdldFByb3BzID0gZnVuY3Rpb24gZ2V0UHJvcHMob3duSWQsIGRyYWdnaW5nSWQsIGltcGFjdCwgYWZ0ZXJDcml0aWNhbCkge1xuICAgIHZhciB2aXN1YWxEaXNwbGFjZW1lbnQgPSBpbXBhY3QuZGlzcGxhY2VkLnZpc2libGVbb3duSWRdO1xuICAgIHZhciBpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0ID0gQm9vbGVhbihhZnRlckNyaXRpY2FsLmluVmlydHVhbExpc3QgJiYgYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtvd25JZF0pO1xuICAgIHZhciBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAgIHZhciBjb21iaW5lVGFyZ2V0Rm9yID0gY29tYmluZSAmJiBjb21iaW5lLmRyYWdnYWJsZUlkID09PSBvd25JZCA/IGRyYWdnaW5nSWQgOiBudWxsO1xuXG4gICAgaWYgKCF2aXN1YWxEaXNwbGFjZW1lbnQpIHtcbiAgICAgIGlmICghaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCkge1xuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2soY29tYmluZVRhcmdldEZvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbXBhY3QuZGlzcGxhY2VkLmludmlzaWJsZVtvd25JZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2UgPSBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCk7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoY2hhbmdlLngsIGNoYW5nZS55KTtcblxuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMoX29mZnNldCwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGxhY2VCeSA9IGltcGFjdC5kaXNwbGFjZWRCeS5wb2ludDtcbiAgICB2YXIgb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoZGlzcGxhY2VCeS54LCBkaXNwbGFjZUJ5LnkpO1xuICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgdmlzdWFsRGlzcGxhY2VtZW50LnNob3VsZEFuaW1hdGUpO1xuICB9O1xuXG4gIHZhciBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIGlmIChzdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICBpZiAoc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFByb3BzKG93blByb3BzLmRyYWdnYWJsZUlkLCBzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQsIHN0YXRlLmltcGFjdCwgc3RhdGUuYWZ0ZXJDcml0aWNhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICB2YXIgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuXG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCwgY29tcGxldGVkLmltcGFjdCwgY29tcGxldGVkLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cblxudmFyIG1ha2VNYXBTdGF0ZVRvUHJvcHMgPSBmdW5jdGlvbiBtYWtlTWFwU3RhdGVUb1Byb3BzKCkge1xuICB2YXIgZHJhZ2dpbmdTZWxlY3RvciA9IGdldERyYWdnYWJsZVNlbGVjdG9yKCk7XG4gIHZhciBzZWNvbmRhcnlTZWxlY3RvciA9IGdldFNlY29uZGFyeVNlbGVjdG9yKCk7XG5cbiAgdmFyIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBzZWNvbmRhcnlTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHx8IGF0UmVzdDtcbiAgfTtcblxuICByZXR1cm4gc2VsZWN0b3I7XG59O1xudmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkOiBkcm9wQW5pbWF0aW9uRmluaXNoZWRcbn07XG52YXIgQ29ubmVjdGVkRHJhZ2dhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG51bGwsIHtcbiAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICBwdXJlOiB0cnVlLFxuICBhcmVTdGF0ZVByb3BzRXF1YWw6IGlzU3RyaWN0RXF1YWxcbn0pKERyYWdnYWJsZSk7XG5cbmZ1bmN0aW9uIFByaXZhdGVEcmFnZ2FibGUocHJvcHMpIHtcbiAgdmFyIGRyb3BwYWJsZUNvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCk7XG4gIHZhciBpc1VzaW5nQ2xvbmVGb3IgPSBkcm9wcGFibGVDb250ZXh0LmlzVXNpbmdDbG9uZUZvcjtcblxuICBpZiAoaXNVc2luZ0Nsb25lRm9yID09PSBwcm9wcy5kcmFnZ2FibGVJZCAmJiAhcHJvcHMuaXNDbG9uZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGVkRHJhZ2dhYmxlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBQdWJsaWNEcmFnZ2FibGUocHJvcHMpIHtcbiAgdmFyIGlzRW5hYmxlZCA9IHR5cGVvZiBwcm9wcy5pc0RyYWdEaXNhYmxlZCA9PT0gJ2Jvb2xlYW4nID8gIXByb3BzLmlzRHJhZ0Rpc2FibGVkIDogdHJ1ZTtcbiAgdmFyIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzID0gQm9vbGVhbihwcm9wcy5kaXNhYmxlSW50ZXJhY3RpdmVFbGVtZW50QmxvY2tpbmcpO1xuICB2YXIgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MgPSBCb29sZWFuKHByb3BzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpdmF0ZURyYWdnYWJsZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgaXNFbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIERyb3BwYWJsZShwcm9wcykge1xuICB2YXIgYXBwQ29udGV4dCA9IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7XG4gICFhcHBDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgYXBwIGNvbnRleHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBjb250ZXh0SWQgPSBhcHBDb250ZXh0LmNvbnRleHRJZCxcbiAgICAgIGlzTW92ZW1lbnRBbGxvd2VkID0gYXBwQ29udGV4dC5pc01vdmVtZW50QWxsb3dlZDtcbiAgdmFyIGRyb3BwYWJsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGRyb3BwYWJsZUlkID0gcHJvcHMuZHJvcHBhYmxlSWQsXG4gICAgICB0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIG1vZGUgPSBwcm9wcy5tb2RlLFxuICAgICAgZGlyZWN0aW9uID0gcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcgPSBwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICAgIGlzRHJvcERpc2FibGVkID0gcHJvcHMuaXNEcm9wRGlzYWJsZWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkID0gcHJvcHMuaXNDb21iaW5lRW5hYmxlZCxcbiAgICAgIHNuYXBzaG90ID0gcHJvcHMuc25hcHNob3QsXG4gICAgICB1c2VDbG9uZSA9IHByb3BzLnVzZUNsb25lLFxuICAgICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwgPSBwcm9wcy51cGRhdGVWaWV3cG9ydE1heFNjcm9sbCxcbiAgICAgIGdldENvbnRhaW5lckZvckNsb25lID0gcHJvcHMuZ2V0Q29udGFpbmVyRm9yQ2xvbmU7XG4gIHZhciBnZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHZhciBzZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBkcm9wcGFibGVSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIHZhciBnZXRQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXJSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB2YXIgc2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFtdKTtcbiAgdXNlVmFsaWRhdGlvbih7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGdldERyb3BwYWJsZVJlZjogZ2V0RHJvcHBhYmxlUmVmLFxuICAgIGdldFBsYWNlaG9sZGVyUmVmOiBnZXRQbGFjZWhvbGRlclJlZlxuICB9KTtcbiAgdmFyIG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc01vdmVtZW50QWxsb3dlZCgpKSB7XG4gICAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCh7XG4gICAgICAgIG1heFNjcm9sbDogZ2V0TWF4V2luZG93U2Nyb2xsKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2lzTW92ZW1lbnRBbGxvd2VkLCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbF0pO1xuICB1c2VEcm9wcGFibGVQdWJsaXNoZXIoe1xuICAgIGRyb3BwYWJsZUlkOiBkcm9wcGFibGVJZCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIG1vZGU6IG1vZGUsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgaXNEcm9wRGlzYWJsZWQ6IGlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmc6IGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nLFxuICAgIGdldERyb3BwYWJsZVJlZjogZ2V0RHJvcHBhYmxlUmVmXG4gIH0pO1xuICB2YXIgcGxhY2Vob2xkZXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGVJbk91dCwge1xuICAgIG9uOiBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICBzaG91bGRBbmltYXRlOiBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXJcbiAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgb25DbG9zZSA9IF9yZWYub25DbG9zZSxcbiAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgYW5pbWF0ZSA9IF9yZWYuYW5pbWF0ZTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQbGFjZWhvbGRlciQxLCB7XG4gICAgICBwbGFjZWhvbGRlcjogZGF0YSxcbiAgICAgIG9uQ2xvc2U6IG9uQ2xvc2UsXG4gICAgICBpbm5lclJlZjogc2V0UGxhY2Vob2xkZXJSZWYsXG4gICAgICBhbmltYXRlOiBhbmltYXRlLFxuICAgICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgICBvblRyYW5zaXRpb25FbmQ6IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kXG4gICAgfSk7XG4gIH0pO1xuICB2YXIgcHJvdmlkZWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5uZXJSZWY6IHNldERyb3BwYWJsZVJlZixcbiAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgIGRyb3BwYWJsZVByb3BzOiB7XG4gICAgICAgICdkYXRhLXJiZC1kcm9wcGFibGUtaWQnOiBkcm9wcGFibGVJZCxcbiAgICAgICAgJ2RhdGEtcmJkLWRyb3BwYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2NvbnRleHRJZCwgZHJvcHBhYmxlSWQsIHBsYWNlaG9sZGVyLCBzZXREcm9wcGFibGVSZWZdKTtcbiAgdmFyIGlzVXNpbmdDbG9uZUZvciA9IHVzZUNsb25lID8gdXNlQ2xvbmUuZHJhZ2dpbmcuZHJhZ2dhYmxlSWQgOiBudWxsO1xuICB2YXIgZHJvcHBhYmxlQ29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkcm9wcGFibGVJZDogZHJvcHBhYmxlSWQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaXNVc2luZ0Nsb25lRm9yOiBpc1VzaW5nQ2xvbmVGb3JcbiAgICB9O1xuICB9LCBbZHJvcHBhYmxlSWQsIGlzVXNpbmdDbG9uZUZvciwgdHlwZV0pO1xuXG4gIGZ1bmN0aW9uIGdldENsb25lKCkge1xuICAgIGlmICghdXNlQ2xvbmUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBkcmFnZ2luZyA9IHVzZUNsb25lLmRyYWdnaW5nLFxuICAgICAgICByZW5kZXIgPSB1c2VDbG9uZS5yZW5kZXI7XG4gICAgdmFyIG5vZGUgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIHtcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2luZy5kcmFnZ2FibGVJZCxcbiAgICAgIGluZGV4OiBkcmFnZ2luZy5zb3VyY2UuaW5kZXgsXG4gICAgICBpc0Nsb25lOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiB0cnVlLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGZhbHNlLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IHRydWVcbiAgICB9LCBmdW5jdGlvbiAoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90KSB7XG4gICAgICByZXR1cm4gcmVuZGVyKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCwgZHJhZ2dpbmcpO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwobm9kZSwgZ2V0Q29udGFpbmVyRm9yQ2xvbmUoKSk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wcGFibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRyb3BwYWJsZUNvbnRleHRcbiAgfSwgY2hpbGRyZW4ocHJvdmlkZWQsIHNuYXBzaG90KSwgZ2V0Q2xvbmUoKSk7XG59XG5cbnZhciBpc01hdGNoaW5nVHlwZSA9IGZ1bmN0aW9uIGlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNyaXRpY2FsKSB7XG4gIHJldHVybiB0eXBlID09PSBjcml0aWNhbC5kcm9wcGFibGUudHlwZTtcbn07XG5cbnZhciBnZXREcmFnZ2FibGUgPSBmdW5jdGlvbiBnZXREcmFnZ2FibGUoY3JpdGljYWwsIGRpbWVuc2lvbnMpIHtcbiAgcmV0dXJuIGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xufTtcblxudmFyIG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSA9IGZ1bmN0aW9uIG1ha2VNYXBTdGF0ZVRvUHJvcHMoKSB7XG4gIHZhciBpZGxlV2l0aEFuaW1hdGlvbiA9IHtcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IHRydWUsXG4gICAgc25hcHNob3Q6IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nT3ZlcldpdGg6IG51bGwsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogZmFsc2VcbiAgICB9LFxuICAgIHVzZUNsb25lOiBudWxsXG4gIH07XG5cbiAgdmFyIGlkbGVXaXRob3V0QW5pbWF0aW9uID0gX2V4dGVuZHMoe30sIGlkbGVXaXRoQW5pbWF0aW9uLCB7XG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZVxuICB9KTtcblxuICB2YXIgZ2V0RHJhZ2dhYmxlUnVicmljID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgIHJldHVybiB7XG4gICAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICAgIHNvdXJjZToge1xuICAgICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgdmFyIGdldE1hcFByb3BzID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciwgaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSkge1xuICAgIHZhciBkcmFnZ2FibGVJZCA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuaWQ7XG4gICAgdmFyIGlzSG9tZSA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGlkO1xuXG4gICAgaWYgKGlzSG9tZSkge1xuICAgICAgdmFyIHVzZUNsb25lID0gcmVuZGVyQ2xvbmUgPyB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyQ2xvbmUsXG4gICAgICAgIGRyYWdnaW5nOiBnZXREcmFnZ2FibGVSdWJyaWMoZHJhZ2dpbmcuZGVzY3JpcHRvcilcbiAgICAgIH0gOiBudWxsO1xuICAgICAgdmFyIF9zbmFwc2hvdCA9IHtcbiAgICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICAgIGRyYWdnaW5nT3ZlcldpdGg6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIgPyBkcmFnZ2FibGVJZCA6IG51bGwsXG4gICAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IGZhbHNlLFxuICAgICAgICBzbmFwc2hvdDogX3NuYXBzaG90LFxuICAgICAgICB1c2VDbG9uZTogdXNlQ2xvbmVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0KSB7XG4gICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgfVxuXG4gICAgdmFyIHNuYXBzaG90ID0ge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgc25hcHNob3Q6IHNuYXBzaG90LFxuICAgICAgdXNlQ2xvbmU6IG51bGxcbiAgICB9O1xuICB9KTtcblxuICB2YXIgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICB2YXIgaWQgPSBvd25Qcm9wcy5kcm9wcGFibGVJZDtcbiAgICB2YXIgdHlwZSA9IG93blByb3BzLnR5cGU7XG4gICAgdmFyIGlzRW5hYmxlZCA9ICFvd25Qcm9wcy5pc0Ryb3BEaXNhYmxlZDtcbiAgICB2YXIgcmVuZGVyQ2xvbmUgPSBvd25Qcm9wcy5yZW5kZXJDbG9uZTtcblxuICAgIGlmIChzdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICB2YXIgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcblxuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuICAgICAgdmFyIGlzRHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KSA9PT0gaWQ7XG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXIsIGlzRHJhZ2dpbmdPdmVyLCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcblxuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjb21wbGV0ZWQuY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9kcmFnZ2luZyA9IGdldERyYWdnYWJsZShjb21wbGV0ZWQuY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuXG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KGNvbXBsZXRlZC5yZXN1bHQpID09PSBpZCwgd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkLCBfZHJhZ2dpbmcsIHJlbmRlckNsb25lKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyAmJiBzdGF0ZS5jb21wbGV0ZWQgJiYgIXN0YXRlLnNob3VsZEZsdXNoKSB7XG4gICAgICB2YXIgX2NvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcblxuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBfY29tcGxldGVkLmNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoX2NvbXBsZXRlZC5pbXBhY3QpID09PSBpZDtcbiAgICAgIHZhciB3YXNDb21iaW5pbmcgPSBCb29sZWFuKF9jb21wbGV0ZWQuaW1wYWN0LmF0ICYmIF9jb21wbGV0ZWQuaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyk7XG4gICAgICB2YXIgaXNIb21lID0gX2NvbXBsZXRlZC5jcml0aWNhbC5kcm9wcGFibGUuaWQgPT09IGlkO1xuXG4gICAgICBpZiAod2FzT3Zlcikge1xuICAgICAgICByZXR1cm4gd2FzQ29tYmluaW5nID8gaWRsZVdpdGhBbmltYXRpb24gOiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSG9tZSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbnZhciBtYXBEaXNwYXRjaFRvUHJvcHMkMSA9IHtcbiAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGw6IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXG59O1xuXG5mdW5jdGlvbiBnZXRCb2R5KCkge1xuICAhZG9jdW1lbnQuYm9keSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2RvY3VtZW50LmJvZHkgaXMgbm90IHJlYWR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbn1cblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgbW9kZTogJ3N0YW5kYXJkJyxcbiAgdHlwZTogJ0RFRkFVTFQnLFxuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGlzRHJvcERpc2FibGVkOiBmYWxzZSxcbiAgaXNDb21iaW5lRW5hYmxlZDogZmFsc2UsXG4gIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nOiBmYWxzZSxcbiAgcmVuZGVyQ2xvbmU6IG51bGwsXG4gIGdldENvbnRhaW5lckZvckNsb25lOiBnZXRCb2R5XG59O1xudmFyIENvbm5lY3RlZERyb3BwYWJsZSA9IGNvbm5lY3QobWFrZU1hcFN0YXRlVG9Qcm9wcyQxLCBtYXBEaXNwYXRjaFRvUHJvcHMkMSwgbnVsbCwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIHB1cmU6IHRydWUsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJvcHBhYmxlKTtcbkNvbm5lY3RlZERyb3BwYWJsZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbmV4cG9ydCB7IERyYWdEcm9wQ29udGV4dCwgUHVibGljRHJhZ2dhYmxlIGFzIERyYWdnYWJsZSwgQ29ubmVjdGVkRHJvcHBhYmxlIGFzIERyb3BwYWJsZSwgcmVzZXRTZXJ2ZXJDb250ZXh0LCB1c2VLZXlib2FyZFNlbnNvciwgdXNlTW91c2VTZW5zb3IsIHVzZVRvdWNoU2Vuc29yIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNvbnRleHQiLCJfaW5oZXJpdHNMb29zZSIsIl9leHRlbmRzIiwiY3JlYXRlU3RvcmUiLCJjcmVhdGVTdG9yZSQxIiwiYXBwbHlNaWRkbGV3YXJlIiwiY29tcG9zZSIsImJpbmRBY3Rpb25DcmVhdG9ycyIsIlByb3ZpZGVyIiwiY29ubmVjdCIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImdldFJlY3QiLCJleHBhbmQiLCJvZmZzZXQiLCJ3aXRoU2Nyb2xsIiwiZ2V0Qm94IiwiY3JlYXRlQm94IiwiY2FsY3VsYXRlQm94IiwibWVtb2l6ZU9uZSIsInJhZlNjaGQiLCJSZWFjdERPTSIsImlzUHJvZHVjdGlvbiIsInByb2Nlc3MiLCJzcGFjZXNBbmRUYWJzIiwibGluZVN0YXJ0V2l0aFNwYWNlcyIsImNsZWFuIiwidmFsdWUiLCJyZXBsYWNlIiwidHJpbSIsImdldERldk1lc3NhZ2UiLCJtZXNzYWdlIiwiZ2V0Rm9ybWF0dGVkTWVzc2FnZSIsImlzRGlzYWJsZWRGbGFnIiwibG9nIiwidHlwZSIsIl9jb25zb2xlIiwid2luZG93IiwiY29uc29sZSIsImFwcGx5Iiwid2FybmluZyIsImJpbmQiLCJlcnJvciIsIm5vb3AiLCJnZXRPcHRpb25zIiwic2hhcmVkIiwiZnJvbUJpbmRpbmciLCJiaW5kRXZlbnRzIiwiZWwiLCJiaW5kaW5ncyIsInNoYXJlZE9wdGlvbnMiLCJ1bmJpbmRpbmdzIiwibWFwIiwiYmluZGluZyIsIm9wdGlvbnMiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lIiwiZm4iLCJ1bmJpbmQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidW5iaW5kQWxsIiwiZm9yRWFjaCIsImlzUHJvZHVjdGlvbiQxIiwicHJlZml4IiwiUmJkSW52YXJpYW50IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJFcnJvckJvdW5kYXJ5IiwiX1JlYWN0JENvbXBvbmVudCIsIl90aGlzIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjYWxsIiwiY29uY2F0IiwiY2FsbGJhY2tzIiwib25XaW5kb3dFcnJvciIsImV2ZW50IiwiZ2V0Q2FsbGJhY2tzIiwiaXNEcmFnZ2luZyIsInRyeUFib3J0IiwiZXJyIiwicHJldmVudERlZmF1bHQiLCJFcnJvciIsInNldENhbGxiYWNrcyIsIl9wcm90byIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJzZXRTdGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwicHJvcHMiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCIsImRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyIsInBvc2l0aW9uIiwiaW5kZXgiLCJvbkRyYWdTdGFydCIsInN0YXJ0Iiwic291cmNlIiwid2l0aExvY2F0aW9uIiwiZGVzdGluYXRpb24iLCJpc0luSG9tZUxpc3QiLCJkcm9wcGFibGVJZCIsInN0YXJ0UG9zaXRpb24iLCJlbmRQb3NpdGlvbiIsIndpdGhDb21iaW5lIiwiaWQiLCJjb21iaW5lIiwiaW5Ib21lTGlzdCIsImRyYWdnYWJsZUlkIiwib25EcmFnVXBkYXRlIiwidXBkYXRlIiwibG9jYXRpb24iLCJyZXR1cm5lZFRvU3RhcnQiLCJvbkRyYWdFbmQiLCJyZXN1bHQiLCJyZWFzb24iLCJwcmVzZXQiLCJvcmlnaW4iLCJ4IiwieSIsImFkZCIsInBvaW50MSIsInBvaW50MiIsInN1YnRyYWN0IiwiaXNFcXVhbCIsIm5lZ2F0ZSIsInBvaW50IiwicGF0Y2giLCJsaW5lIiwib3RoZXJWYWx1ZSIsIl9yZWYiLCJkaXN0YW5jZSIsIk1hdGgiLCJzcXJ0IiwicG93IiwiY2xvc2VzdCIsInRhcmdldCIsInBvaW50cyIsIm1pbiIsImV4ZWN1dGVDbGlwIiwiZnJhbWUiLCJzdWJqZWN0IiwidG9wIiwibWF4IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRCeVBvc2l0aW9uIiwic3BhY2luZyIsImdldENvcm5lcnMiLCJub1NwYWNpbmciLCJzY3JvbGwiLCJkaWZmIiwiZGlzcGxhY2VtZW50IiwiaW5jcmVhc2UiLCJheGlzIiwid2l0aFBsYWNlaG9sZGVyIiwiaW5jcmVhc2VkQnkiLCJfZXh0ZW5kczIiLCJlbmQiLCJjbGlwIiwic2hvdWxkQ2xpcFN1YmplY3QiLCJwYWdlTWFyZ2luQm94IiwiZ2V0U3ViamVjdCIsInBhZ2UiLCJzY3JvbGxlZCIsIm1hcmdpbkJveCIsImluY3JlYXNlZCIsImNsaXBwZWQiLCJhY3RpdmUiLCJzY3JvbGxEcm9wcGFibGUiLCJkcm9wcGFibGUiLCJuZXdTY3JvbGwiLCJzY3JvbGxhYmxlIiwic2Nyb2xsRGlmZiIsImluaXRpYWwiLCJzY3JvbGxEaXNwbGFjZW1lbnQiLCJjdXJyZW50IiwiaXNJbnRlZ2VyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmbG9vciIsInZhbHVlcyIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJmaW5kSW5kZXgiLCJsaXN0IiwicHJlZGljYXRlIiwiaSIsImZpbmQiLCJ1bmRlZmluZWQiLCJ0b0FycmF5Iiwic2xpY2UiLCJ0b0Ryb3BwYWJsZU1hcCIsImRyb3BwYWJsZXMiLCJyZWR1Y2UiLCJwcmV2aW91cyIsImRlc2NyaXB0b3IiLCJ0b0RyYWdnYWJsZU1hcCIsImRyYWdnYWJsZXMiLCJ0b0Ryb3BwYWJsZUxpc3QiLCJ0b0RyYWdnYWJsZUxpc3QiLCJnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlIiwiZmlsdGVyIiwiZHJhZ2dhYmxlIiwic29ydCIsImEiLCJiIiwidHJ5R2V0RGVzdGluYXRpb24iLCJpbXBhY3QiLCJhdCIsInRyeUdldENvbWJpbmUiLCJyZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCIsInJlbW92ZSIsIml0ZW0iLCJtb3ZlVG9OZXh0Q29tYmluZSIsImlzTW92aW5nRm9yd2FyZCIsImluc2lkZURlc3RpbmF0aW9uIiwicHJldmlvdXNJbXBhY3QiLCJpc0NvbWJpbmVFbmFibGVkIiwiZ2V0SW1wYWN0IiwiYWxsIiwiZGlzcGxhY2VkIiwiY2xvc2VzdElkIiwid2l0aG91dERyYWdnYWJsZSIsImxhc3QiLCJpbmRleE9mQ2xvc2VzdCIsImQiLCJwcm9wb3NlZEluZGV4IiwiYmVmb3JlIiwiaXNIb21lT2YiLCJub0Rpc3BsYWNlZEJ5IiwiZW1wdHlHcm91cHMiLCJpbnZpc2libGUiLCJ2aXNpYmxlIiwibm9JbXBhY3QiLCJkaXNwbGFjZWRCeSIsImlzV2l0aGluIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUiLCJpc1dpdGhpblZlcnRpY2FsIiwiaXNXaXRoaW5Ib3Jpem9udGFsIiwiaXNDb250YWluZWQiLCJpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5IiwiaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5IiwiaXNQYXJ0aWFsbHlDb250YWluZWQiLCJpc0JpZ2dlclZlcnRpY2FsbHkiLCJpc0JpZ2dlckhvcml6b250YWxseSIsImlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lIiwiaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXMiLCJpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lIiwidmVydGljYWwiLCJkaXJlY3Rpb24iLCJjcm9zc0F4aXNMaW5lIiwic2l6ZSIsImNyb3NzQXhpc1N0YXJ0IiwiY3Jvc3NBeGlzRW5kIiwiY3Jvc3NBeGlzU2l6ZSIsImhvcml6b250YWwiLCJpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzIiwiZ2V0RHJvcHBhYmxlRGlzcGxhY2VkIiwiaXNWaXNpYmxlSW5Ecm9wcGFibGUiLCJpc1Zpc2libGVUaHJvdWdoRnJhbWVGbiIsImlzVmlzaWJsZUluVmlld3BvcnQiLCJ2aWV3cG9ydCIsImlzVmlzaWJsZSIsInRvQmVEaXNwbGFjZWQiLCJ3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50IiwiZGlzcGxhY2VkVGFyZ2V0IiwiaXNQYXJ0aWFsbHlWaXNpYmxlIiwiaXNUb3RhbGx5VmlzaWJsZSIsImlzVG90YWxseVZpc2libGVPbkF4aXMiLCJnZXRTaG91bGRBbmltYXRlIiwiZm9yY2VTaG91bGRBbmltYXRlIiwic2hvdWxkQW5pbWF0ZSIsImdldFRhcmdldCIsImV4cGFuZEJ5IiwiZ2V0RGlzcGxhY2VtZW50R3JvdXBzIiwiYWZ0ZXJEcmFnZ2luZyIsImdyb3VwcyIsInB1c2giLCJnZXRJbmRleE9mTGFzdEl0ZW0iLCJpbmRleE9mTGFzdEl0ZW0iLCJnb0F0RW5kIiwibmV3SW5kZXgiLCJjYWxjdWxhdGVSZW9yZGVySW1wYWN0IiwiX3JlZjIiLCJtYXRjaCIsIndpdGhvdXREcmFnZ2luZyIsInNsaWNlRnJvbSIsImluZGV4T2YiLCJpbXBhY3RlZCIsImRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCIsImFmdGVyQ3JpdGljYWwiLCJCb29sZWFuIiwiZWZmZWN0ZWQiLCJmcm9tQ29tYmluZSIsImNvbWJpbmVJZCIsImNvbWJpbmVXaXRoIiwiY29tYmluZVdpdGhJbmRleCIsImRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsIiwiZnJvbVJlb3JkZXIiLCJjdXJyZW50SW5kZXgiLCJmaXJzdEluZGV4IiwibGFzdEluZGV4IiwibW92ZVRvTmV4dEluZGV4Iiwid2FzQXQiLCJfbmV3SW5kZXgiLCJnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQiLCJpc0Rpc3BsYWNlZCIsIndoZW5Db21iaW5pbmciLCJjZW50ZXIiLCJib3JkZXJCb3giLCJkaXNwbGFjZUJ5IiwiZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlciIsImJveCIsIm1hcmdpbiIsImRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyIiwiZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyIiwiaXNNb3ZpbmciLCJnb0FmdGVyIiwibW92ZVJlbGF0aXZlVG8iLCJnb0JlZm9yZSIsImdvSW50b1N0YXJ0IiwiX3JlZjMiLCJtb3ZlSW50byIsImNvbnRlbnRCb3giLCJ3aGVuUmVvcmRlcmluZyIsImRyYWdnYWJsZVBhZ2UiLCJjbG9zZXN0QWZ0ZXIiLCJ3aXRoRGlzcGxhY2VtZW50IiwiZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCIsIm9yaWdpbmFsIiwiZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3QiLCJ3aXRob3V0RGlzcGxhY2VtZW50Iiwic2Nyb2xsVmlld3BvcnQiLCJ1cGRhdGVkIiwiZ2V0RHJhZ2dhYmxlcyIsImlkcyIsInRyeUdldFZpc2libGUiLCJzcGVjdWxhdGl2ZWx5SW5jcmVhc2UiLCJtYXhTY3JvbGxDaGFuZ2UiLCJzY3JvbGxlZFZpZXdwb3J0Iiwic2Nyb2xsZWREcm9wcGFibGUiLCJ3aXRoVmlld3BvcnRTY3JvbGwiLCJ3aXRoRHJvcHBhYmxlU2Nyb2xsIiwibmV3SW1wYWN0Iiwid2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50IiwiZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJwYWdlQm9yZGVyQm94Q2VudGVyIiwid2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UiLCJjbGllbnQiLCJpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbiIsIm5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIiLCJfcmVmJG9ubHlPbk1haW5BeGlzIiwib25seU9uTWFpbkF4aXMiLCJjaGFuZ2VOZWVkZWQiLCJzaGlmdGVkIiwibW92ZVRvTmV4dFBsYWNlIiwicHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyIiwicHJldmlvdXNDbGllbnRTZWxlY3Rpb24iLCJpc0VuYWJsZWQiLCJpc1Zpc2libGVJbk5ld0xvY2F0aW9uIiwiY2xpZW50U2VsZWN0aW9uIiwic2Nyb2xsSnVtcFJlcXVlc3QiLCJjYXV0aW91cyIsImdldEtub3duQWN0aXZlIiwicmVjdCIsImdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUiLCJpc0JldHdlZW5Tb3VyY2VDbGlwcGVkIiwiY2FuZGlkYXRlcyIsImFjdGl2ZU9mVGFyZ2V0IiwiaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkIiwiZmlyc3QiLCJzZWNvbmQiLCJhcnJheSIsImNvbnRhaW5zIiwiaXNXaXRoaW5Ecm9wcGFibGUiLCJnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlciIsImdldEN1cnJlbnRQYWdlQm9yZGVyQm94IiwiZ2V0Q2xvc2VzdERyYWdnYWJsZSIsInNvcnRlZCIsImRpc3RhbmNlVG9BIiwiZGlzdGFuY2VUb0IiLCJnZXREaXNwbGFjZWRCeSIsImdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlclNpemUiLCJtb2RlIiwiYXZhaWxhYmxlU3BhY2UiLCJpbnNpZGVEcm9wcGFibGUiLCJzcGFjZVVzZWQiLCJzdW0iLCJkaW1lbnNpb24iLCJyZXF1aXJlZFNwYWNlIiwibmVlZHNUb0dyb3dCeSIsIndpdGhNYXhTY3JvbGwiLCJhZGRQbGFjZWhvbGRlciIsInJlcXVpcmVkR3Jvd3RoIiwiYWRkZWQiLCJvbGRGcmFtZU1heFNjcm9sbCIsIl9zdWJqZWN0IiwibWF4U2Nyb2xsIiwibmV3RnJhbWUiLCJyZW1vdmVQbGFjZWhvbGRlciIsIl9zdWJqZWN0MiIsIm9sZE1heFNjcm9sbCIsIm1vdmVUb05ld0Ryb3BwYWJsZSIsInByb3Bvc2VkIiwicHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyIiwiaXNHb2luZ0JlZm9yZVRhcmdldCIsInJlbGF0aXZlVG8iLCJtb3ZlQ3Jvc3NBeGlzIiwiaXNPdmVyIiwid2hhdElzRHJhZ2dlZE92ZXIiLCJnZXREcm9wcGFibGVPdmVyIiwibW92ZUluRGlyZWN0aW9uIiwic3RhdGUiLCJpc0FjdHVhbGx5T3ZlciIsImRpbWVuc2lvbnMiLCJpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkIiwiaG9tZSIsImNyaXRpY2FsIiwiaXNNb3ZpbmdPbk1haW5BeGlzIiwiYm9yZGVyQm94Q2VudGVyIiwiX3N0YXRlJGRpbWVuc2lvbnMiLCJzZWxlY3Rpb24iLCJpc01vdmVtZW50QWxsb3dlZCIsInBoYXNlIiwiaXNQb3NpdGlvbkluRnJhbWUiLCJydW4iLCJnZXRIYXNPdmVybGFwIiwiZ2V0RnVydGhlc3RBd2F5IiwicGFnZUJvcmRlckJveCIsInN0YXJ0Q2VudGVyIiwiY2FuZGlkYXRlIiwiZ2V0RHJvcHBhYmxlT3ZlciQxIiwiY2hpbGRDZW50ZXIiLCJpc1N0YXJ0Q29udGFpbmVkIiwiaXNFbmRDb250YWluZWQiLCJvZmZzZXRSZWN0QnlQb3NpdGlvbiIsImFyZWEiLCJnZXRJc0Rpc3BsYWNlZCIsImF0SW5kZXgiLCJnZXRSZW9yZGVySW1wYWN0IiwidGFyZ2V0UmVjdCIsInBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsIiwidGFyZ2V0U3RhcnQiLCJ0YXJnZXRFbmQiLCJjaGlsZCIsImRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxIiwiY29tYmluZVRocmVzaG9sZERpdmlzb3IiLCJnZXRDb21iaW5lSW1wYWN0IiwiY2hpbGRSZWN0IiwiY2hpbGRTaXplIiwidGhyZXNob2xkIiwiZ2V0RHJhZ0ltcGFjdCIsInBhZ2VPZmZzZXQiLCJkZXN0aW5hdGlvbklkIiwicGF0Y2hEcm9wcGFibGVNYXAiLCJjbGVhclVudXNlZFBsYWNlaG9sZGVyIiwibm93IiwibGFzdERyb3BwYWJsZSIsInJlY29tcHV0ZVBsYWNlaG9sZGVycyIsImNsZWFuZWQiLCJwYXRjaGVkIiwiZm9yY2VkQ2xpZW50U2VsZWN0aW9uIiwiZm9yY2VkRGltZW5zaW9ucyIsImZvcmNlZFZpZXdwb3J0IiwiZm9yY2VkSW1wYWN0Iiwid2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnMiLCJnZXREcmFnZ2FibGVzJDEiLCJyZWNvbXB1dGUiLCJnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIiLCJyZWZyZXNoU25hcCIsIm1vdmVtZW50TW9kZSIsIm5lZWRzVmlzaWJpbGl0eUNoZWNrIiwiZ2V0SG9tZUxvY2F0aW9uIiwiZ2V0TGlmdEVmZmVjdCIsImluc2lkZUhvbWUiLCJyYXdJbmRleCIsImluVmlydHVhbExpc3QiLCJwYXRjaERpbWVuc2lvbk1hcCIsImZpbmlzaCIsIm9mZnNldERyYWdnYWJsZSIsIm9mZnNldCQxIiwiaW5pdGlhbFdpbmRvd1Njcm9sbCIsIm1vdmVkIiwicGxhY2Vob2xkZXIiLCJnZXRGcmFtZSIsImFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMiLCJhZGRpdGlvbnMiLCJ1cGRhdGVkRHJvcHBhYmxlcyIsIndpbmRvd1Njcm9sbENoYW5nZSIsIm1vZGlmaWVkIiwiZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlIiwidG90YWxDaGFuZ2UiLCJwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCIsInB1Ymxpc2hlZCIsIndpdGhTY3JvbGxDaGFuZ2UiLCJleGlzdGluZyIsInVwZGF0ZWRBZGRpdGlvbnMiLCJyZW1vdmFscyIsIndhc092ZXJJZCIsIndhc092ZXIiLCJfZ2V0TGlmdEVmZmVjdCIsIm9uTGlmdEltcGFjdCIsImRyYWdnaW5nU3RhdGUiLCJkcm9wUGVuZGluZyIsImlzV2FpdGluZyIsImlzU25hcHBpbmciLCJwb3N0RHJvcHBhYmxlQ2hhbmdlIiwiaXNFbmFibGVkQ2hhbmdpbmciLCJyZW1vdmVTY3JvbGxKdW1wUmVxdWVzdCIsImlkbGUiLCJjb21wbGV0ZWQiLCJzaG91bGRGbHVzaCIsInJlZHVjZXIiLCJhY3Rpb24iLCJfYWN0aW9uJHBheWxvYWQiLCJwYXlsb2FkIiwiaXNXaW5kb3dTY3JvbGxBbGxvd2VkIiwiZXZlcnkiLCJpc0ZpeGVkT25QYWdlIiwiX3Jlc3VsdCIsIl9jbGllbnRTZWxlY3Rpb24iLCJfYWN0aW9uJHBheWxvYWQyIiwiX2FjdGlvbiRwYXlsb2FkMyIsIl9pZCIsIl90YXJnZXQiLCJTdHJpbmciLCJfYWN0aW9uJHBheWxvYWQ0IiwiX2lkMiIsIl90YXJnZXQyIiwiX3VwZGF0ZWQiLCJfbmV3U2Nyb2xsIiwiX3ZpZXdwb3J0IiwiX3Jlc3VsdDIiLCJuZXdTdGF0ZSIsIl9hY3Rpb24kcGF5bG9hZDUiLCJkcm9wRHVyYXRpb24iLCJuZXdIb21lQ2xpZW50T2Zmc2V0IiwiX3Jlc3VsdDMiLCJfY29tcGxldGVkIiwiYmVmb3JlSW5pdGlhbENhcHR1cmUiLCJsaWZ0IiwiaW5pdGlhbFB1Ymxpc2giLCJwdWJsaXNoV2hpbGVEcmFnZ2luZyIsImNvbGxlY3Rpb25TdGFydGluZyIsInVwZGF0ZURyb3BwYWJsZVNjcm9sbCIsInVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCIsInVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQiLCJtb3ZlIiwibW92ZUJ5V2luZG93U2Nyb2xsIiwidXBkYXRlVmlld3BvcnRNYXhTY3JvbGwiLCJtb3ZlVXAiLCJtb3ZlRG93biIsIm1vdmVSaWdodCIsIm1vdmVMZWZ0IiwiZmx1c2giLCJhbmltYXRlRHJvcCIsImNvbXBsZXRlRHJvcCIsImRyb3AiLCJkcm9wQW5pbWF0aW9uRmluaXNoZWQiLCJjaGVja0luZGV4ZXMiLCJpbmRleGVzIiwiZXJyb3JzIiwiZm9ybWF0dGVkIiwiaGFzRXJyb3IiLCJqb2luIiwidmFsaWRhdGVEaW1lbnNpb25zIiwibGlmdCQxIiwibWFyc2hhbCIsImdldFN0YXRlIiwiZGlzcGF0Y2giLCJuZXh0Iiwic2Nyb2xsT3B0aW9ucyIsInNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSIsInJlcXVlc3QiLCJfbWFyc2hhbCRzdGFydFB1Ymxpc2giLCJzdGFydFB1Ymxpc2hpbmciLCJzdHlsZSIsImRyYWdnaW5nIiwiZHJvcHBpbmciLCJyZXN0aW5nIiwiY3VydmVzIiwib3V0T2ZUaGVXYXkiLCJvcGFjaXR5IiwiY29tYmluaW5nIiwic2NhbGUiLCJ0aW1pbmdzIiwibWluRHJvcFRpbWUiLCJtYXhEcm9wVGltZSIsIm91dE9mVGhlV2F5VGltaW5nIiwidHJhbnNpdGlvbnMiLCJmbHVpZCIsInNuYXAiLCJkdXJhdGlvbiIsInRpbWluZyIsIm1vdmVUbyIsInRyYW5zZm9ybXMiLCJpc0NvbWJpbmluZyIsInRyYW5zbGF0ZSIsImRyb3BUaW1lUmFuZ2UiLCJtYXhEcm9wVGltZUF0RGlzdGFuY2UiLCJjYW5jZWxEcm9wTW9kaWZpZXIiLCJnZXREcm9wRHVyYXRpb24iLCJkaXN0YW5jZSQxIiwicGVyY2VudGFnZSIsIndpdGhEdXJhdGlvbiIsInRvRml4ZWQiLCJnZXROZXdIb21lQ2xpZW50T2Zmc2V0IiwibmV3Q2xpZW50Q2VudGVyIiwiZ2V0RHJvcEltcGFjdCIsImxhc3RJbXBhY3QiLCJyZWNvbXB1dGVkSG9tZUltcGFjdCIsImRpZERyb3BJbnNpZGVEcm9wcGFibGUiLCJ3aXRob3V0TW92ZW1lbnQiLCJkcm9wJDEiLCJpc1dhaXRpbmdGb3JEcm9wIiwiX2dldERyb3BJbXBhY3QiLCJpc0FuaW1hdGlvblJlcXVpcmVkIiwiZ2V0V2luZG93U2Nyb2xsIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJpbmRpbmciLCJwYXNzaXZlIiwiY2FwdHVyZSIsImRvY3VtZW50IiwiZ2V0U2Nyb2xsTGlzdGVuZXIiLCJvbldpbmRvd1Njcm9sbCIsInVwZGF0ZVNjcm9sbCIsInNjaGVkdWxlZCIsImlzQWN0aXZlIiwic3RvcCIsImNhbmNlbCIsInNob3VsZEVuZCIsInNjcm9sbExpc3RlbmVyIiwic3RvcmUiLCJsaXN0ZW5lciIsImdldEV4cGlyaW5nQW5ub3VuY2UiLCJhbm5vdW5jZSIsIndhc0NhbGxlZCIsImlzRXhwaXJlZCIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRBc3luY01hcnNoYWwiLCJlbnRyaWVzIiwiZXhlY3V0ZSIsInRpbWVySWQiLCJfZW50cmllcyRzcGxpY2UiLCJzcGxpY2UiLCJlbnRyeSIsImNhbGxiYWNrIiwic2hhbGxvdyIsImFyZUxvY2F0aW9uc0VxdWFsIiwiaXNDb21iaW5lRXF1YWwiLCJpc0NyaXRpY2FsRXF1YWwiLCJpc0RyYWdnYWJsZUVxdWFsIiwiaXNEcm9wcGFibGVFcXVhbCIsIndpdGhUaW1pbmdzIiwiZ2V0RHJhZ1N0YXJ0IiwicmVzcG9uZGVyIiwiZGF0YSIsImdldERlZmF1bHRNZXNzYWdlIiwid2lsbEV4cGlyZSIsInByb3ZpZGVkIiwiZ2V0UHVibGlzaGVyIiwiZ2V0UmVzcG9uZGVycyIsImFzeW5jTWFyc2hhbCIsImJlZm9yZUNhcHR1cmUiLCJvbkJlZm9yZUNhcHR1cmUiLCJiZWZvcmVTdGFydCIsIm9uQmVmb3JlRHJhZ1N0YXJ0IiwibGFzdENyaXRpY2FsIiwibGFzdExvY2F0aW9uIiwibGFzdENvbWJpbmUiLCJoYXNDcml0aWNhbENoYW5nZWQiLCJoYXNMb2NhdGlvbkNoYW5nZWQiLCJoYXNHcm91cGluZ0NoYW5nZWQiLCJhYm9ydCIsInJlc3BvbmRlcnMiLCJwdWJsaXNoZXIiLCJkcm9wQW5pbWF0aW9uRmluaXNoIiwiZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGwiLCJmcmFtZUlkIiwiY2xlYXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm9uY2UiLCJmbHVzaERyb3BBbmltYXRpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkaW1lbnNpb25NYXJzaGFsU3RvcHBlciIsInN0b3BQdWJsaXNoaW5nIiwiZm9jdXMiLCJpc1dhdGNoaW5nIiwidHJ5UmVjb3JkRm9jdXMiLCJ0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCIsInRyeVNoaWZ0UmVjb3JkIiwic2hvdWxkU3RvcCIsImF1dG9TY3JvbGwiLCJhdXRvU2Nyb2xsZXIiLCJwZW5kaW5nRHJvcCIsInBvc3RBY3Rpb25TdGF0ZSIsImNvbXBvc2VFbmhhbmNlcnMiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJuYW1lIiwiZGltZW5zaW9uTWFyc2hhbCIsImZvY3VzTWFyc2hhbCIsInN0eWxlTWFyc2hhbCIsImNsZWFuJDEiLCJjcmVhdGVQdWJsaXNoZXIiLCJyZWdpc3RyeSIsInN0YWdpbmciLCJjb2xsZWN0IiwiX3N0YWdpbmciLCJnZXRCeUlkIiwiZ2V0RGltZW5zaW9uIiwiZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyIsInB1Ymxpc2giLCJnZXRNYXhTY3JvbGwiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImFkanVzdGVkTWF4U2Nyb2xsIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0TWF4V2luZG93U2Nyb2xsIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJnZXRWaWV3cG9ydCIsImdldEluaXRpYWxQdWJsaXNoIiwid2luZG93U2Nyb2xsIiwiZ2V0QWxsQnlUeXBlIiwiZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwiLCJzaG91bGRQdWJsaXNoVXBkYXRlIiwiY3JlYXRlRGltZW5zaW9uTWFyc2hhbCIsImNvbGxlY3Rpb24iLCJleGlzdHMiLCJjaGFuZ2UiLCJkcmFnU3RvcHBlZCIsInVuc3Vic2NyaWJlIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsImNhblN0YXJ0RHJhZyIsInNjcm9sbFdpbmRvdyIsInNjcm9sbEJ5IiwiZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMiLCJnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlciIsIm1heWJlIiwiZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUiLCJfZGltZW5zaW9uIiwiY29uZmlnIiwic3RhcnRGcm9tUGVyY2VudGFnZSIsIm1heFNjcm9sbEF0UGVyY2VudGFnZSIsIm1heFBpeGVsU2Nyb2xsIiwiZWFzZSIsImR1cmF0aW9uRGFtcGVuaW5nIiwic3RvcERhbXBlbmluZ0F0IiwiYWNjZWxlcmF0ZUF0IiwiZ2V0RGlzdGFuY2VUaHJlc2hvbGRzIiwiY29udGFpbmVyIiwic3RhcnRTY3JvbGxpbmdGcm9tIiwibWF4U2Nyb2xsVmFsdWVBdCIsInRocmVzaG9sZHMiLCJnZXRQZXJjZW50YWdlIiwic3RhcnRPZlJhbmdlIiwiZW5kT2ZSYW5nZSIsInJhbmdlIiwiY3VycmVudEluUmFuZ2UiLCJtaW5TY3JvbGwiLCJnZXRWYWx1ZUZyb21EaXN0YW5jZSIsImRpc3RhbmNlVG9FZGdlIiwicGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0IiwicGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20iLCJjZWlsIiwic3RvcEF0IiwiZGFtcGVuVmFsdWVCeVRpbWUiLCJwcm9wb3NlZFNjcm9sbCIsImRyYWdTdGFydFRpbWUiLCJEYXRlIiwicnVuVGltZSIsImJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlIiwiZ2V0VmFsdWUiLCJzaG91bGRVc2VUaW1lRGFtcGVuaW5nIiwiZ2V0U2Nyb2xsT25BeGlzIiwiZGlzdGFuY2VUb0VkZ2VzIiwiaXNDbG9zZXJUb0VuZCIsImFkanVzdEZvclNpemVMaW1pdHMiLCJpc1Rvb0JpZ1ZlcnRpY2FsbHkiLCJpc1Rvb0JpZ0hvcml6b250YWxseSIsImNsZWFuJDIiLCJnZXRTY3JvbGwiLCJyZXF1aXJlZCIsImxpbWl0ZWQiLCJzbWFsbGVzdFNpZ25lZCIsImdldE92ZXJsYXAiLCJnZXRSZW1haW5kZXIiLCJ0YXJnZXRTY3JvbGwiLCJvdmVybGFwIiwiY2FuUGFydGlhbGx5U2Nyb2xsIiwicmF3TWF4Iiwic21hbGxlc3RDaGFuZ2UiLCJjYW5TY3JvbGxXaW5kb3ciLCJnZXRXaW5kb3dPdmVybGFwIiwiY2FuU2Nyb2xsRHJvcHBhYmxlIiwiZ2V0RHJvcHBhYmxlT3ZlcmxhcCIsImdldFdpbmRvd1Njcm9sbENoYW5nZSIsImdldERyb3BwYWJsZVNjcm9sbENoYW5nZSIsInNjcm9sbCQxIiwiX2NoYW5nZSIsImNyZWF0ZUZsdWlkU2Nyb2xsZXIiLCJzY2hlZHVsZVdpbmRvd1Njcm9sbCIsInNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsIiwidHJ5U2Nyb2xsIiwiX2RyYWdnaW5nIiwic3RhcnQkMSIsIndhc1Njcm9sbE5lZWRlZCIsImZha2VTY3JvbGxDYWxsYmFjayIsImNyZWF0ZUp1bXBTY3JvbGxlciIsIm1vdmVCeU9mZnNldCIsInNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4iLCJ3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsIiwicmVtYWluZGVyIiwic2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiIsIndoYXRUaGVXaW5kb3dDYW5TY3JvbGwiLCJqdW1wU2Nyb2xsZXIiLCJkcm9wcGFibGVSZW1haW5kZXIiLCJ3aW5kb3dSZW1haW5kZXIiLCJjcmVhdGVBdXRvU2Nyb2xsZXIiLCJmbHVpZFNjcm9sbGVyIiwianVtcFNjcm9sbCIsInNjcm9sbGVyIiwicHJlZml4JDEiLCJkcmFnSGFuZGxlIiwiYmFzZSIsImNvbnRleHRJZCIsInNjcm9sbENvbnRhaW5lciIsIm1ha2VHZXRTZWxlY3RvciIsImNvbnRleHQiLCJhdHRyaWJ1dGUiLCJnZXRTdHlsZXMiLCJydWxlcyIsInByb3BlcnR5IiwicnVsZSIsInN0eWxlcyIsInNlbGVjdG9yIiwibm9Qb2ludGVyRXZlbnRzIiwiZ2V0U3R5bGVzJDEiLCJnZXRTZWxlY3RvciIsImRyYWdIYW5kbGUkMSIsImdyYWJDdXJzb3IiLCJhbHdheXMiLCJkcm9wQW5pbWF0aW5nIiwiZHJhZ2dhYmxlJDEiLCJ0cmFuc2l0aW9uIiwidXNlckNhbmNlbCIsImRyb3BwYWJsZSQxIiwiYm9keSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiZ2V0SGVhZCIsImhlYWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlU3R5bGVFbCIsIm5vbmNlIiwic2V0QXR0cmlidXRlIiwidXNlU3R5bGVNYXJzaGFsIiwiYWx3YXlzUmVmIiwiZHluYW1pY1JlZiIsInNldER5bmFtaWNTdHlsZSIsInRleHRDb250ZW50Iiwic2V0QWx3YXlzU3R5bGUiLCJkeW5hbWljIiwiYXBwZW5kQ2hpbGQiLCJyZWYiLCJyZW1vdmVDaGlsZCIsImdldFdpbmRvd0Zyb21FbCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzSHRtbEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImZpbmREcmFnSGFuZGxlIiwicG9zc2libGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaGFuZGxlIiwiZ2V0QXR0cmlidXRlIiwidXNlRm9jdXNNYXJzaGFsIiwiZW50cmllc1JlZiIsInJlY29yZFJlZiIsInJlc3RvcmVGb2N1c0ZyYW1lUmVmIiwiaXNNb3VudGVkUmVmIiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwidHJ5R2l2ZUZvY3VzIiwidHJ5R2l2ZUZvY3VzVG8iLCJhY3RpdmVFbGVtZW50IiwicmVkaXJlY3RUbyIsInJlY29yZCIsImZvY3VzZWQiLCJjbGVhckZyYW1lT25Vbm1vdW50IiwiY3JlYXRlUmVnaXN0cnkiLCJzdWJzY3JpYmVycyIsImNiIiwibm90aWZ5IiwiZmluZERyYWdnYWJsZUJ5SWQiLCJnZXREcmFnZ2FibGVCeUlkIiwiZHJhZ2dhYmxlQVBJIiwidW5pcXVlSWQiLCJmaW5kQnlJZCIsImZpbmREcm9wcGFibGVCeUlkIiwiZ2V0RHJvcHBhYmxlQnlJZCIsImRyb3BwYWJsZUFQSSIsInVzZVJlZ2lzdHJ5IiwidW5tb3VudCIsIlN0b3JlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJnZXRCb2R5RWxlbWVudCIsInZpc3VhbGx5SGlkZGVuIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiZ2V0SWQiLCJ1c2VBbm5vdW5jZXIiLCJzZXR1cCIsImNsZWFudXAiLCJjb3VudCIsImRlZmF1bHRzIiwic2VwYXJhdG9yIiwicmVzZXQiLCJ1c2VVbmlxdWVJZCIsImdldEVsZW1lbnRJZCIsInVzZUhpZGRlblRleHRFbGVtZW50IiwidGV4dCIsIm1vdW50IiwiZGlzcGxheSIsIkFwcENvbnRleHQiLCJwZWVyRGVwZW5kZW5jaWVzIiwicmVhY3QiLCJzZW12ZXIiLCJnZXRWZXJzaW9uIiwiZXhlYyIsIm1ham9yIiwibWlub3IiLCJyYXciLCJpc1NhdGlzZmllZCIsImV4cGVjdGVkIiwiYWN0dWFsIiwiY2hlY2tSZWFjdFZlcnNpb24iLCJwZWVyRGVwVmFsdWUiLCJhY3R1YWxWYWx1ZSIsInBlZXJEZXAiLCJzdWZmaXgiLCJjaGVja0RvY3R5cGUiLCJkb2N0eXBlIiwidG9Mb3dlckNhc2UiLCJwdWJsaWNJZCIsInVzZURldiIsInVzZUhvb2siLCJ1c2VEZXZTZXR1cFdhcm5pbmciLCJpbnB1dHMiLCJlIiwidXNlU3RhcnR1cFZhbGlkYXRpb24iLCJ2ZXJzaW9uIiwidXNlUHJldmlvdXMiLCJjcmVhdGUiLCJsb2NrIiwiaXNDbGFpbWVkIiwiY2xhaW0iLCJhYmFuZG9uIiwibmV3TG9jayIsInJlbGVhc2UiLCJ0cnlBYmFuZG9uIiwidGFiIiwiZW50ZXIiLCJlc2NhcGUiLCJzcGFjZSIsInBhZ2VVcCIsInBhZ2VEb3duIiwiYXJyb3dMZWZ0IiwiYXJyb3dVcCIsImFycm93UmlnaHQiLCJhcnJvd0Rvd24iLCJfcHJldmVudGVkS2V5cyIsInByZXZlbnRlZEtleXMiLCJwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMiLCJrZXlDb2RlIiwic3VwcG9ydGVkRXZlbnROYW1lIiwic3VwcG9ydGVkIiwicHJpbWFyeUJ1dHRvbiIsInNsb3BweUNsaWNrVGhyZXNob2xkIiwiaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkIiwiYWJzIiwiaWRsZSQxIiwiZ2V0Q2FwdHVyZUJpbmRpbmdzIiwiZ2V0UGhhc2UiLCJzZXRQaGFzZSIsImJ1dHRvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiYWN0aW9ucyIsInBlbmRpbmciLCJmbHVpZExpZnQiLCJzaG91bGRCbG9ja05leHRDbGljayIsInNob3VsZFJlc3BlY3RGb3JjZVByZXNzIiwidXNlTW91c2VTZW5zb3IiLCJhcGkiLCJwaGFzZVJlZiIsInVuYmluZEV2ZW50c1JlZiIsInN0YXJ0Q2FwdHVyZUJpbmRpbmciLCJvbk1vdXNlRG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwiZmluZENsb3Nlc3REcmFnZ2FibGVJZCIsInRyeUdldExvY2siLCJzb3VyY2VFdmVudCIsInN0YXJ0UGVuZGluZ0RyYWciLCJwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmciLCJmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSIsImNhbkdldExvY2siLCJsaXN0ZW5Gb3JDYXB0dXJlIiwiYmluZENhcHR1cmluZ0V2ZW50cyIsIl9zY3JvbGxKdW1wS2V5cyIsIm5vb3AkMSIsInNjcm9sbEp1bXBLZXlzIiwiZ2V0RHJhZ2dpbmdCaW5kaW5ncyIsInVzZUtleWJvYXJkU2Vuc29yIiwib25LZXlEb3duIiwicHJlRHJhZyIsImlzQ2FwdHVyaW5nIiwic25hcExpZnQiLCJ0cnlTdGFydENhcHR1cmUiLCJpZGxlJDIiLCJ0aW1lRm9yTG9uZ1ByZXNzIiwiZm9yY2VQcmVzc1RocmVzaG9sZCIsImdldFdpbmRvd0JpbmRpbmdzIiwiZ2V0SGFuZGxlQmluZGluZ3MiLCJoYXNNb3ZlZCIsIl9ldmVudCR0b3VjaGVzJCIsInRvdWNoZXMiLCJ0b3VjaCIsImlzRm9yY2VQcmVzcyIsImZvcmNlIiwic2hvdWxkUmVzcGVjdCIsInVzZVRvdWNoU2Vuc29yIiwib25Ub3VjaFN0YXJ0IiwibG9uZ1ByZXNzVGltZXJJZCIsInVuYmluZFRhcmdldCIsInVuYmluZFdpbmRvdyIsInN0YXJ0RHJhZ2dpbmciLCJ3ZWJraXRIYWNrIiwidXNlVmFsaWRhdGVTZW5zb3JIb29rcyIsInNlbnNvckhvb2tzIiwicHJldmlvdXNSZWYiLCJpbnRlcmFjdGl2ZVRhZ05hbWVzIiwiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsIm9wdGlvbiIsIm9wdGdyb3VwIiwidmlkZW8iLCJhdWRpbyIsImlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJwYXJlbnQiLCJoYXNBbkludGVyYWN0aXZlVGFnIiwidGFnTmFtZSIsInBhcmVudEVsZW1lbnQiLCJpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbiIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJzdXBwb3J0ZWRNYXRjaGVzTmFtZSIsImNsb3Nlc3RQb255ZmlsbCIsImNsb3Nlc3QkMSIsImZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudCIsInRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudCIsImZpbmREcmFnZ2FibGUiLCJfaXNBY3RpdmUiLCJpc0xvY2tBY3RpdmUiLCJzaG91bGRXYXJuIiwiY2FuU3RhcnQiLCJsb2NrQVBJIiwidHJ5U3RhcnQiLCJmb3JjZVNlbnNvclN0b3AiLCJzaG91bGRTdGFydCIsImNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzIiwiZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MiLCJ0cnlEaXNwYXRjaCIsImdldEFjdGlvbiIsInRyeURpc3BhdGNoV2hlbkRyYWdnaW5nIiwibGlmdEFjdGlvbkFyZ3MiLCJtb3ZlJDEiLCJtb3ZlVXAkMSIsIm1vdmVSaWdodCQxIiwibW92ZURvd24kMSIsIm1vdmVMZWZ0JDEiLCJhYm9ydFByZURyYWciLCJzaG91bGRSZWxlYXNlIiwiZGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JNYXJzaGFsIiwiX3JlZjQiLCJjdXN0b21TZW5zb3JzIiwiZW5hYmxlRGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JzIiwidHJ5QWJhbmRvbkxvY2siLCJsaXN0ZW5Ub1N0b3JlIiwiZm9yY2VTdG9wIiwidHJ5UmVsZWFzZUxvY2siLCJpc0xvY2tDbGFpbWVkIiwiY3JlYXRlUmVzcG9uZGVycyIsImdldFN0b3JlIiwibGF6eVJlZiIsIkFwcCIsInNlbnNvcnMiLCJsYXp5U3RvcmVSZWYiLCJsYXN0UHJvcHNSZWYiLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCIsImxhenlEaXNwYXRjaCIsIm1hcnNoYWxDYWxsYmFja3MiLCJ0cnlSZXNldFN0b3JlIiwiYXBwQ2FsbGJhY2tzIiwiZ2V0Q2FuTGlmdCIsImdldElzTW92ZW1lbnRBbGxvd2VkIiwiYXBwQ29udGV4dCIsImNhbkxpZnQiLCJjb3VudCQxIiwicmVzZXQkMSIsInVzZUluc3RhbmNlQ291bnQiLCJyZXNldFNlcnZlckNvbnRleHQiLCJEcmFnRHJvcENvbnRleHQiLCJpc0VxdWFsJDEiLCJpc1Njcm9sbCIsImlzQXV0byIsImlzVmlzaWJsZSQxIiwiaXNFaXRoZXIiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJpc0JvdGgiLCJpc0VsZW1lbnRTY3JvbGxhYmxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzQm9keVNjcm9sbGFibGUiLCJodG1sIiwiaHRtbFN0eWxlIiwiaHRtbE92ZXJmbG93IiwiZ2V0Q2xvc2VzdFNjcm9sbGFibGUiLCJjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMiLCJhbm90aGVyU2Nyb2xsUGFyZW50IiwiZ2V0U2Nyb2xsJDEiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiZ2V0SXNGaXhlZCIsImdldEVudiIsImNsb3Nlc3RTY3JvbGxhYmxlIiwiZ2V0RHJvcHBhYmxlRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImZyYW1lQ2xpZW50IiwicGFkZGluZ0JveCIsImdldENsaWVudCIsInRhcmdldFJlZiIsImVudiIsImlzRHJvcERpc2FibGVkIiwiaW1tZWRpYXRlIiwiZGVsYXllZCIsImdldExpc3RlbmVyT3B0aW9ucyIsInVzZVJlcXVpcmVkQ29udGV4dCIsIkNvbnRleHQiLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnIiwidXNlRHJvcHBhYmxlUHVibGlzaGVyIiwid2hpbGVEcmFnZ2luZ1JlZiIsInB1Ymxpc2hlZERlc2NyaXB0b3JSZWYiLCJtZW1vaXplZFVwZGF0ZVNjcm9sbCIsImdldENsb3Nlc3RTY3JvbGwiLCJzY2hlZHVsZVNjcm9sbFVwZGF0ZSIsIm9uQ2xvc2VzdFNjcm9sbCIsImdldERyb3BwYWJsZVJlZiIsImlnbm9yZUNvbnRhaW5lckNsaXBwaW5nIiwicmVtb3ZlQXR0cmlidXRlIiwibm9vcCQyIiwiZW1wdHkiLCJnZXRTaXplIiwiaXNBbmltYXRpbmdPcGVuT25Nb3VudCIsImFuaW1hdGUiLCJnZXRTdHlsZSIsImJveFNpemluZyIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImZsZXhTaHJpbmsiLCJmbGV4R3JvdyIsInBvaW50ZXJFdmVudHMiLCJQbGFjZWhvbGRlciIsImFuaW1hdGVPcGVuVGltZXJSZWYiLCJ0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIiLCJvblRyYW5zaXRpb25FbmQiLCJvbkNsb3NlIiwiX3VzZVN0YXRlIiwic2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudCIsIm9uU2l6ZUNoYW5nZUVuZCIsInByb3BlcnR5TmFtZSIsImlubmVyUmVmIiwiUGxhY2Vob2xkZXIkMSIsIm1lbW8iLCJEcm9wcGFibGVDb250ZXh0IiwiY2hlY2tJc1ZhbGlkSW5uZXJSZWYiLCJpc0Jvb2xlYW4iLCJydW5DaGVja3MiLCJjaGVja3MiLCJjaGVjayIsIl9ib29sZWFuIiwic3RhbmRhcmQiLCJnZXRQbGFjZWhvbGRlclJlZiIsInZpcnR1YWwiLCJoYXNDbG9uZSIsIl9yZWY1IiwicmVuZGVyQ2xvbmUiLCJoYXNOb1BsYWNlaG9sZGVyIiwiX3JlZjYiLCJ1c2VWYWxpZGF0aW9uIiwiQW5pbWF0ZUluT3V0IiwiX1JlYWN0JFB1cmVDb21wb25lbnQiLCJvbiIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIlB1cmVDb21wb25lbnQiLCJ6SW5kZXhPcHRpb25zIiwiZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uIiwic2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCIsImdldERyYWdnaW5nT3BhY2l0eSIsImlzRHJvcEFuaW1hdGluZyIsImdldFNob3VsZERyYWdnaW5nQW5pbWF0ZSIsImdldERyYWdnaW5nU3R5bGUiLCJ0cmFuc2Zvcm0iLCJ6SW5kZXgiLCJnZXRTZWNvbmRhcnlTdHlsZSIsInNlY29uZGFyeSIsInNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQiLCJnZXRTdHlsZSQxIiwibWFwcGVkIiwiZ2V0RGltZW5zaW9uJDEiLCJjb21wdXRlZFN0eWxlcyIsInVzZURyYWdnYWJsZVB1Ymxpc2hlciIsImdldERyYWdnYWJsZVJlZiIsInB1Ymxpc2hlZFJlZiIsImlzRmlyc3RQdWJsaXNoUmVmIiwidXNlVmFsaWRhdGlvbiQxIiwiZ2V0UmVmIiwidXNlQ2xvbmVQcm9wVmFsaWRhdGlvbiIsImlzQ2xvbmUiLCJpbml0aWFsUmVmIiwicHJldmVudEh0bWw1RG5kIiwiRHJhZ2dhYmxlIiwic2V0UmVmIiwiX3VzZVJlcXVpcmVkQ29udGV4dCIsIl91c2VSZXF1aXJlZENvbnRleHQyIiwiZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uIiwiZm9yUHVibGlzaGVyIiwiZHJhZ0hhbmRsZVByb3BzIiwidGFiSW5kZXgiLCJyb2xlIiwib25Nb3ZlRW5kIiwiZHJhZ2dhYmxlUHJvcHMiLCJydWJyaWMiLCJzbmFwc2hvdCIsImlzU3RyaWN0RXF1YWwiLCJ3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQiLCJnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQiLCJnZXRDb21iaW5lV2l0aEZyb21JbXBhY3QiLCJnZXREcmFnZ2FibGVTZWxlY3RvciIsIm1lbW9pemVkT2Zmc2V0IiwiZ2V0TWVtb2l6ZWRTbmFwc2hvdCIsImRyYWdnaW5nT3ZlciIsImRyb3BBbmltYXRpb24iLCJjb21iaW5lVGFyZ2V0Rm9yIiwiZ2V0TWVtb2l6ZWRQcm9wcyIsIm93blByb3BzIiwiX2RyYWdnaW5nT3ZlciIsIl9jb21iaW5lV2l0aCIsImN1cnZlIiwiZ2V0U2Vjb25kYXJ5U25hcHNob3QiLCJhdFJlc3QiLCJnZXRTZWNvbmRhcnlTZWxlY3RvciIsImdldEZhbGxiYWNrIiwiZ2V0UHJvcHMiLCJvd25JZCIsImRyYWdnaW5nSWQiLCJ2aXN1YWxEaXNwbGFjZW1lbnQiLCJpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0IiwiX29mZnNldCIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMiLCJkcmFnZ2luZ1NlbGVjdG9yIiwic2Vjb25kYXJ5U2VsZWN0b3IiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJDb25uZWN0ZWREcmFnZ2FibGUiLCJwdXJlIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiUHJpdmF0ZURyYWdnYWJsZSIsImRyb3BwYWJsZUNvbnRleHQiLCJpc1VzaW5nQ2xvbmVGb3IiLCJQdWJsaWNEcmFnZ2FibGUiLCJpc0RyYWdEaXNhYmxlZCIsImRpc2FibGVJbnRlcmFjdGl2ZUVsZW1lbnRCbG9ja2luZyIsIkRyb3BwYWJsZSIsImRyb3BwYWJsZVJlZiIsInBsYWNlaG9sZGVyUmVmIiwidXNlQ2xvbmUiLCJnZXRDb250YWluZXJGb3JDbG9uZSIsInNldERyb3BwYWJsZVJlZiIsInNldFBsYWNlaG9sZGVyUmVmIiwib25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQiLCJzaG91bGRBbmltYXRlUGxhY2Vob2xkZXIiLCJkcm9wcGFibGVQcm9wcyIsImdldENsb25lIiwibm9kZSIsImRyYWdnYWJsZVByb3ZpZGVkIiwiZHJhZ2dhYmxlU25hcHNob3QiLCJjcmVhdGVQb3J0YWwiLCJpc01hdGNoaW5nVHlwZSIsImdldERyYWdnYWJsZSIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMkMSIsImlkbGVXaXRoQW5pbWF0aW9uIiwiaXNEcmFnZ2luZ092ZXIiLCJkcmFnZ2luZ092ZXJXaXRoIiwiZHJhZ2dpbmdGcm9tVGhpc1dpdGgiLCJpc1VzaW5nUGxhY2Vob2xkZXIiLCJpZGxlV2l0aG91dEFuaW1hdGlvbiIsImdldERyYWdnYWJsZVJ1YnJpYyIsImdldE1hcFByb3BzIiwiaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciIsImlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0IiwiaXNIb21lIiwiX3NuYXBzaG90Iiwid2FzQ29tYmluaW5nIiwibWFwRGlzcGF0Y2hUb1Byb3BzJDEiLCJnZXRCb2R5IiwiZGVmYXVsdFByb3BzIiwiQ29ubmVjdGVkRHJvcHBhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js\n");

/***/ })

};
;